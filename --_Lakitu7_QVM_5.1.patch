Index: src/server/sv_ccmds.c
===================================================================
--- src/server/sv_ccmds.c	(revision 966)
+++ src/server/sv_ccmds.c	(working copy)
@@ -239,11 +239,6 @@
 	else {
 		delay = 5;
 	}
-	if( delay && !Cvar_VariableValue("g_doWarmup") ) {
-		sv.restartTime = sv.time + delay * 1000;
-		SV_SetConfigstring( CS_WARMUP, va("%i", sv.restartTime) );
-		return;
-	}
 
 	// check for changes in variables that can't just be restarted
 	// check for maxclients change
Index: src/server/server.h
===================================================================
--- src/server/server.h	(revision 966)
+++ src/server/server.h	(working copy)
@@ -228,6 +228,8 @@
 extern	cvar_t	*sv_rconPassword;
 extern	cvar_t	*sv_privatePassword;
 extern	cvar_t	*sv_allowDownload;
+extern	cvar_t	*sv_wwwDownload;
+extern	cvar_t	*sv_wwwBaseURL;
 extern	cvar_t	*sv_maxclients;
 
 extern	cvar_t	*sv_privateClients;
Index: src/server/sv_init.c
===================================================================
--- src/server/sv_init.c	(revision 966)
+++ src/server/sv_init.c	(working copy)
@@ -611,6 +611,10 @@
 
 	sv_allowDownload = Cvar_Get ("sv_allowDownload", "0", CVAR_SERVERINFO);
 	Cvar_Get ("sv_dlURL", "", CVAR_SERVERINFO | CVAR_ARCHIVE);
+	sv_wwwDownload = Cvar_Get ("sv_wwwDownload", "1",
+		CVAR_SYSTEMINFO|CVAR_ARCHIVE);
+	sv_wwwBaseURL = Cvar_Get ("sv_wwwBaseURL", "",
+		CVAR_SYSTEMINFO|CVAR_ARCHIVE);
 	sv_master[0] = Cvar_Get ("sv_master1", MASTER_SERVER_NAME, 0 );
 	sv_master[1] = Cvar_Get ("sv_master2", "", CVAR_ARCHIVE );
 	sv_master[2] = Cvar_Get ("sv_master3", "", CVAR_ARCHIVE );
Index: src/server/sv_main.c
===================================================================
--- src/server/sv_main.c	(revision 966)
+++ src/server/sv_main.c	(working copy)
@@ -33,6 +33,8 @@
 cvar_t	*sv_rconPassword;		// password for remote server commands
 cvar_t	*sv_privatePassword;	// password for the privateClient slots
 cvar_t	*sv_allowDownload;
+cvar_t	*sv_wwwBaseURL;
+cvar_t	*sv_wwwDownload;
 cvar_t	*sv_maxclients;
 
 cvar_t	*sv_privateClients;		// number of clients reserved for password
Index: src/qcommon/q_shared.h
===================================================================
--- src/qcommon/q_shared.h	(revision 966)
+++ src/qcommon/q_shared.h	(working copy)
@@ -1317,5 +1317,8 @@
 #define SAY_ALL		0
 #define SAY_TEAM	1
 #define SAY_TELL	2
+#define SAY_ACTION      3
+#define SAY_ACTION_T    4
+#define SAY_ADMINS    5
 
 #endif	// __Q_SHARED_H
Index: src/game/g_spawn.c
===================================================================
--- src/game/g_spawn.c	(revision 966)
+++ src/game/g_spawn.c	(working copy)
@@ -662,20 +662,8 @@
   g_entities[ ENTITYNUM_WORLD ].s.number = ENTITYNUM_WORLD;
   g_entities[ ENTITYNUM_WORLD ].classname = "worldspawn";
 
-  // see if we want a warmup time
-  trap_SetConfigstring( CS_WARMUP, "" );
   if( g_restarted.integer )
-  {
     trap_Cvar_Set( "g_restarted", "0" );
-    level.warmupTime = 0;
-  }
-  else if( g_doWarmup.integer )
-  {
-    // Turn it on
-    level.warmupTime = -1;
-    trap_SetConfigstring( CS_WARMUP, va( "%i", level.warmupTime ) );
-    G_LogPrintf( "Warmup:\n" );
-  }
 
 }
 
Index: src/game/bg_misc.c
===================================================================
--- src/game/bg_misc.c	(revision 966)
+++ src/game/bg_misc.c	(working copy)
@@ -68,7 +68,8 @@
     ASPAWN_CREEPSIZE,      //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_BARRICADE,        //int       buildNum;
@@ -104,7 +105,8 @@
     BARRICADE_CREEPSIZE,   //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replaceable;
   },
   {
     BA_A_BOOSTER,          //int       buildNum;
@@ -140,7 +142,8 @@
     BOOSTER_CREEPSIZE,     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_A_ACIDTUBE,         //int       buildNum;
@@ -176,7 +179,8 @@
     ACIDTUBE_CREEPSIZE,    //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_HIVE,             //int       buildNum;
@@ -212,7 +216,8 @@
     HIVE_CREEPSIZE,        //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_TRAPPER,          //int       buildNum;
@@ -248,7 +253,8 @@
     TRAPPER_CREEPSIZE,     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_OVERMIND,         //int       buildNum;
@@ -284,7 +290,8 @@
     OVERMIND_CREEPSIZE,    //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_A_HOVEL,            //int       buildNum;
@@ -320,7 +327,8 @@
     HOVEL_CREEPSIZE,       //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_SPAWN,            //int       buildNum;
@@ -356,7 +364,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_MEDISTAT,         //int       buildNum;
@@ -392,7 +401,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_MGTURRET,         //int       buildNum;
@@ -430,7 +440,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_TESLAGEN,         //int       buildNum;
@@ -466,7 +477,8 @@
     0,                     //int       creepSize;
     qtrue,                 //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_DCC,              //int       buildNum;
@@ -502,7 +514,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_ARMOURY,          //int       buildNum;
@@ -538,7 +551,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_REACTOR,          //int       buildNum;
@@ -574,7 +588,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_REPEATER,         //int       buildNum;
@@ -610,7 +625,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   }
 };
 
@@ -1306,6 +1322,25 @@
 
 /*
 ==============
+BG_FindReplaceableTestForBuildable
+==============
+*/
+qboolean BG_FindReplaceableTestForBuildable( int bclass )
+{
+  int i;
+
+  for( i = 0; i < bg_numBuildables; i++ )
+  {
+    if( bg_buildableList[ i ].buildNum == bclass )
+    {
+      return bg_buildableList[ i ].replaceable;
+    }
+  }
+  return qfalse;
+}
+
+/*
+==============
 BG_FindOverrideForBuildable
 ==============
 */
@@ -5224,15 +5259,13 @@
 
 /*
 ===============
-BG_GetValueOfHuman
+BG_GetValueOfEquipment
 
-Returns the kills value of some human player
+Returns the equipment value of some human player's gear
 ===============
 */
-int BG_GetValueOfHuman( playerState_t *ps )
-{
-  int     i, worth = 0;
-  float   portion;
+  int BG_GetValueOfEquipment( playerState_t *ps ) {
+  int i, worth = 0;
 
   for( i = UP_NONE + 1; i < UP_NUM_UPGRADES; i++ )
   {
@@ -5246,8 +5279,20 @@
       worth += BG_FindPriceForWeapon( i );
   }
 
-  portion = worth / (float)HUMAN_MAXED;
+    return worth;
+  }
+/*
+===============
+BG_GetValueOfHuman
 
+Returns the kills value of some human player
+===============
+*/
+int BG_GetValueOfHuman( playerState_t *ps )
+{
+  float portion = BG_GetValueOfEquipment( ps ) / (float)HUMAN_MAXED;
+
+
   if( portion < 0.01f )
     portion = 0.01f;
   else if( portion > 1.0f )
Index: src/game/tremulous.h
===================================================================
--- src/game/tremulous.h	(revision 966)
+++ src/game/tremulous.h	(working copy)
@@ -320,8 +320,8 @@
 
 #define ALIENSENSE_RANGE            1000.0f
 
-#define ALIEN_POISON_TIME           10000
-#define ALIEN_POISON_DMG            30
+#define ALIEN_POISON_TIME           5000
+#define ALIEN_POISON_DMG            5
 #define ALIEN_POISON_DIVIDER        (1.0f/1.32f) //about 1.0/(time`th root of damage)
 
 #define ALIEN_SPAWN_REPEAT_TIME     10000
@@ -452,9 +452,11 @@
  */
 
 #define LIGHTARMOUR_PRICE           70
+#define LIGHTARMOUR_POISON_PROTECTION 1
 
 #define HELMET_PRICE                90
 #define HELMET_RANGE                1000.0f
+#define HELMET_POISON_PROTECTION    2 
 
 #define MEDKIT_PRICE                0
 
@@ -468,6 +470,7 @@
 #define JETPACK_DISABLE_CHANCE      0.3f
 
 #define BSUIT_PRICE                 400
+#define BSUIT_POISON_PROTECTION     4
 
 #define MGCLIP_PRICE                0
 
@@ -475,7 +478,7 @@
 
 #define GAS_PRICE                   0
 
-#define MEDKIT_POISON_IMMUNITY_TIME 30000
+#define MEDKIT_POISON_IMMUNITY_TIME 0
 #define MEDKIT_STARTUP_TIME         4000
 #define MEDKIT_STARTUP_SPEED        5
 
@@ -615,3 +618,8 @@
 
 #define DAMAGE_FRACTION_FOR_KILL    0.5f //how much damage players (versus structures) need to
                                          //do to increment the stage kill counters
+
+// g_suddenDeathMode settings
+#define SDMODE_BP                   0 
+#define SDMODE_NO_BUILD             1
+#define SDMODE_SELECTIVE            2
Index: src/game/g_svcmds.c
===================================================================
--- src/game/g_svcmds.c	(revision 966)
+++ src/game/g_svcmds.c	(working copy)
@@ -722,7 +722,29 @@
     }
     else if( !Q_stricmp( cmd, "cp" ) )
     {
-      trap_SendServerCommand( -1, va( "cp \"%s\"", ConcatArgs( 1 ) ) );
+      int i, j;
+      char buffer[MAX_STRING_CHARS];
+      Q_strncpyz( buffer, ConcatArgs( 1 ), sizeof( buffer ) );
+      for( i = j = 0; i < strlen( buffer ); i++, j++ )
+      {
+	if(!buffer[i]) break;
+	if(buffer[i] == '\\')
+	{
+	    if(buffer[i + 1] == '\\')
+		buffer[j] = buffer[++i];
+	    else if(buffer[i + 1] == 'n')
+	    {
+		buffer[j] = '\n';
+		i++;
+	    }
+	    else
+		buffer[j] = buffer[i];
+	}
+	else
+	    buffer[j] = buffer[i];
+      }
+      buffer[j] = 0;
+      trap_SendServerCommand( -1, va( "cp \"%s\"", buffer ) );
       G_Printf( "cp: %s\n", ConcatArgs( 1 ) );
       return qtrue;
     }
@@ -730,6 +752,11 @@
     {
       G_PrivateMessage( NULL );
       return qtrue;
+    }    
+    else if( !Q_stricmp( cmd, "a" ) || !Q_stricmp( cmd, "say_admins" ))
+    {
+      G_Say( NULL, NULL, SAY_ADMINS, ConcatArgs( 1 )  );
+      return qtrue;
     }
 
     G_Printf( "unknown command: %s\n", cmd );
Index: src/game/g_local.h
===================================================================
--- src/game/g_local.h	(revision 966)
+++ src/game/g_local.h	(working copy)
@@ -215,6 +215,7 @@
   int               clientSpawnTime;    // the time until this spawn can spawn a client
   qboolean          lev1Grabbed;        // for turrets interacting with lev1s
   int               lev1GrabTime;       // for turrets interacting with lev1s
+  int               spawnBlockTime;
 
   int               credits[ MAX_CLIENTS ];     // human credits for each client
   qboolean          creditsHash[ MAX_CLIENTS ]; // track who has claimed credit
@@ -294,6 +295,7 @@
 typedef struct
 {
   team_t            sessionTeam;
+  pTeam_t         restartTeam; //for !restart keepteams and !restart switchteams
   int               spectatorTime;    // for determining next-in-line to play
   spectatorState_t  spectatorState;
   int               spectatorClient;  // for chasecam and follow mode
@@ -314,6 +316,54 @@
   int       ptrCode;
 } connectionRecord_t;
 
+typedef struct
+{
+  short kills;
+  short deaths;
+  short feeds;
+  short suicides;
+  short assists;
+  int dmgdone;
+  int ffdmgdone;
+  int structdmgdone;
+  short structsbuilt;
+  short repairspoisons;
+  short structskilled;
+  int timealive;
+  int timeinbase;
+  short headshots;
+  int hits;
+  int hitslocational;
+  short teamkills;
+  int dretchbasytime;
+  int jetpackusewallwalkusetime;
+  int timeLastViewed;
+} statsCounters_t;
+
+typedef struct
+{
+  int kills;
+  int deaths;
+  int feeds;
+  int suicides;
+  int assists;
+  long dmgdone;
+  long ffdmgdone;
+  long structdmgdone;
+  int structsbuilt;
+  int repairspoisons;
+  int structskilled;
+  long timealive;
+  long timeinbase;
+  int headshots;
+  long hits;
+  long hitslocational;
+  int teamkills;
+  long dretchbasytime;
+  long jetpackusewallwalkusetime;
+  long timeLastViewed;
+} statsCounters_level;
+
 // client data that stays across multiple respawns, but is cleared
 // on each level change or team change at ClientBegin()
 typedef struct
@@ -343,16 +393,23 @@
   int                 nameChangeTime;
   int                 nameChanges;
 
-  // used to save persistant[] values while in SPECTATOR_FOLLOW mode
-  int                 savedScore;
-  int                 savedCredit;
+  // used to save playerState_t values while in SPECTATOR_FOLLOW mode
+  int                 score;
+  int                 credit;
+  int                 ping;
 
+  int                 lastFloodTime;         // level.time of last flood-limited command
+  int                 floodDemerits;         // number of flood demerits accumulated
+
   vec3_t              lastDeathLocation;
   char                guid[ 33 ];
   char                ip[ 16 ];
   qboolean            muted;
   qboolean            denyBuild;
   int                 adminLevel;
+  qboolean            designatedBuilder;
+  qboolean            firstConnect;        // This is the first map since connect
+  statsCounters_t statscounters;	
 } clientPersistant_t;
 
 #define MAX_UNLAGGED_MARKERS 10
@@ -459,6 +516,8 @@
   unlagged_t          unlaggedBackup;
   unlagged_t          unlaggedCalc;
   int                 unlaggedTime;
+  
+  int               tkcredits[ MAX_CLIENTS ];
 
 };
 
@@ -477,7 +536,8 @@
 int       G_GetSpawnQueueLength( spawnQueue_t *sq );
 int       G_PopSpawnQueue( spawnQueue_t *sq );
 int       G_PeekSpawnQueue( spawnQueue_t *sq );
-void      G_PushSpawnQueue( spawnQueue_t *sq, int clientNum );
+qboolean  G_SearchSpawnQueue( spawnQueue_t *sq, int clientNum );
+qboolean  G_PushSpawnQueue( spawnQueue_t *sq, int clientNum );
 qboolean  G_RemoveFromSpawnQueue( spawnQueue_t *sq, int clientNum );
 int       G_GetPosInSpawnQueue( spawnQueue_t *sq, int clientNum );
 
@@ -518,6 +578,32 @@
   TW_PASSED
 } timeWarning_t;
 
+typedef enum
+{
+  BF_BUILT,
+  BF_DECONNED,
+  BF_DESTROYED,
+  BF_TEAMKILLED
+} buildableFate_t;
+
+// record all changes to the buildable layout - build, decon, destroy - and
+// enough information to revert that change
+typedef struct buildHistory_s buildHistory_t;
+struct buildHistory_s
+{
+  int ID; // persistent ID to aid in specific reverting
+  gentity_t *ent; // who, NULL if they've disconnected (or aren't an ent)
+  char name[ MAX_NETNAME ]; // who, saves name if ent is NULL
+  int buildable; // what
+  vec3_t origin; // where
+  vec3_t angles; // which way round
+  vec3_t origin2; // I don't know what the hell these are, but layoutsave saves
+  vec3_t angles2; // them so I will do the same
+  buildableFate_t fate; // was it built, destroyed or deconned
+  buildHistory_t *next; // next oldest change
+  buildHistory_t *marked; // linked list of markdecon buildings taken
+};
+
 //
 // this structure is cleared as each map is entered
 //
@@ -532,8 +618,6 @@
   int               gentitySize;
   int               num_entities;   // current number, <= MAX_GENTITIES
 
-  int               warmupTime;     // restart match at this time
-
   fileHandle_t      logFile;
 
   // store latched cvars here that we want to get at often
@@ -542,6 +626,7 @@
   int               framenum;
   int               time;                         // in msec
   int               previousTime;                 // so movers can back up when blocked
+  int               frameMsec;                    // trap_Milliseconds() at end frame
 
   int               startTime;                    // level.time the map was started
 
@@ -558,13 +643,14 @@
   int               numPlayingClients;            // connected, non-spectators
   int               sortedClients[MAX_CLIENTS];   // sorted by score
 
+  int               numNewbies;                   // number of UnnamedPlayers who have been renamed this round.
+
   int               snd_fry;                      // sound index for standing in lava
 
-  int               warmupModificationCount;      // for detecting if g_warmup is changed
-
   // voting state
   char              voteString[MAX_STRING_CHARS];
   char              voteDisplayString[MAX_STRING_CHARS];
+  int               votePercentToPass;
   int               voteTime;                     // level.time vote was called
   int               voteExecuteTime;              // time the vote is executed
   int               voteYes;
@@ -634,6 +720,9 @@
 
   pTeam_t           lastWin;
 
+  int               suddenDeathABuildPoints;
+  int               suddenDeathHBuildPoints;
+  qboolean          suddenDeath;
   timeWarning_t     suddenDeathWarning;
   timeWarning_t     timelimitWarning;
 
@@ -649,6 +738,8 @@
   qboolean          uncondHumanWin;
   qboolean          alienTeamLocked;
   qboolean          humanTeamLocked;
+  qboolean paused;
+  int pausedTime;
 
   int unlaggedIndex;
   int unlaggedTimes[ MAX_UNLAGGED_MARKERS ];
@@ -656,6 +747,13 @@
   char              layout[ MAX_QPATH ];
 
   pTeam_t           surrenderTeam;
+  buildHistory_t    *buildHistory;
+  int               lastBuildID;
+  int				lastTeamUnbalancedTime;
+  int				numTeamWarnings;  
+  
+  statsCounters_level alienStatsCounters;
+  statsCounters_level humanStatsCounters;
 } level_locals_t;
 
 #define CMD_CHEAT         0x01
@@ -689,11 +787,13 @@
 // g_cmds.c
 //
 void      Cmd_Score_f( gentity_t *ent );
+void      G_StopFromFollowing( gentity_t *ent );
 void      G_StopFollowing( gentity_t *ent );
 qboolean  G_FollowNewClient( gentity_t *ent, int dir );
 void      G_ToggleFollow( gentity_t *ent );
 qboolean  G_MatchOnePlayer( int *plist, char *err, int len );
 int       G_ClientNumbersFromString( char *s, int *plist );
+void G_Say( gentity_t *ent, gentity_t *target, int mode, const char *chatText );
 int       G_SayArgc( void );
 qboolean  G_SayArgv( int n, char *buffer, int bufferLength );
 char      *G_SayConcatArgs( int start );
@@ -702,6 +802,10 @@
 void      G_ChangeTeam( gentity_t *ent, pTeam_t newTeam );
 void      G_SanitiseName( char *in, char *out );
 void      G_PrivateMessage( gentity_t *ent );
+char      *G_statsString( statsCounters_t *sc, pTeam_t *pt );
+void      Cmd_Share_f( gentity_t *ent );
+void      Cmd_Donate_f( gentity_t *ent );
+void      Cmd_TeamVote_f( gentity_t *ent ); 
 
 //
 // g_physics.c
@@ -752,16 +856,24 @@
 void              G_BuildableThink( gentity_t *ent, int msec );
 qboolean          G_BuildableRange( vec3_t origin, float r, buildable_t buildable );
 itemBuildError_t  G_CanBuild( gentity_t *ent, buildable_t buildable, int distance, vec3_t origin );
+qboolean G_BuildingExists( int bclass ) ;
 qboolean          G_BuildIfValid( gentity_t *ent, buildable_t buildable );
 void              G_SetBuildableAnim( gentity_t *ent, buildableAnimNumber_t anim, qboolean force );
 void              G_SetIdleBuildableAnim( gentity_t *ent, buildableAnimNumber_t anim );
 void              G_SpawnBuildable(gentity_t *ent, buildable_t buildable);
 void              FinishSpawningBuildable( gentity_t *ent );
+void              G_CheckDBProtection( void );
 void              G_LayoutSave( char *name );
 int               G_LayoutList( const char *map, char *list, int len );
 void              G_LayoutSelect( void );
 void              G_LayoutLoad( void );
 void              G_BaseSelfDestruct( pTeam_t team );
+gentity_t         *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 );
+void              G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark );
+void              G_CommitRevertedBuildable( gentity_t *ent );
+qboolean          G_RevertCanFit( buildHistory_t *bh );
+int               G_LogBuild( buildHistory_t *new );
+int               G_CountBuildLog( void );
 
 //
 // g_utils.c
@@ -905,15 +1017,18 @@
 //
 void      G_AddCreditToClient( gclient_t *client, short credit, qboolean cap );
 team_t    TeamCount( int ignoreClientNum, int team );
-void      SetClientViewAngle( gentity_t *ent, vec3_t angle );
-gentity_t *SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles );
-gentity_t *SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles );
+void      G_SetClientViewAngle( gentity_t *ent, vec3_t angle );
+gentity_t *G_SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles );
+gentity_t *G_SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles );
+gentity_t *G_SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles );
+gentity_t *G_SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles );
 void      SpawnCorpse( gentity_t *ent );
 void      respawn( gentity_t *ent );
 void      BeginIntermission( void );
 void      ClientSpawn( gentity_t *ent, gentity_t *spawn, vec3_t origin, vec3_t angles );
 void      player_die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
 qboolean  SpotWouldTelefrag( gentity_t *spot );
+char     *G_NextNewbieName( gentity_t *ent );
 
 //
 // g_svcmds.c
@@ -943,6 +1058,9 @@
 void FindIntermissionPoint( void );
 void G_RunThink( gentity_t *ent );
 void QDECL G_LogPrintf( const char *fmt, ... );
+void QDECL G_LogOnlyPrintf( const char *fmt, ... );
+void QDECL G_AdminsPrintf( const char *fmt, ... );
+void QDECL G_LogOnlyPrintf( const char *fmt, ... );
 void SendScoreboardMessageToAllClients( void );
 void QDECL G_Printf( const char *fmt, ... );
 void QDECL G_Error( const char *fmt, ... );
@@ -950,6 +1068,7 @@
 void CheckTeamVote( int teamnum );
 void LogExit( const char *string );
 int  G_TimeTilSuddenDeath( void );
+qboolean G_Flood_Limited( gentity_t *ent );
 
 //
 // g_client.c
@@ -1100,15 +1219,22 @@
 extern  vmCvar_t  g_maxclients;     // allow this many total, including spectators
 extern  vmCvar_t  g_maxGameClients;   // allow this many active
 extern  vmCvar_t  g_restarted;
+extern  vmCvar_t  g_lockTeamsAtStart;
 extern  vmCvar_t  g_minCommandPeriod;
 extern  vmCvar_t  g_minNameChangePeriod;
 extern  vmCvar_t  g_maxNameChanges;
+extern  vmCvar_t  g_newbieNumbering;
+extern  vmCvar_t  g_newbieNamePrefix;
 
 extern  vmCvar_t  g_timelimit;
 extern  vmCvar_t  g_suddenDeathTime;
+extern  vmCvar_t  g_suddenDeath;
+extern  vmCvar_t  g_suddenDeathMode;
 extern  vmCvar_t  g_friendlyFire;
 extern  vmCvar_t  g_friendlyFireHumans;
 extern  vmCvar_t  g_friendlyFireAliens;
+extern  vmCvar_t  g_retribution;
+extern  vmCvar_t  g_friendlyFireMovementAttacks;
 extern  vmCvar_t  g_friendlyBuildableFire;
 extern  vmCvar_t  g_password;
 extern  vmCvar_t  g_needpass;
@@ -1130,14 +1256,19 @@
 extern  vmCvar_t  g_blood;
 extern  vmCvar_t  g_allowVote;
 extern  vmCvar_t  g_voteLimit;
+extern  vmCvar_t  g_suddenDeathVotePercent;
+extern  vmCvar_t  g_mapVotesPercent;
+extern  vmCvar_t  g_designateVotes;
 extern  vmCvar_t  g_teamAutoJoin;
 extern  vmCvar_t  g_teamForceBalance;
 extern  vmCvar_t  g_banIPs;
 extern  vmCvar_t  g_filterBan;
 extern  vmCvar_t  g_smoothClients;
+extern  vmCvar_t  g_clientUpgradeNotice;
 extern  vmCvar_t  pmove_fixed;
 extern  vmCvar_t  pmove_msec;
 extern  vmCvar_t  g_rankings;
+extern  vmCvar_t  g_allowShare;
 extern  vmCvar_t  g_enableDust;
 extern  vmCvar_t  g_enableBreath;
 extern  vmCvar_t  g_singlePlayer;
@@ -1154,6 +1285,7 @@
 extern  vmCvar_t  g_alienMaxStage;
 extern  vmCvar_t  g_alienStage2Threshold;
 extern  vmCvar_t  g_alienStage3Threshold;
+extern  vmCvar_t  g_teamImbalanceWarnings;
 
 extern  vmCvar_t  g_unlagged;
 
@@ -1162,12 +1294,15 @@
 extern  vmCvar_t  g_disabledBuildables;
 
 extern  vmCvar_t  g_markDeconstruct;
+extern  vmCvar_t  g_deconDead;
 
 extern  vmCvar_t  g_debugMapRotation;
 extern  vmCvar_t  g_currentMapRotation;
 extern  vmCvar_t  g_currentMap;
 extern  vmCvar_t  g_initialMapRotation;
 extern  vmCvar_t  g_chatTeamPrefix;
+extern  vmCvar_t  g_floodMaxDemerits;
+extern  vmCvar_t  g_floodMinTime;
 
 extern  vmCvar_t  g_shove;
 
@@ -1179,11 +1314,33 @@
 extern  vmCvar_t  g_admin;
 extern  vmCvar_t  g_adminLog;
 extern  vmCvar_t  g_adminParseSay;
+extern  vmCvar_t  g_adminSayFilter;
 extern  vmCvar_t  g_adminNameProtect;
 extern  vmCvar_t  g_adminTempBan;
+extern  vmCvar_t  g_minLevelToJoinTeam;
+extern  vmCvar_t  g_minLevelToSpecMM1;
 
+extern  vmCvar_t  g_devmapKillerHP;
+
 extern  vmCvar_t  g_privateMessages;
+extern  vmCvar_t  g_decolourLogfiles;
+extern  vmCvar_t  g_publicSayadmins;
+extern  vmCvar_t  g_myStats;
+extern  vmCvar_t  g_antiSpawnBlock;
 
+extern  vmCvar_t  g_dretchPunt;
+
+extern  vmCvar_t  g_allowActions;
+extern  vmCvar_t  g_actionPrefix;
+
+extern  vmCvar_t  g_devmapNoGod;
+extern  vmCvar_t  g_devmapNoStructDmg;
+
+extern  vmCvar_t  g_voteMinTime;
+extern  vmCvar_t  g_mapvoteMaxTime;
+
+extern  vmCvar_t  g_buildLogMaxLength;
+
 void      trap_Printf( const char *fmt );
 void      trap_Error( const char *fmt );
 int       trap_Milliseconds( void );
Index: src/game/g_ptr.c
===================================================================
--- src/game/g_ptr.c	(revision 966)
+++ src/game/g_ptr.c	(working copy)
@@ -63,7 +63,7 @@
   {
     client->pers.connection->clientTeam = client->pers.teamSelection;
     if( client->pers.teamSelection == PTE_NONE )
-      client->pers.connection->clientCredit = client->pers.savedCredit;
+      client->pers.connection->clientCredit = client->pers.credit;
     else
       client->pers.connection->clientCredit = client->ps.persistant[ PERS_CREDIT ];
   }
Index: src/game/g_combat.c
===================================================================
--- src/game/g_combat.c	(revision 966)
+++ src/game/g_combat.c	(working copy)
@@ -41,10 +41,6 @@
   if( !ent->client )
     return;
 
-  // no scoring during pre-match warmup
-  if( level.warmupTime )
-    return;
-
   ent->client->ps.persistant[ PERS_SCORE ] += score;
   CalculateRanks( );
 }
@@ -137,26 +133,32 @@
   int       i, j;
   char      *killerName, *obit;
   float     totalDamage = 0.0f;
+  float     percentDamage = 0.0f;
   gentity_t *player;
+  qboolean  tk = qfalse;
 
 
   if( self->client->ps.pm_type == PM_DEAD )
     return;
+  
+  if( attacker != self && attacker->client->ps.stats[ STAT_PTEAM ]  == self->client->ps.stats[ STAT_PTEAM ] ) 
+  {
+    attacker->client->pers.statscounters.teamkills++;
+    if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+    {
+      level.alienStatsCounters.teamkills++;
+    }
+    else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+    {
+     level.humanStatsCounters.teamkills++;
+    }
+  }
 
   if( level.intermissiontime )
     return;
 
   // stop any following clients
-  for( i = 0; i < level.maxclients; i++ )
-  {
-    if( level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR &&
-        level.clients[ i ].sess.spectatorState == SPECTATOR_FOLLOW &&
-        level.clients[ i ].sess.spectatorClient == self->client->ps.clientNum )
-    {
-      if( !G_FollowNewClient( &g_entities[ i ], 1 ) )
-        G_StopFollowing( &g_entities[ i ] );
-    }
-  }
+  // r1: removed, annoying.
 
   self->client->ps.pm_type = PM_DEAD;
   self->suicideTime = 0;
@@ -166,7 +168,11 @@
     killer = attacker->s.number;
 
     if( attacker->client )
+    {
       killerName = attacker->client->pers.netname;
+      tk = ( attacker != self && attacker->client->ps.stats[ STAT_PTEAM ] 
+        == self->client->ps.stats[ STAT_PTEAM ] );
+    }
     else
       killerName = "<non-client>";
   }
@@ -187,7 +193,7 @@
   else
     obit = modNames[ meansOfDeath ];
 
-  G_LogPrintf("Kill: %i %i %i: %s killed %s by %s\n",
+  G_LogPrintf("Kill: %i %i %i: %s^7 killed %s^7 by %s\n",
     killer, self->s.number, meansOfDeath, killerName,
     self->client->pers.netname, obit );
 
@@ -199,35 +205,126 @@
     BG_DeactivateUpgrade( i, self->client->ps.stats );
 
   // broadcast the death event to everyone
-  ent = G_TempEntity( self->r.currentOrigin, EV_OBITUARY );
-  ent->s.eventParm = meansOfDeath;
-  ent->s.otherEntityNum = self->s.number;
-  ent->s.otherEntityNum2 = killer;
-  ent->r.svFlags = SVF_BROADCAST; // send to everyone
+  if( !tk )
+  {
+    ent = G_TempEntity( self->r.currentOrigin, EV_OBITUARY );
+    ent->s.eventParm = meansOfDeath;
+    ent->s.otherEntityNum = self->s.number;
+    ent->s.otherEntityNum2 = killer;
+    ent->r.svFlags = SVF_BROADCAST; // send to everyone
+  }
+  else 
+  {
+    // tjw: obviously this is a hack and belongs in the client, but
+    //      this works as a temporary fix.
+    trap_SendServerCommand( -1,
+      va( "print \"%s^7 was killed by ^1TEAMMATE^7 %s^7 (Did %d damage to %d max)\n\"",
+      self->client->pers.netname, attacker->client->pers.netname, self->client->tkcredits[ attacker->s.number ], self->client->ps.stats[ STAT_MAX_HEALTH ] ) );
+    trap_SendServerCommand( attacker - g_entities,
+      va( "cp \"You killed ^1TEAMMATE^7 %s\"", self->client->pers.netname ) );
+    G_LogOnlyPrintf("%s^7 was killed by ^1TEAMMATE^7 %s^7 (Did %d damage to %d max)\n",
+      self->client->pers.netname, attacker->client->pers.netname, self->client->tkcredits[ attacker->s.number ], self->client->ps.stats[ STAT_MAX_HEALTH ] );
+  }
 
   self->enemy = attacker;
 
   self->client->ps.persistant[ PERS_KILLED ]++;
+  self->client->pers.statscounters.deaths++;
+  if( self->client->pers.teamSelection == PTE_ALIENS ) 
+  {
+   level.alienStatsCounters.deaths++;
+  }
+  else if( self->client->pers.teamSelection == PTE_HUMANS )
+  {
+    level.humanStatsCounters.deaths++;
+  }
 
   if( attacker && attacker->client )
   {
     attacker->client->lastkilled_client = self->s.number;
+	  
+   if( g_devmapKillerHP.integer && g_cheats.integer ) 
+   {
+     trap_SendServerCommand( self-g_entities, va( "print \"Your killer, %s, had %3i HP.\n\"", killerName, attacker->health ) );
+   }
 
     if( attacker == self || OnSameTeam( self, attacker ) )
     {
       AddScore( attacker, -1 );
 
-      //punish team kills and suicides
-      if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-        G_AddCreditToClient( attacker->client, -1, qtrue );
-      else if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-        G_AddCreditToClient( attacker->client, -ASPAWN_VALUE, qtrue );
+      // Retribution: transfer value of player from attacker to victim
+      if( g_retribution.integer) {
+	      if(attacker!=self){
+		int max = ALIEN_MAX_KILLS, tk_value = 0;
+		char *type = "evos";
+
+		if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) {
+		  tk_value = BG_ClassCanEvolveFromTo( PCL_ALIEN_LEVEL0,
+		    self->client->ps.stats[ STAT_PCLASS ], ALIEN_MAX_KILLS, 0 );
+		} else {
+		  tk_value = BG_GetValueOfEquipment( &self->client->ps );
+		  max = HUMAN_MAX_CREDITS;
+		  type = "credits";
+		}
+
+		if( attacker->client->ps.persistant[ PERS_CREDIT ] < tk_value )
+		  tk_value = attacker->client->ps.persistant[ PERS_CREDIT ];
+		if( self->client->ps.persistant[ PERS_CREDIT ]+tk_value > max )
+		  tk_value = max-self->client->ps.persistant[ PERS_CREDIT ];
+
+		if( tk_value > 0 ) {
+
+		  // adjust using the retribution cvar (in percent)
+		  tk_value = tk_value*g_retribution.integer/100;
+
+		  G_AddCreditToClient( self->client, tk_value, qtrue );
+		  G_AddCreditToClient( attacker->client, -tk_value, qtrue );
+
+		  trap_SendServerCommand( self->client->ps.clientNum,
+		    va( "print \"Received ^3%d %s ^7from %s ^7in retribution.\n\"",
+			tk_value, type, attacker->client->pers.netname ) );
+		  trap_SendServerCommand( attacker->client->ps.clientNum,
+		    va( "print \"Transfered ^3%d %s ^7to %s ^7in retribution.\n\"",
+			tk_value, type, self->client->pers.netname ) );
+		}
+	      }
+      }
+
+      // Normal teamkill penalty
+      else {
+        if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+          G_AddCreditToClient( attacker->client, -FREEKILL_ALIEN, qtrue );
+        else if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+          G_AddCreditToClient( attacker->client, -FREEKILL_HUMAN, qtrue );
+      }
     }
     else
     {
       AddScore( attacker, 1 );
 
       attacker->client->lastKillTime = level.time;
+      attacker->client->pers.statscounters.kills++;
+      if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+      {
+       level.alienStatsCounters.kills++;
+      }
+      else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+      {
+        level.humanStatsCounters.kills++;
+      }
+     }
+    
+    if( attacker == self )
+    {
+      attacker->client->pers.statscounters.suicides++;
+      if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+      {
+       level.alienStatsCounters.suicides++;
+      }
+      else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+      {
+        level.humanStatsCounters.suicides++;
+      }
     }
   }
   else if( attacker->s.eType != ET_BUILDABLE )
@@ -240,10 +337,24 @@
   // if players did more than DAMAGE_FRACTION_FOR_KILL increment the stage counters
   if( !OnSameTeam( self, attacker ) && totalDamage >= ( self->client->ps.stats[ STAT_MAX_HEALTH ] * DAMAGE_FRACTION_FOR_KILL ) )
   {
-    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) 
+    {
       trap_Cvar_Set( "g_alienKills", va( "%d", g_alienKills.integer + 1 ) );
+      if( g_alienStage.integer < 2 )
+      {
+	self->client->pers.statscounters.feeds++;
+	level.humanStatsCounters.feeds++;
+      }
+    }
     else if( self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    {
       trap_Cvar_Set( "g_humanKills", va( "%d", g_humanKills.integer + 1 ) );
+      if( g_humanStage.integer < 2 )
+      {
+	self->client->pers.statscounters.feeds++;
+	level.alienStatsCounters.feeds++;
+      }
+    }
   }
 
   if( totalDamage > 0.0f )
@@ -265,10 +376,18 @@
 
         if( !self->credits[ i ] )
           continue;
+	
+	percentDamage = (float)self->credits[ i ] / totalDamage;
+	if( percentDamage > 0 && percentDamage < 1)
+	{
+	  player->client->pers.statscounters.assists++;
+          level.humanStatsCounters.assists++;
 
+	}
+
         //add credit
         G_AddCreditToClient( player->client,
-            (int)( classValue * ( (float)self->credits[ i ] / totalDamage ) ), qtrue );
+            (int)( classValue * percentDamage ), qtrue );
       }
     }
     else if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
@@ -296,7 +415,14 @@
         if( !unclaimedFrags )
           break;
 
-        frags = (int)floor( humanValue * ( (float)self->credits[ i ] / totalDamage ) );
+	percentDamage = (float)self->credits[ i ] / totalDamage;
+	if( percentDamage > 0 && percentDamage < 1)
+	{
+	  player->client->pers.statscounters.assists++;
+	  level.alienStatsCounters.assists++;
+	}
+	
+        frags = (int)floor( humanValue * percentDamage);
 
         if( frags > 0 )
         {
@@ -756,6 +882,8 @@
   }
   else
   {
+    attacker->client->pers.statscounters.hitslocational++;
+    level.alienStatsCounters.hitslocational++;
     for( i = 0; i < g_numDamageRegions[ class ]; i++ )
     {
       qboolean rotationBound;
@@ -779,6 +907,12 @@
           ( g_damageRegions[ class ][ i ].crouch ==
             ( targ->client->ps.pm_flags & PMF_DUCKED ) ) )
         modifier *= g_damageRegions[ class ][ i ].modifier;
+    }    
+    
+    if(modifier == 2)
+    {
+     attacker->client->pers.statscounters.headshots++;
+     level.alienStatsCounters.headshots++;
     }
 
     for( i = UP_NONE + 1; i < UP_NUM_UPGRADES; i++ )
@@ -926,6 +1060,8 @@
   int     save;
   int     asave = 0;
   int     knockback;
+  float damagemodifier=0.0;
+  int takeNoOverkill;
 
   if( !targ->takedamage )
     return;
@@ -955,7 +1091,7 @@
 
   if( client )
   {
-    if( client->noclip )
+    if( client->noclip && !g_devmapNoGod.integer)
       return;
   }
 
@@ -1024,32 +1160,74 @@
     // if the attacker was on the same team
     if( targ != attacker && OnSameTeam( targ, attacker ) )
     {
-      if( !g_friendlyFire.integer )
+      if( g_dretchPunt.integer &&
+        targ->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_LEVEL0 )
       {
-        if( !g_friendlyFireHumans.integer 
-          && targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-        {
-          return;
-        }
-        if( !g_friendlyFireAliens.integer 
-          && targ->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-        {
-          return;
-        }
+        vec3_t dir, push;
+
+        VectorSubtract( targ->r.currentOrigin, attacker->r.currentOrigin, dir );
+        VectorNormalizeFast( dir );
+        VectorScale( dir, ( damage * 10.0f ), push );
+        push[2] = 64.0f;
+        VectorAdd( targ->client->ps.velocity, push, targ->client->ps.velocity );
+        return;
+      } 
+      else if(mod == MOD_LEVEL4_CHARGE || mod == MOD_LEVEL3_POUNCE )
+      { // don't do friendly fire on movement attacks
+	if( g_friendlyFireMovementAttacks.value <= 0 || ( g_friendlyFire.value<=0 && g_friendlyFireAliens.value<=0 ) )
+	  return;
+	else if( g_friendlyFireMovementAttacks.value > 0 && g_friendlyFireMovementAttacks.value < 1 )
+	  damage =(int)(0.5 + g_friendlyFireMovementAttacks.value * (float) damage);	
       }
-    }
+	  else if( g_friendlyFire.value <=0)
+	      {
+		if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+		{
+		  if(g_friendlyFireHumans.value<=0)
+		    return;
+		  else if( g_friendlyFireHumans.value > 0 && g_friendlyFireHumans.value < 1 )
+		    damage =(int)(0.5 + g_friendlyFireHumans.value * (float) damage);	    
+		}
+		if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+		{
+		  if(g_friendlyFireAliens.value==0)
+		    return;
+		  else if( g_friendlyFireAliens.value > 0 && g_friendlyFireAliens.value < 1 )
+		   damage =(int)(0.5 + g_friendlyFireAliens.value * (float) damage);
+		}
+	      }
+	      else if( g_friendlyFire.value > 0 && g_friendlyFire.value < 1 )
+	      {
+		damage =(int)(0.5 + g_friendlyFire.value * (float) damage);
+	      }
+	    }
 
-		// If target is buildable on the same team as the attacking client
-		if( targ->s.eType == ET_BUILDABLE && attacker->client &&
-				targ->biteam == attacker->client->pers.teamSelection )
+	// If target is buildable on the same team as the attacking client
+	if( targ->s.eType == ET_BUILDABLE && attacker->client &&
+			targ->biteam == attacker->client->pers.teamSelection )
+	{
+		if(mod == MOD_LEVEL4_CHARGE || mod == MOD_LEVEL3_POUNCE )
+			if(g_friendlyFireMovementAttacks.value <= 0)
+			  return;
+			else if(g_friendlyFireMovementAttacks.value > 0 && g_friendlyFireMovementAttacks.value < 1)
+			  damage =(int)(0.5 + g_friendlyFireMovementAttacks.value * (float) damage);	
+		
+		if( g_friendlyBuildableFire.value <= 0 )
 		{
-			if( !g_friendlyBuildableFire.integer )
-				return;
+		  return;
 		}
+		else if( g_friendlyBuildableFire.value > 0 && g_friendlyBuildableFire.value < 1 )
+		{
+		  damage =(int)(0.5 + g_friendlyBuildableFire.value * (float) damage);
+		}
+	}
 
     // check for godmode
-    if ( targ->flags & FL_GODMODE )
+    if ( targ->flags & FL_GODMODE && !g_devmapNoGod.integer)
       return;
+    
+    if(targ->s.eType == ET_BUILDABLE && g_cheats.integer && g_devmapNoStructDmg.integer)
+	    return;
   }
 
   // add to the attacker's hit counter
@@ -1094,20 +1272,23 @@
     // set the last client who damaged the target
     targ->client->lasthurt_client = attacker->s.number;
     targ->client->lasthurt_mod = mod;
-    take = (int)( (float)take * G_CalcDamageModifier( point, targ, attacker,
-                                                      client->ps.stats[ STAT_PCLASS ], dflags ) );
+    
+    damagemodifier = G_CalcDamageModifier( point, targ, attacker, client->ps.stats[ STAT_PCLASS ], dflags );
+    take = (int)( (float)take * damagemodifier );
 
     //if boosted poison every attack
     if( attacker->client && attacker->client->ps.stats[ STAT_STATE ] & SS_BOOSTED )
     {
-      if( !( targ->client->ps.stats[ STAT_STATE ] & SS_POISONED ) &&
-          !BG_InventoryContainsUpgrade( UP_BATTLESUIT, targ->client->ps.stats ) &&
+      if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
+          !( targ->client->ps.stats[ STAT_STATE ] & SS_POISONED ) &&
           mod != MOD_LEVEL2_ZAP &&
           targ->client->poisonImmunityTime < level.time )
       {
         targ->client->ps.stats[ STAT_STATE ] |= SS_POISONED;
         targ->client->lastPoisonTime = level.time;
         targ->client->lastPoisonClient = attacker;
+	attacker->client->pers.statscounters.repairspoisons++;
+	level.alienStatsCounters.repairspoisons++;
       }
     }
   }
@@ -1121,9 +1302,76 @@
       targ->health, take, asave );
   }
 
-  // do the damage
+  takeNoOverkill = take;
+  if( takeNoOverkill > targ->health ) 
+  {
+    if(targ->health > 0)
+	takeNoOverkill = targ->health;
+    else
+	takeNoOverkill = 0;
+  }
+
   if( take )
   {
+    //Increment some stats counters
+    if( attacker->client )
+    {
+      if( targ->biteam == attacker->client->pers.teamSelection || OnSameTeam( targ, attacker ) ) 
+      {
+	attacker->client->pers.statscounters.ffdmgdone += takeNoOverkill;
+	if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+	{
+	 level.alienStatsCounters.ffdmgdone+=takeNoOverkill;
+	}
+	else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+	{
+	  level.humanStatsCounters.ffdmgdone+=takeNoOverkill;
+	}
+      }
+      else if( targ->s.eType == ET_BUILDABLE )
+      {
+
+	attacker->client->pers.statscounters.structdmgdone += takeNoOverkill;
+	      
+	if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+	{
+	 level.alienStatsCounters.structdmgdone+=takeNoOverkill;
+	}
+	else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+	{
+	  level.humanStatsCounters.structdmgdone+=takeNoOverkill;
+	}
+	      
+	if( targ->health > 0 && ( targ->health - take ) <=0 )
+	{
+	 attacker->client->pers.statscounters.structskilled++;
+	 if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+	 {
+	  level.alienStatsCounters.structskilled++;
+	 }
+	 else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+	 {
+	   level.humanStatsCounters.structskilled++;
+	 }
+	}
+      }
+      else if( targ->client )
+      {
+	attacker->client->pers.statscounters.dmgdone +=takeNoOverkill;
+        attacker->client->pers.statscounters.hits++; 	      
+	if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+	{
+	 level.alienStatsCounters.dmgdone+=takeNoOverkill;
+	}
+	else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+	{
+	  level.humanStatsCounters.dmgdone+=takeNoOverkill;
+	}
+      }	
+    }
+
+    
+    //Do the damage
     targ->health = targ->health - take;
 
     if( targ->client )
@@ -1136,6 +1384,8 @@
     {
       if( attacker != targ && !OnSameTeam( targ, attacker ) )
         targ->credits[ attacker->client->ps.clientNum ] += take;
+      else if( attacker != targ && OnSameTeam( targ, attacker ) )
+        targ->client->tkcredits[ attacker->client->ps.clientNum ] += takeNoOverkill;
     }
 
     if( targ->health <= 0 )
Index: src/game/g_active.c
===================================================================
--- src/game/g_active.c	(revision 966)
+++ src/game/g_active.c	(working copy)
@@ -200,6 +200,11 @@
   if( !OnSameTeam( ent, victim ) )
     return;
 
+  if ( ( victim->client->ps.weapon >= WP_ABUILD ) &&
+       ( victim->client->ps.weapon <= WP_HBUILD ) &&
+       ( victim->client->ps.stats[ STAT_BUILDABLE ] != BA_NONE ) )
+  return;
+
   // alien mass is directly related to their health points
   // human mass is 200, double for bsuit  
   if( ent->client->pers.teamSelection == PTE_ALIENS )
@@ -375,20 +380,48 @@
 {
   pmove_t pm;
   gclient_t *client;
+  qboolean attack1, attack3;
+  qboolean	doPmove = qtrue;
 
   client = ent->client;
 
   client->oldbuttons = client->buttons;
   client->buttons = ucmd->buttons;
+	
+   attack1 = ( ( client->buttons & BUTTON_ATTACK ) &&
+               !( client->oldbuttons & BUTTON_ATTACK ) );
+   attack3 = ( ( client->buttons & BUTTON_USE_HOLDABLE ) &&
+               !( client->oldbuttons & BUTTON_USE_HOLDABLE ) );
 
-  if( client->sess.spectatorState != SPECTATOR_FOLLOW )
+  if( client->sess.spectatorState == SPECTATOR_LOCKED || client->sess.spectatorState == SPECTATOR_FOLLOW )
+    client->ps.pm_type = PM_FREEZE;
+  else
+    client->ps.pm_type = PM_SPECTATOR;
+
+  if ( client->sess.spectatorState == SPECTATOR_FOLLOW )
   {
-    if( client->sess.spectatorState == SPECTATOR_LOCKED )
-      client->ps.pm_type = PM_FREEZE;
-    else
-      client->ps.pm_type = PM_SPECTATOR;
+    gclient_t *cl;
+    if ( client->sess.spectatorClient >= 0 )
+    {
+      cl = &level.clients[ client->sess.spectatorClient ];
+      if ( cl->sess.sessionTeam != TEAM_SPECTATOR )
+        doPmove = qfalse;
+    }
+  }
 
+  if (doPmove)
+  {
     client->ps.speed = BG_FindSpeedForClass( client->ps.stats[ STAT_PCLASS ] );
+	  
+     // in case the client entered the queue while following a teammate
+     if( ( client->pers.teamSelection == PTE_ALIENS &&
+           G_SearchSpawnQueue( &level.alienSpawnQueue, ent-g_entities ) ) ||
+         ( client->pers.teamSelection == PTE_HUMANS &&
+           G_SearchSpawnQueue( &level.alienSpawnQueue, ent-g_entities ) ) )
+     {
+       client->ps.pm_flags |= PMF_QUEUED;
+     }
+ 
 
     client->ps.stats[ STAT_STAMINA ] = 0;
     client->ps.stats[ STAT_MISC ] = 0;
@@ -413,29 +446,26 @@
     G_TouchTriggers( ent );
     trap_UnlinkEntity( ent );
 
-    if( ( client->buttons & BUTTON_ATTACK ) && !( client->oldbuttons & BUTTON_ATTACK ) )
+    if( ( attack1 ) && ( client->ps.pm_flags & PMF_QUEUED ) )
     {
-      //if waiting in a queue remove from the queue
-      if( client->ps.pm_flags & PMF_QUEUED )
-      {
-        if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-          G_RemoveFromSpawnQueue( &level.alienSpawnQueue, client->ps.clientNum );
-        else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-          G_RemoveFromSpawnQueue( &level.humanSpawnQueue, client->ps.clientNum );
+      if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        G_RemoveFromSpawnQueue( &level.alienSpawnQueue, client->ps.clientNum );
+      else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        G_RemoveFromSpawnQueue( &level.humanSpawnQueue, client->ps.clientNum );
 
-        client->pers.classSelection = PCL_NONE;
-        client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
-      }
-      else if( client->pers.classSelection == PCL_NONE )
-      {
-        if( client->pers.teamSelection == PTE_NONE )
-          G_TriggerMenu( client->ps.clientNum, MN_TEAM );
-        else if( client->pers.teamSelection == PTE_ALIENS )
-          G_TriggerMenu( client->ps.clientNum, MN_A_CLASS );
-        else if( client->pers.teamSelection == PTE_HUMANS )
-          G_TriggerMenu( client->ps.clientNum, MN_H_SPAWN );
-      }
+      client->pers.classSelection = PCL_NONE;
+      client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
     }
+    
+    if( attack1 && client->pers.classSelection == PCL_NONE )
+    {
+      if( client->pers.teamSelection == PTE_NONE )
+        G_TriggerMenu( client->ps.clientNum, MN_TEAM );
+      else if( client->pers.teamSelection == PTE_ALIENS )
+        G_TriggerMenu( client->ps.clientNum, MN_A_CLASS );
+      else if( client->pers.teamSelection == PTE_HUMANS )
+        G_TriggerMenu( client->ps.clientNum, MN_H_SPAWN );
+    }
 
     //set the queue position for the client side
     if( client->ps.pm_flags & PMF_QUEUED )
@@ -453,8 +483,22 @@
     }
   }
 
-  if( ( client->buttons & BUTTON_USE_HOLDABLE ) && !( client->oldbuttons & BUTTON_USE_HOLDABLE ) )
-    G_ToggleFollow( ent );
+  else if( attack1 && ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+  {
+    G_StopFollowing( ent );
+    client->pers.classSelection = PCL_NONE;
+    if( client->pers.teamSelection == PTE_NONE )
+      G_TriggerMenu( ent-g_entities, MN_TEAM );
+    else if( client->pers.teamSelection == PTE_ALIENS )
+      G_TriggerMenu( ent-g_entities, MN_A_CLASS );
+    else if( client->pers.teamSelection == PTE_HUMANS )
+      G_TriggerMenu( ent-g_entities, MN_H_SPAWN );
+  }
+   
+  if( attack3 )
+  {
+   G_ToggleFollow( ent );
+  }
 }
 
 
@@ -681,6 +725,7 @@
             client->ps.stats[ STAT_BUILDABLE ] &= ~SB_VALID_TOGGLEBIT;
         }
 
+      case WP_BLASTER:
         //update build timer
         if( client->ps.stats[ STAT_MISC ] > 0 )
           client->ps.stats[ STAT_MISC ] -= 100;
@@ -743,22 +788,17 @@
     //client is poisoned
     if( client->ps.stats[ STAT_STATE ] & SS_POISONED )
     {
-      int i;
-      int seconds = ( ( level.time - client->lastPoisonTime ) / 1000 ) + 1;
-      int damage = ALIEN_POISON_DMG, damage2 = 0;
+      int damage = ALIEN_POISON_DMG; 
+   
+      if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, client->ps.stats ) )
+        damage -= BSUIT_POISON_PROTECTION;
+      if( BG_InventoryContainsUpgrade( UP_HELMET, client->ps.stats ) )
+        damage -= HELMET_POISON_PROTECTION;
+      if( BG_InventoryContainsUpgrade( UP_LIGHTARMOUR, client->ps.stats ) )
+        damage -= LIGHTARMOUR_POISON_PROTECTION;
 
-      for( i = 0; i < seconds; i++ )
-      {
-        if( i == seconds - 1 )
-          damage2 = damage;
-
-        damage *= ALIEN_POISON_DIVIDER;
-      }
-
-      damage = damage2 - damage;
-
-      G_Damage( ent, client->lastPoisonClient, client->lastPoisonClient, NULL, NULL,
-                damage, 0, MOD_POISON );
+      G_Damage( ent, client->lastPoisonClient, client->lastPoisonClient, NULL,
+        0, damage, 0, MOD_POISON );
     }
 
     //replenish alien health
@@ -802,6 +842,46 @@
       if( ent->health > client->ps.stats[ STAT_MAX_HEALTH ] )
         ent->health = client->ps.stats[ STAT_MAX_HEALTH ];
     }
+    
+    
+    if( ent->client->ps.stats[ STAT_HEALTH ] > 0 && ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    {
+      ent->client->pers.statscounters.timealive++;
+      level.alienStatsCounters.timealive++;
+      if( G_BuildableRange( ent->client->ps.origin, 900, BA_A_OVERMIND ) )
+      {
+	ent->client->pers.statscounters.timeinbase++;
+	level.alienStatsCounters.timeinbase++;
+      }
+      if( BG_ClassHasAbility( ent->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER )  )
+      {
+	ent->client->pers.statscounters.dretchbasytime++;
+	level.alienStatsCounters.dretchbasytime++;
+	if( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING  || ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING) 
+	{
+	  ent->client->pers.statscounters.jetpackusewallwalkusetime++;
+	  level.alienStatsCounters.jetpackusewallwalkusetime++;
+	}
+      }
+    }
+    else if( ent->client->ps.stats[ STAT_HEALTH ] > 0 && ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    {
+      ent->client->pers.statscounters.timealive++;
+      level.humanStatsCounters.timealive++;
+      if( G_BuildableRange( ent->client->ps.origin, 900, BA_H_REACTOR ) )
+      {
+	ent->client->pers.statscounters.timeinbase++;
+	level.humanStatsCounters.timeinbase++;
+      }
+      if( BG_InventoryContainsUpgrade( UP_JETPACK, client->ps.stats ) )
+      {
+	if( client->ps.pm_type == PM_JETPACK ) 
+	{
+	  ent->client->pers.statscounters.jetpackusewallwalkusetime++;
+	  level.humanStatsCounters.jetpackusewallwalkusetime++;
+	}
+      }
+    }
    
     // turn off life support when a team admits defeat 
     if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
@@ -1297,6 +1377,19 @@
 //    G_Printf("serverTime >>>>>\n" );
   }
 
+  // ucmd->serverTime is a client predicted value, but it works for making a
+  // replacement for client->ps.ping when in SPECTATOR_FOLLOW 
+  client->pers.ping = level.time - ucmd->serverTime;
+
+  // account for the one frame of delay on client side
+  client->pers.ping -= level.time - level.previousTime;
+
+  // account for the time that's elapsed since the last ClientEndFrame()
+  client->pers.ping += trap_Milliseconds( ) - level.frameMsec;
+
+  if( client->pers.ping < 0 )
+    client->pers.ping = 0;
+
   msec = ucmd->serverTime - client->ps.commandTime;
   // following others may result in bad times, but we still want
   // to check for follow toggles
@@ -1691,15 +1784,12 @@
   // Give clients some credit periodically
   if( ent->client->lastKillTime + FREEKILL_PERIOD < level.time )
   {
-    if( G_TimeTilSuddenDeath( ) <= 0 )
-    {
-      //gotta love logic like this eh?
+    if( !g_suddenDeath.integer ) {
+      if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        G_AddCreditToClient( ent->client, FREEKILL_ALIEN, qtrue );
+      if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        G_AddCreditToClient( ent->client, FREEKILL_HUMAN, qtrue );
     }
-    else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-      G_AddCreditToClient( ent->client, FREEKILL_ALIEN, qtrue );
-    else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-      G_AddCreditToClient( ent->client, FREEKILL_HUMAN, qtrue );
-
     ent->client->lastKillTime = level.time;
   }
 
@@ -1769,13 +1859,29 @@
     {
       cl = &level.clients[ clientNum ];
 
-      if( cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR )
+      if( cl->pers.connected == CON_CONNECTED )
       {
-        flags = ( cl->ps.eFlags & ~( EF_VOTED | EF_TEAMVOTED ) ) |
-          ( ent->client->ps.eFlags & ( EF_VOTED | EF_TEAMVOTED ) );
-        ent->client->ps = cl->ps;
-        ent->client->ps.pm_flags |= PMF_FOLLOW;
-        ent->client->ps.eFlags = flags;
+ 	      
+ 	if( cl -> sess.spectatorState != SPECTATOR_FOLLOW ) 
+	{
+          flags = ( cl->ps.eFlags & ~( EF_VOTED | EF_TEAMVOTED ) ) |
+            ( ent->client->ps.eFlags & ( EF_VOTED | EF_TEAMVOTED ) );
+          ent->client->ps = cl->ps;
+          ent->client->ps.eFlags = flags;
+          ent->client->ps.pm_flags |= PMF_FOLLOW;
+ 	  ent->client->ps.pm_flags &= ~PMF_QUEUED;
+ 	}
+ 	else //we are stickyspec-spectating someone who is spectating someone else
+ 	{
+ 	  ent->client->ps.clientNum = (g_entities + clientNum)->s.number;
+ 	  ent->client->ps.commandTime = cl->ps.commandTime;
+ 	  ent->client->ps.weapon = 0;
+ 	  ent->client->ps.pm_flags |= PMF_FOLLOW;
+ 	  ent->client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
+ 	  VectorCopy( level.intermission_origin, ent->s.origin );
+          VectorCopy( level.intermission_origin, ent->client->ps.origin );
+          VectorCopy( level.intermission_angle, ent->client->ps.viewangles );
+ 	}
       }
     }
   }
@@ -1802,6 +1908,10 @@
 
   pers = &ent->client->pers;
 
+  // save a copy of certain playerState values in case of SPECTATOR_FOLLOW 
+  pers->score = ent->client->ps.persistant[ PERS_SCORE ];
+  pers->credit = ent->client->ps.persistant[ PERS_CREDIT ];
+
   //
   // If the end of unit layout is displayed, don't give
   // the player any normal movement attributes
Index: src/game/g_session.c
===================================================================
--- src/game/g_session.c	(revision 966)
+++ src/game/g_session.c	(working copy)
@@ -46,8 +46,9 @@
   const char  *s;
   const char  *var;
 
-  s = va( "%i %i %i %i %i %i %i %s",
+  s = va( "%i %i %i %i %i %i %i %i %s",
     client->sess.sessionTeam,
+    client->sess.restartTeam,
     client->sess.spectatorTime,
     client->sess.spectatorState,
     client->sess.spectatorClient,
@@ -78,14 +79,16 @@
   int teamLeader;
   int spectatorState;
   int sessionTeam;
+  int restartTeam;
 
   var = va( "session%i", client - level.clients );
   trap_Cvar_VariableStringBuffer( var, s, sizeof(s) );
 
   // FIXME: should be using BG_ClientListParse() for ignoreList, but
   //        bg_lib.c's sscanf() currently lacks %s
-  sscanf( s, "%i %i %i %i %i %i %i %x%x",
+  sscanf( s, "%i %i %i %i %i %i %i %i %x%x",
     &sessionTeam,
+    &restartTeam,
     &client->sess.spectatorTime,
     &spectatorState,
     &client->sess.spectatorClient,
@@ -97,6 +100,7 @@
     );
   // bk001205 - format issues
   client->sess.sessionTeam = (team_t)sessionTeam;
+  client->sess.restartTeam = (pTeam_t)restartTeam;
   client->sess.spectatorState = (spectatorState_t)spectatorState;
   client->sess.teamLeader = (qboolean)teamLeader;
 }
@@ -132,6 +136,7 @@
       sess->sessionTeam = TEAM_FREE;
   }
 
+  sess->restartTeam = PTE_NONE;
   sess->spectatorState = SPECTATOR_FREE;
   sess->spectatorTime = level.time;
   sess->spectatorClient = -1;
Index: src/game/g_buildable.c
===================================================================
--- src/game/g_buildable.c	(revision 966)
+++ src/game/g_buildable.c	(working copy)
@@ -472,6 +472,9 @@
   {
     enemy = &g_entities[ entityList[ i ] ];
 
+    if( enemy->flags & FL_NOTARGET )
+      continue;
+
     if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
         enemy->client->ps.groundEntityNum != ENTITYNUM_NONE &&
         G_Visible( self, enemy ) )
@@ -617,7 +620,24 @@
 ================
 */
 void ASpawn_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
-{
+{	
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+  
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
@@ -646,8 +666,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -680,10 +703,39 @@
           G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
           return;
         }
+	else if( g_antiSpawnBlock.integer && ent->client && 
+		 ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+	{
+	  //spawnblock protection
+	  if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+	  {
+	    //five seconds of countermeasures and we're still blocked
+	    //time for something more drastic
+	    G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+	    self->spawnBlockTime += 2000;
+	    //inappropriate MOD but prints an apt obituary
+	  }
+	  else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+	    //five seconds of blocked by client and...
+	  {
+	    //random direction
+	    vec3_t velocity;
+	    velocity[0] = crandom() * g_antiSpawnBlock.integer;
+	    velocity[1] = crandom() * g_antiSpawnBlock.integer;
+	    velocity[2] = g_antiSpawnBlock.integer;
+            
+	    VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+	    trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+	  }
+	  else if( !self->spawnBlockTime )
+	    self->spawnBlockTime = level.time;
+        }
 
         if( ent->s.eType == ET_CORPSE )
           G_FreeEntity( ent ); //quietly remove
       }
+      else
+	self->spawnBlockTime = 0;
     }
   }
 
@@ -744,6 +796,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET ) 
+	continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
       {
         self->timestamp = level.time;
@@ -870,6 +925,23 @@
 */
 void ABarricade_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+    
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
@@ -890,8 +962,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -1003,6 +1078,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+	continue;
+
       if( !G_Visible( self, enemy ) )
         continue;
 
@@ -1071,6 +1149,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+	continue;
+
       if( enemy->health <= 0 )
         continue;
 
@@ -1154,7 +1235,7 @@
     G_SetOrigin( player, origin );
     VectorCopy( origin, player->client->ps.origin );
     VectorCopy( vec3_origin, player->client->ps.velocity );
-    SetClientViewAngle( player, angles );
+    G_SetClientViewAngle( player, angles );
   }
 
   if( tr.fraction < 1.0f )
@@ -1234,7 +1315,7 @@
 
       G_SetOrigin( activator, hovelOrigin );
       VectorCopy( hovelOrigin, activator->client->ps.origin );
-      SetClientViewAngle( activator, hovelAngles );
+      G_SetClientViewAngle( activator, hovelAngles );
     }
   }
 }
@@ -1272,8 +1353,25 @@
 */
 void AHovel_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
-  vec3_t  dir;
+  vec3_t  dir;	
 
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+	
   VectorCopy( self->s.origin2, dir );
 
   //do a bit of radius damage
@@ -1309,7 +1407,7 @@
 
     G_SetOrigin( builder, newOrigin );
     VectorCopy( newOrigin, builder->client->ps.origin );
-    SetClientViewAngle( builder, newAngles );
+    G_SetClientViewAngle( builder, newAngles );
 
     //client leaves hovel
     builder->client->ps.stats[ STAT_STATE ] &= ~SS_HOVELING;
@@ -1326,8 +1424,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -1355,6 +1456,9 @@
 {
   gclient_t *client = other->client;
 
+  if( other->flags & FL_NOTARGET )
+    return; // notarget cancels even beneficial effects?
+
   if( !self->spawned )
     return;
 
@@ -1458,6 +1562,8 @@
     return qfalse;
   if( !target->client ) // is the target a bot or player?
     return qfalse;
+  if( target->flags & FL_NOTARGET ) // is the target cheating?
+    return qfalse;
   if( target->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) // one of us?
     return qfalse;
   if( target->client->sess.sessionTeam == TEAM_SPECTATOR ) // is the target alive?
@@ -1647,6 +1753,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+	continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
       {
         self->timestamp = level.time;
@@ -1815,6 +1924,9 @@
       {
         player = &g_entities[ entityList[ i ] ];
 
+	if( player->flags & FL_NOTARGET )
+	  continue; // notarget cancels even beneficial effects?
+
         if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
         {
           if( player->health < player->client->ps.stats[ STAT_MAX_HEALTH ] &&
@@ -1966,6 +2078,9 @@
   if( !target )
     return qfalse;
 
+  if( target->flags & FL_NOTARGET )
+    return qfalse;
+
   if( !target->client )
     return qfalse;
 
@@ -2165,6 +2280,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+	continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
           enemy->health > 0 &&
           Distance( enemy->s.pos.trBase, self->s.pos.trBase ) <= TESLAGEN_RANGE )
@@ -2266,13 +2384,31 @@
 */
 void HSpawn_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+    
   //pretty events and cleanup
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
   self->die = nullDieFunction;
   self->powered = qfalse; //free up power
-  self->s.eFlags &= ~EF_FIRING; //prevent any firing effects
+  //prevent any firing effects and cancel structure protection
+  self->s.eFlags &= ~( EF_FIRING | EF_DBUILDER );
 
   if( self->spawned )
   {
@@ -2300,8 +2436,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -2337,10 +2476,39 @@
           G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
           return;
         }
+	else if( g_antiSpawnBlock.integer && ent->client && 
+		 ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+	{
+	  //spawnblock protection
+	  if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+	  {
+	    //five seconds of countermeasures and we're still blocked
+	    //time for something more drastic
+	    G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+	    self->spawnBlockTime += 2000;
+	    //inappropriate MOD but prints an apt obituary
+	  }
+	  else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+	    //five seconds of blocked by client and...
+	  {
+	    //random direction
+	    vec3_t velocity;
+	    velocity[0] = crandom() * g_antiSpawnBlock.integer;
+	    velocity[1] = crandom() * g_antiSpawnBlock.integer;
+	    velocity[2] = g_antiSpawnBlock.integer;
+            
+	    VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+	    trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+	  }
+	  else if( !self->spawnBlockTime )
+	    self->spawnBlockTime = level.time;
+        }
 
         if( ent->s.eType == ET_CORPSE )
           G_FreeEntity( ent ); //quietly remove
       }
+      else
+        self->spawnBlockTime = 0;
     }
 
     //spawn under attack
@@ -2438,7 +2606,7 @@
   //pack health, power and dcc
 
   //toggle spawned flag for buildables
-  if( !ent->spawned && ent->health > 0 )
+  if( !ent->spawned && ent->health > 0 && !level.pausedTime )
   {
     if( ent->buildTime + bTime < level.time )
       ent->spawned = qtrue;
@@ -2597,6 +2765,8 @@
 {
   int       i;
   gentity_t *ent;
+  buildHistory_t *new, *last;
+  last = level.buildHistory;
 
   if( !g_markDeconstruct.integer )
     return; // Not enabled, can't deconstruct anything
@@ -2605,6 +2775,21 @@
   {
     ent = level.markedBuildables[ i ];
 
+    new = G_Alloc( sizeof( buildHistory_t ) );
+    new->ID = -1;
+    new->ent = NULL;
+    Q_strncpyz( new->name, "<markdecon>", 12 );
+    new->buildable = ent->s.modelindex;
+    VectorCopy( ent->s.pos.trBase, new->origin );
+    VectorCopy( ent->s.angles, new->angles );
+    VectorCopy( ent->s.origin2, new->origin2 );
+    VectorCopy( ent->s.angles2, new->angles2 );
+    new->fate = BF_DECONNED;
+    new->next = NULL;
+    new->marked = NULL;
+
+    last = last->marked = new;
+
     G_FreeEntity( ent );
   }
 }
@@ -2920,7 +3105,7 @@
         }
         else if( tempent->s.modelindex == buildable )
         {
-          level.markedBuildables[ level.numBuildablesForRemoval++ ] = tempent;
+          level.markedBuildables[ level.numBuildablesForRemoval++ ] = tempent;	
         }
       }
     }
@@ -3013,7 +3198,29 @@
   return reason;
 }
 
+/*
+==============
+G_BuildingExists
+==============
+*/
+qboolean G_BuildingExists( int bclass ) 
+{
+  int               i;
+  gentity_t         *tempent;
+  //look for an Armoury
+  for (i = 1, tempent = g_entities + i; i < level.num_entities; i++, tempent++ )
+  {
+    if( tempent->s.eType != ET_BUILDABLE )
+     continue;
+    if( tempent->s.modelindex == bclass && tempent->health > 0 )
+    {
+      return qtrue;
+    }
+  }
+  return qfalse;
+}
 
+
 /*
 ================
 G_Build
@@ -3024,7 +3231,15 @@
 static gentity_t *G_Build( gentity_t *builder, buildable_t buildable, vec3_t origin, vec3_t angles )
 {
   gentity_t *built;
+  buildHistory_t *new;
   vec3_t    normal;
+    
+  // initialise the buildhistory so other functions can use it
+  if( builder && builder->client )
+  {
+    new = G_Alloc( sizeof( buildHistory_t ) );
+    G_LogBuild( new );
+  }
 
   // Free existing buildables
   G_FreeMarkedBuildables( );
@@ -3088,6 +3303,7 @@
   built->takedamage = qtrue;
   built->spawned = qfalse;
   built->buildTime = built->s.time = level.time;
+  built->spawnBlockTime = 0;
 
   // build instantly in cheat mode
   if( builder->client && g_cheats.integer )
@@ -3207,7 +3423,14 @@
   built->s.weapon = BG_FindProjTypeForBuildable( buildable );
 
   if( builder->client )
+  {
     built->builtBy = builder->client->ps.clientNum;
+
+    if( builder->client->pers.designatedBuilder )
+    {
+      built->s.eFlags |= EF_DBUILDER; // designated builder protection
+    }
+  }
   else
     built->builtBy = -1;
 
@@ -3256,7 +3479,48 @@
     G_SetBuildableAnim( built, BANIM_CONSTRUCT1, qtrue );
 
   trap_LinkEntity( built );
+  
+  
+  if( builder->client ) 
+  {
+     builder->client->pers.statscounters.structsbuilt++;
+     if( builder->client->pers.teamSelection == PTE_ALIENS ) 
+     {
+       level.alienStatsCounters.structsbuilt++;
+     }
+     else if( builder->client->pers.teamSelection == PTE_HUMANS )
+     {
+       level.humanStatsCounters.structsbuilt++;
+     }
+  }
 
+  if( builder->client ) {
+    G_TeamCommand( builder->client->pers.teamSelection,
+      va( "print \"%s is ^2being built^7 by %s^7\n\"",
+        BG_FindHumanNameForBuildable( built->s.modelindex ), 
+        builder->client->pers.netname ) );
+    G_LogPrintf("Build: %i %i 0: %s^7 is ^2building^7 %s\n",
+      builder->client->ps.clientNum,
+      built->s.modelindex,
+      builder->client->pers.netname, 
+      BG_FindNameForBuildable( built->s.modelindex ) );
+  }
+
+  // ok we're all done building, so what we log here should be the final values
+  if( builder && builder->client ) // log ingame building only
+  {
+    new = level.buildHistory;
+    new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+    new->ent = builder;
+    new->name[ 0 ] = 0;
+    new->buildable = buildable;
+    VectorCopy( built->s.pos.trBase, new->origin );
+    VectorCopy( built->s.angles, new->angles );
+    VectorCopy( built->s.origin2, new->origin2 );
+    VectorCopy( built->s.angles2, new->angles2 );
+    new->fate = BF_BUILT;
+  }
+
   return built;
 }
 
@@ -3433,6 +3697,58 @@
   ent->think = G_FinishSpawningBuildable;
 }
 
+ /*
+ ============
+ G_CheckDBProtection
+ 
+ Count how many designated builders are in both teams and
+ if none found in some team, cancel protection for all
+ structures of that team
+ ============
+ */
+ 
+ void G_CheckDBProtection( void )
+ {
+   int alienDBs = 0, humanDBs = 0, i;
+   gentity_t *ent;
+ 
+   // count designated builders
+   for( i = 0, ent = g_entities + i; i < level.maxclients; i++, ent++)
+   {
+     if( !ent->client || ( ent->client->pers.connected != CON_CONNECTED ) )
+       continue;
+ 
+     if( ent->client->pers.designatedBuilder)
+     {
+       if( ent->client->pers.teamSelection == PTE_HUMANS )
+       {
+         humanDBs++;
+       }
+       else if( ent->client->pers.teamSelection == PTE_ALIENS )
+       {
+         alienDBs++;
+       }
+     }
+   }
+ 
+   // both teams have designate builders, we're done
+   if( alienDBs > 0 && humanDBs > 0 )
+     return;
+ 
+   // cancel protection if needed
+   for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++)
+   {
+     if( ent->s.eType != ET_BUILDABLE)
+       continue;
+ 
+     if( ( !alienDBs && ent->biteam == BIT_ALIENS ) ||
+       ( !humanDBs && ent->biteam == BIT_HUMANS ) )
+     {
+       ent->s.eFlags &= ~EF_DBUILDER;
+     }
+   }
+ }
+ 
 /*
 ============
 G_LayoutSave
@@ -3631,6 +3947,232 @@
 
 /*
 ============
+G_InstantBuild
+
+This function is extremely similar to the few functions that place a 
+buildable on map load. It exists because G_LayoutBuildItem takes a couple
+of frames to finish spawning it, so it's not truly instant
+Do not call this function immediately after the map loads - that's what
+G_LayoutBuildItem is for.
+============
+*/
+gentity_t *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 )
+{
+  gentity_t *builder, *built;
+  trace_t   tr;
+  vec3_t    dest;
+  
+  builder = G_Spawn( );
+  builder->client = 0;
+  VectorCopy( origin, builder->s.pos.trBase );
+  VectorCopy( angles, builder->s.angles );
+  VectorCopy( origin2, builder->s.origin2 );
+  VectorCopy( angles2, builder->s.angles2 );
+//old method didn't quite work out
+//builder->s.modelindex = buildable;
+//G_FinishSpawningBuildable( builder );
+
+  built = G_Build( builder, buildable, builder->s.pos.trBase, builder->s.angles );
+  G_FreeEntity( builder );
+
+  built->takedamage = qtrue;
+  built->spawned = qtrue; //map entities are already spawned
+  built->health = BG_FindHealthForBuildable( buildable );
+  built->s.generic1 |= B_SPAWNED_TOGGLEBIT;
+
+  // drop towards normal surface
+  VectorScale( built->s.origin2, -4096.0f, dest );
+  VectorAdd( dest, built->s.origin, dest );
+
+  trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask );
+  if( tr.startsolid )
+  {
+    G_Printf( S_COLOR_YELLOW "G_FinishSpawningBuildable: %s startsolid at %s\n",
+         built->classname, vtos( built->s.origin ) );
+    G_FreeEntity( built );
+    return NULL;
+  }
+
+  //point items in the correct direction
+  VectorCopy( tr.plane.normal, built->s.origin2 );
+
+  // allow to ride movers
+  built->s.groundEntityNum = tr.entityNum;
+
+  G_SetOrigin( built, tr.endpos );
+
+  trap_LinkEntity( built );
+  return built;
+}
+
+/*
+============
+G_SpawnRevertedBuildable
+
+Given a buildhistory, try to replace the lost buildable
+============
+*/
+void G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark )
+{
+  vec3_t mins, maxs;
+  int i, j, blockCount, blockers[ MAX_GENTITIES ];
+  gentity_t *targ, *built, *toRecontent[ MAX_GENTITIES ];
+
+  BG_FindBBoxForBuildable( bh->buildable, mins, maxs );
+  VectorAdd( bh->origin, mins, mins );
+  VectorAdd( bh->origin, maxs, maxs );
+  blockCount = trap_EntitiesInBox( mins, maxs, blockers, MAX_GENTITIES );
+  for( i = j = 0; i < blockCount; i++ )
+  {
+    targ = g_entities + blockers[ i ];
+    if( targ->s.eType == ET_BUILDABLE )
+      G_FreeEntity( targ );
+    else if( targ->s.eType == ET_PLAYER )
+    {
+      targ->r.contents = 0; // make it intangible
+      toRecontent[ j++ ] = targ; // and remember it
+    }
+  }
+  level.numBuildablesForRemoval = 0;
+  built = G_InstantBuild( bh->buildable, bh->origin, bh->angles, bh->origin2, bh->angles2 );
+  if( built )
+  {
+    built->r.contents = 0;
+    built->think = G_CommitRevertedBuildable;
+    built->nextthink = level.time;
+    built->deconstruct = mark;
+  }
+  for( i = 0; i < j; i++ )
+    toRecontent[ i ]->r.contents = CONTENTS_BODY;
+}
+
+/*
+============
+G_CommitRevertedBuildable
+
+Check if there's anyone occupying me, and if not, become solid and operate as 
+normal. Else, try to get rid of them.
+============
+*/
+void G_CommitRevertedBuildable( gentity_t *ent )
+{
+  gentity_t *targ;
+  int i, n, occupants[ MAX_GENTITIES ];
+  vec3_t mins, maxs;
+  VectorAdd( ent->s.origin, ent->r.mins, mins );
+  VectorAdd( ent->s.origin, ent->r.maxs, maxs );
+  trap_UnlinkEntity( ent );
+  n = trap_EntitiesInBox( mins, maxs, occupants, MAX_GENTITIES );
+  trap_LinkEntity( ent );
+  if( n == 0 )
+  { // we're in the clear!
+    ent->r.contents = MASK_PLAYERSOLID;
+    trap_LinkEntity( ent ); // relink
+    // oh dear, manual think set
+    switch( ent->s.modelindex )
+    {
+      case BA_A_SPAWN:
+         ent->think = ASpawn_Think;
+         break;
+      case BA_A_BARRICADE: 
+      case BA_A_BOOSTER:
+        ent->think = ABarricade_Think;
+        break;
+      case BA_A_ACIDTUBE:
+        ent->think = AAcidTube_Think;
+        break;
+      case BA_A_HIVE:
+        ent->think = AHive_Think;
+        break;
+      case BA_A_TRAPPER:
+        ent->think = ATrapper_Think;
+        break;
+      case BA_A_OVERMIND:
+        ent->think = AOvermind_Think;
+        break;
+      case BA_A_HOVEL:
+        ent->think = AHovel_Think;
+        break;
+      case BA_H_SPAWN:
+        ent->think = HSpawn_Think;
+        break;
+      case BA_H_MGTURRET:
+        ent->think = HMGTurret_Think;
+        break;
+      case BA_H_TESLAGEN:
+        ent->think = HTeslaGen_Think;
+        break;
+      case BA_H_ARMOURY:
+        ent->think = HArmoury_Think;
+        break;
+      case BA_H_DCC:
+        ent->think = HDCC_Think;
+        break;
+      case BA_H_MEDISTAT:
+        ent->think = HMedistat_Think;
+        break;
+      case BA_H_REACTOR:
+        ent->think = HReactor_Think;
+        break;
+      case BA_H_REPEATER:
+        ent->think = HRepeater_Think;
+        break;
+    }
+    ent->nextthink = level.time + BG_FindNextThinkForBuildable( ent->s.modelindex );
+    // oh if only everything was that simple
+    return;
+  }
+  for( i = 0; i < n; i++ )
+  {
+    vec3_t gtfo;
+    targ = g_entities + occupants[ i ];
+    if( targ->client )
+    {
+      VectorSet( gtfo, crandom() * 150, crandom() * 150, random() * 150 );
+      VectorAdd( targ->client->ps.velocity, gtfo, targ->client->ps.velocity );
+    }
+  }
+#define REVERT_THINK_INTERVAL 50
+  ent->nextthink = level.time + REVERT_THINK_INTERVAL;
+}
+
+/*
+============
+G_RevertCanFit
+
+take a bhist and make sure you're not overwriting anything by placing it
+============
+*/
+qboolean G_RevertCanFit( buildHistory_t *bh )
+{
+  int i, num, blockers[ MAX_GENTITIES ];
+  vec3_t mins, maxs;
+  gentity_t *targ;
+  vec3_t dist;
+
+  BG_FindBBoxForBuildable( bh->buildable, mins, maxs );
+  VectorAdd( bh->origin, mins, mins );
+  VectorAdd( bh->origin, maxs, maxs );
+  num = trap_EntitiesInBox( mins, maxs, blockers, MAX_GENTITIES );
+  for( i = 0; i < num; i++ )
+  {
+    targ = g_entities + blockers[ i ];
+    if( targ->s.eType == ET_BUILDABLE )
+    {
+      VectorSubtract( bh->origin, targ->s.pos.trBase, dist );
+      if( targ->s.modelindex == bh->buildable && VectorLength( dist ) < 10 && targ->health <= 0 )
+        continue; // it's the same buildable, hasn't blown up yet
+      else
+        return qfalse; // can't get rid of this one
+    }
+    else
+      continue;
+  }
+  return qtrue;
+}
+
+/*
+============
 G_LayoutLoad
 
 load the layout .dat file indicated by level.layout and spawn buildables
@@ -3716,3 +4258,39 @@
   }
 }
 
+ int G_LogBuild( buildHistory_t *new )
+ { 
+   new->next = level.buildHistory;
+   level.buildHistory = new;
+   return G_CountBuildLog();
+ }
+ 
+ int G_CountBuildLog( void )
+ {
+   buildHistory_t *ptr, *mark;
+   int i = 0, overflow;
+   for( ptr = level.buildHistory; ptr; ptr = ptr->next, i++ );
+   if( i > g_buildLogMaxLength.integer )
+   {
+     for( overflow = i - g_buildLogMaxLength.integer; overflow > 0; overflow-- )
+     {
+       ptr = level.buildHistory;
+       while( ptr->next )
+       {
+     if( ptr->next->next )
+       ptr = ptr->next;
+     else
+     {
+       while( mark = ptr->next )
+       {
+         ptr->next = ptr->next->marked;
+             G_Free( mark );
+       }
+     }
+       }
+     }
+     return g_buildLogMaxLength.integer;
+   }
+   return i;
+ }
+ 
\ No newline at end of file
Index: src/game/g_main.c
===================================================================
--- src/game/g_main.c	(revision 966)
+++ src/game/g_main.c	(working copy)
@@ -42,10 +42,14 @@
 vmCvar_t  g_fraglimit;
 vmCvar_t  g_timelimit;
 vmCvar_t  g_suddenDeathTime;
+vmCvar_t  g_suddenDeath;
+vmCvar_t  g_suddenDeathMode;
 vmCvar_t  g_capturelimit;
 vmCvar_t  g_friendlyFire;
 vmCvar_t  g_friendlyFireAliens;
 vmCvar_t  g_friendlyFireHumans;
+vmCvar_t  g_friendlyFireMovementAttacks;
+vmCvar_t  g_retribution;
 vmCvar_t  g_friendlyBuildableFire;
 vmCvar_t  g_password;
 vmCvar_t  g_needpass;
@@ -69,6 +73,7 @@
 vmCvar_t  g_warmup;
 vmCvar_t  g_doWarmup;
 vmCvar_t  g_restarted;
+vmCvar_t  g_lockTeamsAtStart;
 vmCvar_t  g_logFile;
 vmCvar_t  g_logFileSync;
 vmCvar_t  g_blood;
@@ -76,11 +81,15 @@
 vmCvar_t  g_podiumDrop;
 vmCvar_t  g_allowVote;
 vmCvar_t  g_voteLimit;
+vmCvar_t  g_suddenDeathVotePercent;
+vmCvar_t  g_mapVotesPercent;
+vmCvar_t  g_designateVotes;
 vmCvar_t  g_teamAutoJoin;
 vmCvar_t  g_teamForceBalance;
 vmCvar_t  g_banIPs;
 vmCvar_t  g_filterBan;
 vmCvar_t  g_smoothClients;
+vmCvar_t  g_clientUpgradeNotice;
 vmCvar_t  pmove_fixed;
 vmCvar_t  pmove_msec;
 vmCvar_t  g_rankings;
@@ -88,6 +97,8 @@
 vmCvar_t  g_minCommandPeriod;
 vmCvar_t  g_minNameChangePeriod;
 vmCvar_t  g_maxNameChanges;
+vmCvar_t  g_newbieNumbering;
+vmCvar_t  g_newbieNamePrefix;
 
 vmCvar_t  g_humanBuildPoints;
 vmCvar_t  g_alienBuildPoints;
@@ -101,6 +112,7 @@
 vmCvar_t  g_alienMaxStage;
 vmCvar_t  g_alienStage2Threshold;
 vmCvar_t  g_alienStage3Threshold;
+vmCvar_t  g_teamImbalanceWarnings;
 
 vmCvar_t  g_unlagged;
 
@@ -109,6 +121,7 @@
 vmCvar_t  g_disabledBuildables;
 
 vmCvar_t  g_markDeconstruct;
+vmCvar_t  g_deconDead;
 
 vmCvar_t  g_debugMapRotation;
 vmCvar_t  g_currentMapRotation;
@@ -119,6 +132,8 @@
 
 vmCvar_t  g_mapConfigs;
 vmCvar_t  g_chatTeamPrefix;
+vmCvar_t  g_floodMaxDemerits;
+vmCvar_t  g_floodMinTime;
 
 vmCvar_t  g_layouts;
 vmCvar_t  g_layoutAuto;
@@ -126,13 +141,37 @@
 vmCvar_t  g_admin;
 vmCvar_t  g_adminLog;
 vmCvar_t  g_adminParseSay;
+vmCvar_t  g_adminSayFilter;
 vmCvar_t  g_adminNameProtect;
 vmCvar_t  g_adminTempBan;
+vmCvar_t  g_minLevelToJoinTeam;
 
 vmCvar_t  g_privateMessages;
+vmCvar_t  g_decolourLogfiles;
+vmCvar_t  g_minLevelToSpecMM1;
+vmCvar_t  g_publicSayadmins;
+vmCvar_t  g_myStats;
+vmCvar_t  g_antiSpawnBlock;
 
+vmCvar_t  g_devmapKillerHP;
+
+vmCvar_t  g_buildLogMaxLength;
+
 vmCvar_t  g_tag;
 
+vmCvar_t  g_dretchPunt;
+
+vmCvar_t  g_allowActions;
+vmCvar_t  g_actionPrefix;
+
+vmCvar_t  g_allowShare;
+
+vmCvar_t  g_devmapNoGod;
+vmCvar_t  g_devmapNoStructDmg;
+
+vmCvar_t  g_voteMinTime;
+vmCvar_t  g_mapvoteMaxTime;
+
 static cvarTable_t   gameCvarTable[ ] =
 {
   // don't override the cheat state set by the system
@@ -142,6 +181,7 @@
   { NULL, "gamename", GAME_VERSION , CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "gamedate", __DATE__ , CVAR_ROM, 0, qfalse  },
   { &g_restarted, "g_restarted", "0", CVAR_ROM, 0, qfalse  },
+  { &g_lockTeamsAtStart, "g_lockTeamsAtStart", "0", CVAR_ROM, 0, qfalse  },
   { NULL, "sv_mapname", "", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "P", "", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "ff", "0", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
@@ -149,24 +189,30 @@
   // latched vars
 
   { &g_maxclients, "sv_maxclients", "8", CVAR_SERVERINFO | CVAR_LATCH | CVAR_ARCHIVE, 0, qfalse  },
-  { &g_maxGameClients, "g_maxGameClients", "0", CVAR_SERVERINFO | CVAR_LATCH | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_maxGameClients, "g_maxGameClients", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue  },
 
   // change anytime vars
-  { &g_timelimit, "timelimit", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
-  { &g_suddenDeathTime, "g_suddenDeathTime", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_timelimit, "timelimit", "45", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeathTime, "g_suddenDeathTime", "30", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeathMode, "g_suddenDeathMode", "2", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeath, "g_suddenDeath", "0", CVAR_SERVERINFO | CVAR_NORESTART, 0, qtrue },
 
   { &g_synchronousClients, "g_synchronousClients", "0", CVAR_SYSTEMINFO, 0, qfalse  },
 
-  { &g_friendlyFire, "g_friendlyFire", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyFire, "g_friendlyFire", "0", CVAR_ARCHIVE | CVAR_SERVERINFO, 0, qtrue  },
   { &g_friendlyFireAliens, "g_friendlyFireAliens", "0", CVAR_ARCHIVE, 0, qtrue  },
   { &g_friendlyFireHumans, "g_friendlyFireHumans", "0", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_friendlyBuildableFire, "g_friendlyBuildableFire", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_retribution, "g_retribution", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyBuildableFire, "g_friendlyBuildableFire", "0", CVAR_ARCHIVE | CVAR_SERVERINFO, 0, qtrue  },
+  { &g_friendlyFireMovementAttacks, "g_friendlyFireMovementAttacks", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_devmapNoGod, "g_devmapNoGod", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_devmapNoStructDmg, "g_devmapNoStructDmg", "0", CVAR_ARCHIVE, 0, qtrue  },
 
   { &g_teamAutoJoin, "g_teamAutoJoin", "0", CVAR_ARCHIVE  },
-  { &g_teamForceBalance, "g_teamForceBalance", "0", CVAR_ARCHIVE  },
+  { &g_teamForceBalance, "g_teamForceBalance", "1", CVAR_ARCHIVE  },
 
-  { &g_warmup, "g_warmup", "20", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_doWarmup, "g_doWarmup", "0", 0, 0, qtrue  },
+  { &g_warmup, "g_warmup", "10", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_doWarmup, "g_doWarmup", "1", CVAR_ARCHIVE, 0, qtrue  },
   { &g_logFile, "g_logFile", "games.log", CVAR_ARCHIVE, 0, qfalse  },
   { &g_logFileSync, "g_logFileSync", "0", CVAR_ARCHIVE, 0, qfalse  },
 
@@ -179,9 +225,9 @@
 
   { &g_dedicated, "dedicated", "0", 0, 0, qfalse  },
 
-  { &g_speed, "g_speed", "320", 0, 0, qtrue  },
-  { &g_gravity, "g_gravity", "800", 0, 0, qtrue  },
-  { &g_knockback, "g_knockback", "1000", 0, 0, qtrue  },
+  { &g_speed, "g_speed", "320", CVAR_SERVERINFO, 0, qtrue  },
+  { &g_gravity, "g_gravity", "800", CVAR_SERVERINFO, 0, qtrue  },
+  { &g_knockback, "g_knockback", "1000", CVAR_SERVERINFO, 0, qtrue  },
   { &g_quadfactor, "g_quadfactor", "3", 0, 0, qtrue  },
   { &g_weaponRespawn, "g_weaponrespawn", "5", 0, 0, qtrue  },
   { &g_weaponTeamRespawn, "g_weaponTeamRespawn", "30", 0, 0, qtrue },
@@ -198,17 +244,26 @@
 
   { &g_allowVote, "g_allowVote", "1", CVAR_ARCHIVE, 0, qfalse },
   { &g_voteLimit, "g_voteLimit", "5", CVAR_ARCHIVE, 0, qfalse },
+  { &g_voteMinTime, "g_voteMinTime", "120", CVAR_ARCHIVE, 0, qfalse },
+  { &g_mapvoteMaxTime, "g_mapvoteMaxTime", "240", CVAR_ARCHIVE, 0, qfalse },
+  { &g_suddenDeathVotePercent, "g_suddenDeathVotePercent", "75", CVAR_ARCHIVE, 0, qfalse },
+  { &g_mapVotesPercent, "g_mapVotesPercent", "50", CVAR_ARCHIVE, 0, qfalse },
+  { &g_designateVotes, "g_designateVotes", "0", CVAR_ARCHIVE, 0, qfalse },
+  
   { &g_listEntity, "g_listEntity", "0", 0, 0, qfalse },
   { &g_minCommandPeriod, "g_minCommandPeriod", "500", 0, 0, qfalse},
   { &g_minNameChangePeriod, "g_minNameChangePeriod", "5", 0, 0, qfalse},
   { &g_maxNameChanges, "g_maxNameChanges", "5", 0, 0, qfalse},
+  { &g_newbieNumbering, "g_newbieNumbering", "0", CVAR_ARCHIVE, 0, qfalse},
+  { &g_newbieNamePrefix, "g_newbieNamePrefix", "Newbie#", CVAR_ARCHIVE, 0, qfalse},
 
   { &g_smoothClients, "g_smoothClients", "1", 0, 0, qfalse},
+  { &g_clientUpgradeNotice, "g_clientUpgradeNotice", "1", 0, 0, qfalse},
   { &pmove_fixed, "pmove_fixed", "0", CVAR_SYSTEMINFO, 0, qfalse},
   { &pmove_msec, "pmove_msec", "8", CVAR_SYSTEMINFO, 0, qfalse},
 
-  { &g_humanBuildPoints, "g_humanBuildPoints", DEFAULT_HUMAN_BUILDPOINTS, 0, 0, qfalse  },
-  { &g_alienBuildPoints, "g_alienBuildPoints", DEFAULT_ALIEN_BUILDPOINTS, 0, 0, qfalse  },
+  { &g_humanBuildPoints, "g_humanBuildPoints", DEFAULT_HUMAN_BUILDPOINTS, CVAR_SERVERINFO, 0, qfalse  },
+  { &g_alienBuildPoints, "g_alienBuildPoints", DEFAULT_ALIEN_BUILDPOINTS, CVAR_SERVERINFO, 0, qfalse  },
   { &g_humanStage, "g_humanStage", "0", 0, 0, qfalse  },
   { &g_humanKills, "g_humanKills", "0", 0, 0, qfalse  },
   { &g_humanMaxStage, "g_humanMaxStage", DEFAULT_HUMAN_MAX_STAGE, 0, 0, qfalse  },
@@ -220,21 +275,26 @@
   { &g_alienStage2Threshold, "g_alienStage2Threshold", DEFAULT_ALIEN_STAGE2_THRESH, 0, 0, qfalse  },
   { &g_alienStage3Threshold, "g_alienStage3Threshold", DEFAULT_ALIEN_STAGE3_THRESH, 0, 0, qfalse  },
   
+  { &g_teamImbalanceWarnings, "g_teamImbalanceWarnings", "30", CVAR_ARCHIVE, 0, qfalse  },
+  
   { &g_unlagged, "g_unlagged", "1", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_disabledEquipment, "g_disabledEquipment", "", CVAR_ROM, 0, qfalse  },
   { &g_disabledClasses, "g_disabledClasses", "", CVAR_ROM, 0, qfalse  },
   { &g_disabledBuildables, "g_disabledBuildables", "", CVAR_ROM, 0, qfalse  },
 
-  { &g_chatTeamPrefix, "g_chatTeamPrefix", "0", CVAR_ARCHIVE  },
+  { &g_chatTeamPrefix, "g_chatTeamPrefix", "1", CVAR_ARCHIVE  },
+  { &g_floodMaxDemerits, "g_floodMaxDemerits", "5000", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_floodMinTime, "g_floodMinTime", "2000", CVAR_ARCHIVE, 0, qfalse  },
 
-  { &g_markDeconstruct, "g_markDeconstruct", "1", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_markDeconstruct, "g_markDeconstruct", "0", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_deconDead, "g_deconDead", "0", CVAR_ARCHIVE, 0, qtrue  },
 
   { &g_debugMapRotation, "g_debugMapRotation", "0", 0, 0, qfalse  },
   { &g_currentMapRotation, "g_currentMapRotation", "-1", 0, 0, qfalse  }, // -1 = NOT_ROTATING
   { &g_currentMap, "g_currentMap", "0", 0, 0, qfalse  },
   { &g_initialMapRotation, "g_initialMapRotation", "", CVAR_ARCHIVE, 0, qfalse  },
-  { &g_shove, "g_shove", "0.0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_shove, "g_shove", "15", CVAR_ARCHIVE, 0, qfalse  },
   { &g_mapConfigs, "g_mapConfigs", "", CVAR_ARCHIVE, 0, qfalse  },
   { NULL, "g_mapConfigsLoaded", "0", CVAR_ROM, 0, qfalse  },
 
@@ -244,14 +304,29 @@
   { &g_admin, "g_admin", "admin.dat", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminLog, "g_adminLog", "admin.log", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminParseSay, "g_adminParseSay", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminSayFilter, "g_adminSayFilter", "0", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminNameProtect, "g_adminNameProtect", "1", CVAR_ARCHIVE, 0, qfalse  },
-  { &g_adminTempBan, "g_adminTempBan", "120", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminTempBan, "g_adminTempBan", "2m", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_minLevelToJoinTeam, "g_minLevelToJoinTeam", "0", CVAR_ARCHIVE, 0, qfalse  },
   
   { &g_privateMessages, "g_privateMessages", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_decolourLogfiles, "g_decolourLogfiles", "0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_buildLogMaxLength, "g_buildLogMaxLength", "25", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_myStats, "g_myStats", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_publicSayadmins, "g_publicSayadmins", "1", CVAR_ARCHIVE, 0, qfalse  },    
+  { &g_minLevelToSpecMM1, "g_minLevelToSpecMM1", "0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_antiSpawnBlock, "g_antiSpawnBlock", "0", CVAR_ARCHIVE, 0, qfalse  },
   
+  { &g_devmapKillerHP, "g_devmapKillerHP", "0", CVAR_ARCHIVE, 0, qtrue  },
+  
   { &g_tag, "g_tag", "main", CVAR_INIT, 0, qfalse },
   
-  { &g_rankings, "g_rankings", "0", 0, 0, qfalse}
+  { &g_dretchPunt, "g_dretchPunt", "1", CVAR_ARCHIVE, 0, qfalse  },
+  
+  { &g_rankings, "g_rankings", "0", 0, 0, qfalse },
+  { &g_allowShare, "g_allowShare", "1", CVAR_ARCHIVE | CVAR_SERVERINFO, 0, qfalse},
+  { &g_allowActions, "g_allowActions", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_actionPrefix, "g_actionPrefix", "***", CVAR_ARCHIVE, 0, qfalse }
 };
 
 static int gameCvarTableSize = sizeof( gameCvarTable ) / sizeof( gameCvarTable[ 0 ] );
@@ -443,9 +518,6 @@
 
   if( remapped )
     G_RemapTeamShaders( );
-
-  // check some things
-  level.warmupModificationCount = g_warmup.modificationCount;
 }
 
 /*
@@ -553,11 +625,20 @@
     else
     {
       char serverinfo[ MAX_INFO_STRING ];
+      qtime_t qt;
+      int t;
 
+
       trap_GetServerinfo( serverinfo, sizeof( serverinfo ) );
 
       G_LogPrintf( "------------------------------------------------------------\n" );
       G_LogPrintf( "InitGame: %s\n", serverinfo );
+
+      t = trap_RealTime( &qt );
+      G_LogPrintf("RealTime: %04i/%02i/%02i %02i:%02i:%02i\n",
+            qt.tm_year+1900, qt.tm_mon+1, qt.tm_mday, 
+            qt.tm_hour, qt.tm_min, qt.tm_sec );
+
     }
   }
   else
@@ -632,6 +713,7 @@
   trap_Cvar_Set( "g_humanStage", va( "%d", S1 ) );
   trap_Cvar_Set( "g_alienKills", 0 );
   trap_Cvar_Set( "g_humanKills", 0 );
+  trap_Cvar_Set( "g_suddenDeath", 0 );
 
   G_Printf( "-----------------------------------\n" );
 
@@ -641,6 +723,13 @@
   G_CountSpawns( );
 
   G_ResetPTRConnections( );
+  
+  if(g_lockTeamsAtStart.integer)
+  {
+    level.alienTeamLocked=qtrue;
+    level.humanTeamLocked=qtrue;
+    trap_Cvar_Set( "g_lockTeamsAtStart", "0" );
+  }
 }
 
 /*
@@ -741,9 +830,9 @@
   cb = &level.clients[ *(int *)b ];
 
   // then sort by score
-  if( ca->ps.persistant[ PERS_SCORE ] > cb->ps.persistant[ PERS_SCORE ] )
+  if( ca->pers.score > cb->pers.score )
     return -1;
-  else if( ca->ps.persistant[ PERS_SCORE ] < cb->ps.persistant[ PERS_SCORE ] )
+  else if( ca->pers.score < cb->pers.score )
     return 1;
   else
     return 0;
@@ -825,17 +914,39 @@
 
 /*
 ============
+G_SearchSpawnQueue
+
+Look to see if clientNum is already in the spawnQueue
+============
+*/
+qboolean G_SearchSpawnQueue( spawnQueue_t *sq, int clientNum )
+{
+  int i;
+
+  for( i = 0; i < MAX_CLIENTS; i++ )
+    if( sq->clients[ i ] == clientNum )
+      return qtrue;
+  return qfalse;
+}
+
+/*
+============
 G_PushSpawnQueue
 
 Add an element to the back of the spawn queue
 ============
 */
-void G_PushSpawnQueue( spawnQueue_t *sq, int clientNum )
+qboolean G_PushSpawnQueue( spawnQueue_t *sq, int clientNum )
 {
+  // don't add the same client more than once
+  if( G_SearchSpawnQueue( sq, clientNum ) )
+    return qfalse;
+
   sq->back = QUEUE_PLUS1( sq->back );
   sq->clients[ sq->back ] = clientNum;
 
   g_entities[ clientNum ].client->ps.pm_flags |= PMF_QUEUED;
+  return qtrue;
 }
 
 /*
@@ -969,7 +1080,7 @@
     clientNum = G_PeekSpawnQueue( sq );
     ent = &g_entities[ clientNum ];
 
-    if( ( spawn = SelectTremulousSpawnPoint( team,
+    if( ( spawn = G_SelectTremulousSpawnPoint( team,
             ent->client->pers.lastDeathLocation,
             spawn_origin, spawn_angles ) ) )
     {
@@ -1050,31 +1161,68 @@
   gentity_t   *ent;
   int         localHTP = g_humanBuildPoints.integer,
               localATP = g_alienBuildPoints.integer;
+	
+  //g_suddenDeath sets what state we want it to be.  level.suddenDeath says whether we've calculated BPs at the 'start' of SD or not
 
-  if( g_suddenDeathTime.integer && !level.warmupTime )
-  {
-    if( G_TimeTilSuddenDeath( ) <= 0 )
-    {
-      localHTP = 0;
-      localATP = 0;
+  //reset if SD was on, but now it's off
+  if(!g_suddenDeath.integer && level.suddenDeath) {
+	  level.suddenDeath=qfalse;
+	  level.suddenDeathWarning=0;
+  }
 
-      //warn about sudden death
-      if( level.suddenDeathWarning < TW_PASSED )
-      {
-        trap_SendServerCommand( -1, "cp \"Sudden Death!\"" );
-        level.suddenDeathWarning = TW_PASSED;
-      }
+    if(!level.suddenDeath){
+	    if(g_suddenDeath.integer || G_TimeTilSuddenDeath( ) <= 0 ) //Conditions to enter SD
+	    {
+	      //begin sudden death
+	      if( level.suddenDeathWarning < TW_PASSED )
+	      {
+		trap_SendServerCommand( -1, "cp \"Sudden Death!\"" );
+		G_LogPrintf("Beginning Sudden Death (Mode %d)\n",g_suddenDeathMode.integer);
+		localHTP = 0;
+		localATP = 0;
+
+		if( g_suddenDeathMode.integer == SDMODE_SELECTIVE ) {
+		  for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
+		  {
+		    if( ent->s.eType != ET_BUILDABLE )
+		      continue;
+	    
+		    if( BG_FindReplaceableTestForBuildable( ent->s.modelindex ) )
+		    {
+		      int t = BG_FindTeamForBuildable( ent->s.modelindex );
+	    
+		      if( t == BIT_HUMANS )
+			localHTP += BG_FindBuildPointsForBuildable( ent->s.modelindex );
+		      else if( t == BIT_ALIENS )
+			localATP += BG_FindBuildPointsForBuildable( ent->s.modelindex );
+		    }
+		  }
+		}
+		level.suddenDeathHBuildPoints = localHTP;
+		level.suddenDeathABuildPoints = localATP;
+		level.suddenDeath=qtrue;
+		//trap_Cvar_Set( "g_suddenDeath", "1" );
+		g_suddenDeath.integer=1;
+
+		level.suddenDeathWarning = TW_PASSED;
+	      }
+	    }  else {
+	   
+	      //warn about sudden death
+	      if( G_TimeTilSuddenDeath( ) <= 60000 &&
+		  level.suddenDeathWarning < TW_IMMINENT )
+	      {
+		trap_SendServerCommand( -1, "cp \"Sudden Death in 1 minute!\"" );
+		level.suddenDeathWarning = TW_IMMINENT;
+	      }
+	    }
     }
-    else
-    {
-      //warn about sudden death
-      if( G_TimeTilSuddenDeath( ) <= 60000 &&
-          level.suddenDeathWarning < TW_IMMINENT )
-      {
-        trap_SendServerCommand( -1, "cp \"Sudden Death in 1 minute!\"" );
-        level.suddenDeathWarning = TW_IMMINENT;
-      }
-    }
+  
+  //set BP at each cycle
+  if( g_suddenDeath.integer )
+  {
+    localHTP = level.suddenDeathHBuildPoints;
+    localATP = level.suddenDeathABuildPoints;
   }
   else
   {
@@ -1106,17 +1254,19 @@
       if( buildable == BA_A_OVERMIND && ent->spawned && ent->health > 0 )
         level.overmindPresent = qtrue;
 
-      if( BG_FindTeamForBuildable( buildable ) == BIT_HUMANS )
+      if( !g_suddenDeath.integer || BG_FindReplaceableTestForBuildable( buildable ) )
       {
-        level.humanBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
-
-        if( ent->powered )
-          level.humanBuildPointsPowered -= BG_FindBuildPointsForBuildable( buildable );
+        if( BG_FindTeamForBuildable( buildable ) == BIT_HUMANS )
+        {
+          level.humanBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
+          if( ent->powered )
+            level.humanBuildPointsPowered -= BG_FindBuildPointsForBuildable( buildable );
+        }
+        else
+        {
+          level.alienBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
+        }
       }
-      else
-      {
-        level.alienBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
-      }
     }
   }
 
@@ -1194,6 +1344,7 @@
     G_Checktrigger_stages( PTE_ALIENS, S2 );
     trap_Cvar_Set( "g_alienStage", va( "%d", S2 ) );
     level.alienStage2Time = level.time;
+    G_LogPrintf("Stage: A 2: Aliens reached Stage 2\n");
   }
 
   if( g_alienKills.integer >=
@@ -1203,6 +1354,7 @@
     G_Checktrigger_stages( PTE_ALIENS, S3 );
     trap_Cvar_Set( "g_alienStage", va( "%d", S3 ) );
     level.alienStage3Time = level.time;
+    G_LogPrintf("Stage: A 3: Aliens reached Stage 3\n");
   }
 
   if( g_humanKills.integer >=
@@ -1212,6 +1364,7 @@
     G_Checktrigger_stages( PTE_HUMANS, S2 );
     trap_Cvar_Set( "g_humanStage", va( "%d", S2 ) );
     level.humanStage2Time = level.time;
+    G_LogPrintf("Stage: H 2: Humans reached Stage 2\n");
   }
 
   if( g_humanKills.integer >=
@@ -1221,6 +1374,7 @@
     G_Checktrigger_stages( PTE_HUMANS, S3 );
     trap_Cvar_Set( "g_humanStage", va( "%d", S3 ) );
     level.humanStage3Time = level.time;
+    G_LogPrintf("Stage: H 3: Humans reached Stage 3\n");
   }
 }
 
@@ -1274,10 +1428,6 @@
 void CalculateRanks( void )
 {
   int       i;
-  int       rank;
-  int       score;
-  int       newScore;
-  gclient_t *cl;
   char      P[ MAX_CLIENTS + 1 ] = {""};
   int       ff = 0;
 
@@ -1329,43 +1479,19 @@
   P[ i + 1 ] = '\0';
   trap_Cvar_Set( "P", P );
 
-  if( g_friendlyFire.integer )
+  if( g_friendlyFire.value>0 )
     ff |= ( FFF_HUMANS | FFF_ALIENS );
-  if( g_friendlyFireHumans.integer )
+  if( g_friendlyFireHumans.value>0  )
     ff |=  FFF_HUMANS;
-  if( g_friendlyFireAliens.integer )
+  if( g_friendlyFireAliens.value>0  )
     ff |=  FFF_ALIENS;
-  if( g_friendlyBuildableFire.integer )
+  if( g_friendlyBuildableFire.value>0  )
     ff |=  FFF_BUILDABLES;
   trap_Cvar_Set( "ff", va( "%i", ff ) );
 
   qsort( level.sortedClients, level.numConnectedClients,
     sizeof( level.sortedClients[ 0 ] ), SortRanks );
 
-  // set the rank value for all clients that are connected and not spectators
-  rank = -1;
-  score = 0;
-  for( i = 0;  i < level.numPlayingClients; i++ )
-  {
-    cl = &level.clients[ level.sortedClients[ i ] ];
-    newScore = cl->ps.persistant[ PERS_SCORE ];
-
-    if( i == 0 || newScore != score )
-    {
-      rank = i;
-      // assume we aren't tied until the next client is checked
-      level.clients[ level.sortedClients[ i ] ].ps.persistant[ PERS_RANK ] = rank;
-    }
-    else
-    {
-      // we are tied with the previous client
-      level.clients[ level.sortedClients[ i - 1 ] ].ps.persistant[ PERS_RANK ] = rank;
-      level.clients[ level.sortedClients[ i ] ].ps.persistant[ PERS_RANK ] = rank;
-    }
-
-    score = newScore;
-  }
-
   // see if it is time to end the level
   CheckExitRules( );
 
@@ -1451,7 +1577,7 @@
 
   if( !ent )
   { // the map creator forgot to put in an intermission point...
-    SelectSpawnPoint( vec3_origin, level.intermission_origin, level.intermission_angle );
+    G_SelectSpawnPoint( vec3_origin, level.intermission_origin, level.intermission_angle );
   }
   else
   {
@@ -1485,6 +1611,8 @@
   if( level.intermissiontime )
     return;   // already active
 
+  level.numTeamWarnings = 99;
+  
   level.intermissiontime = level.time;
 
   G_ClearVotes( );
@@ -1523,7 +1651,18 @@
 {
   int       i;
   gclient_t *cl;
+  buildHistory_t *tmp, *mark;
 
+  while( tmp = level.buildHistory )
+  {
+    level.buildHistory = level.buildHistory->next;
+    while( mark = tmp )
+    {
+      tmp = tmp->marked;
+      G_Free( mark );
+    }
+  }
+
   if( G_MapRotationActive( ) )
     G_AdvanceMapRotation( );
   else
@@ -1555,7 +1694,37 @@
   }
 
 }
+/*
+=================
+G_AdminsPrintf
 
+Print to all active admins, and the logfile with a time stamp if it is open, and to the console
+=================
+*/
+void QDECL G_AdminsPrintf( const char *fmt, ... )
+{
+  va_list argptr;
+  char    string[ 1024 ];	
+  gentity_t   *tempent;
+  int j;
+	
+  va_start( argptr, fmt );
+  vsprintf( string, fmt,argptr );
+  va_end( argptr );
+	
+  for( j = 0; j < level.maxclients; j++ )
+  {
+    tempent = &g_entities[ j ];
+    if( G_admin_permission( tempent, ADMF_ADMINCHAT) ) 
+    {
+       trap_SendServerCommand(tempent-g_entities,va( "print \"^6[Admins]^7 %s\"", string) ); 
+    }
+  }
+  
+  G_LogPrintf("%s",string);
+	
+}
+
 /*
 =================
 G_LogPrintf
@@ -1566,6 +1735,49 @@
 void QDECL G_LogPrintf( const char *fmt, ... )
 {
   va_list argptr;
+  char    string[ 1024 ], decoloured[ 1024 ];
+  int     min, tens, sec;
+
+  sec = level.time / 1000;
+
+  min = sec / 60;
+  sec -= min * 60;
+  tens = sec / 10;
+  sec -= tens * 10;
+
+  Com_sprintf( string, sizeof( string ), "%3i:%i%i ", min, tens, sec );
+
+  va_start( argptr, fmt );
+  vsprintf( string +7 , fmt,argptr );
+  va_end( argptr );
+
+  if( g_dedicated.integer )
+    G_Printf( "%s", string + 7 );
+
+  if( !level.logFile )
+    return;
+
+  if( g_decolourLogfiles.integer )
+  {
+    G_DecolorString( string, decoloured );
+    trap_FS_Write( decoloured, strlen( decoloured ), level.logFile );
+  }
+  else
+  {
+    trap_FS_Write( string, strlen( string ), level.logFile );
+  }
+}
+
+/*
+=================
+G_LogPrintfColoured
+
+Bypasses g_decolourLogfiles for events that need colors in the logs
+=================
+*/
+void QDECL G_LogPrintfColoured( const char *fmt, ... )
+{
+  va_list argptr;
   char    string[ 1024 ];
   int     min, tens, sec;
 
@@ -1593,6 +1805,46 @@
 
 /*
 =================
+G_LogOnlyPrintf
+
+Print to the logfile only (not console) with a time stamp if it is open
+=================
+*/
+void QDECL G_LogOnlyPrintf( const char *fmt, ... )
+{
+  va_list argptr;
+  char    string[ 1024 ], decoloured[ 1024 ];
+  int     min, tens, sec;
+
+  sec = level.time / 1000;
+
+  min = sec / 60;
+  sec -= min * 60;
+  tens = sec / 10;
+  sec -= tens * 10;
+
+  Com_sprintf( string, sizeof( string ), "%3i:%i%i ", min, tens, sec );
+
+  va_start( argptr, fmt );
+  vsprintf( string +7 , fmt,argptr );
+  va_end( argptr );
+
+  if( !level.logFile )
+    return;
+
+  if( g_decolourLogfiles.integer )
+  {
+    G_DecolorString( string, decoloured );
+    trap_FS_Write( decoloured, strlen( decoloured ), level.logFile );
+  }
+  else
+  {
+    trap_FS_Write( string, strlen( string ), level.logFile );
+  }
+}
+
+/*
+=================
 G_SendGameStat
 =================
 */
@@ -1876,7 +2128,7 @@
     return;
   }
 
-  if( g_timelimit.integer && !level.warmupTime )
+  if( g_timelimit.integer )
   {
     if( level.time - level.startTime >= g_timelimit.integer * 60000 )
     {
@@ -1942,6 +2194,9 @@
 */
 void CheckVote( void )
 {
+  int votePercentToPass=level.votePercentToPass;
+  int voteYesPercent;
+	
   if( level.voteExecuteTime && level.voteExecuteTime < level.time )
   {
     level.voteExecuteTime = 0;
@@ -1957,32 +2212,41 @@
   if( !level.voteTime )
     return;
 
-  if( level.time - level.voteTime >= VOTE_TIME )
+  if( level.voteYes + level.voteNo > 0 )
+   voteYesPercent = (int)(100* (level.voteYes)/(level.voteYes + level.voteNo));
+  else
+   voteYesPercent = 0; 
+  
+  if( level.time - level.voteTime >= VOTE_TIME || ( level.voteYes + level.voteNo == level.numConnectedClients ) )
   {
-    if( level.voteYes > level.voteNo )
+    if( voteYesPercent> votePercentToPass || level.voteNo == 0 )
     {
       // execute the command, then remove the vote
       trap_SendServerCommand( -1, "print \"Vote passed\n\"" );
+      G_LogPrintf( "Vote: Vote passed (%d-%d)\n", level.voteYes, level.voteNo );
       level.voteExecuteTime = level.time + 3000;
     }
     else
     {
       // same behavior as a timeout
       trap_SendServerCommand( -1, "print \"Vote failed\n\"" );
+      G_LogPrintf( "Vote: Vote failed (%d - %d)\n", level.voteYes, level.voteNo );
     }
   }
   else
   {
-    if( level.voteYes > level.numVotingClients / 2 )
+    if( level.voteYes > (int)((double)level.numConnectedClients * ((double)votePercentToPass/100.0)) )
     {
       // execute the command, then remove the vote
       trap_SendServerCommand( -1, "print \"Vote passed\n\"" );
+      G_LogPrintf( "Vote: Vote passed (%d - %d)\n", level.voteYes, level.voteNo );
       level.voteExecuteTime = level.time + 3000;
     }
-    else if( level.voteNo >= level.numVotingClients / 2 )
+    else if( level.voteNo > (int)((double)level.numConnectedClients * ((double)(100.0-votePercentToPass)/100.0)) )
     {
       // same behavior as a timeout
-      trap_SendServerCommand( -1, "print \"Vote failed\n\"" );
+      G_LogPrintf("Vote: Vote failed (%d - %d)\n", level.voteYes, level.voteNo );
+      G_LogOnlyPrintf("Vote failed\n");
     }
     else
     {
@@ -2017,7 +2281,17 @@
 
   if( level.time - level.teamVoteTime[ cs_offset ] >= VOTE_TIME )
   {
-    trap_SendServerCommand( -1, "print \"Team vote failed\n\"" );
+    if( level.teamVoteYes[ cs_offset ] > level.teamVoteNo[ cs_offset ] && level.teamVoteYes[ cs_offset ] >= 2 )
+    {
+      // execute the command, then remove the vote
+      trap_SendServerCommand( -1, "print \"Team vote passed\n\"" );
+      trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.teamVoteString[ cs_offset ] ) );
+    }
+    else
+    {	    
+      trap_SendServerCommand( -1, "print \"Team vote failed\n\"" );
+      G_LogPrintf( "Teamvote: Team vote failed (%d - %d)\n", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] );
+    }
   }
   else
   {
@@ -2025,13 +2299,15 @@
     {
       // execute the command, then remove the vote
       trap_SendServerCommand( -1, "print \"Team vote passed\n\"" );
+      G_LogPrintf( "Teamvote: Team vote passed (%d - %d)\n", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] );
       //
       trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.teamVoteString[ cs_offset ] ) );
     }
-    else if( level.teamVoteNo[ cs_offset ] >= level.numteamVotingClients[ cs_offset ] / 2 )
+    else if( level.teamVoteNo[ cs_offset ] > level.numteamVotingClients[ cs_offset ] / 2 )
     {
       // same behavior as a timeout
       trap_SendServerCommand( -1, "print \"Team vote failed\n\"" );
+      G_LogPrintf( "Teamvote: Team vote failed (%d - %d)\n", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] );
     }
     else
     {
@@ -2085,6 +2361,8 @@
       ent->deconstruct = qfalse;
     }
   }
+
+  level.frameMsec = trap_Milliseconds( );
 }
 
 /*
@@ -2151,6 +2429,20 @@
   // if we are waiting for the level to restart, do nothing
   if( level.restarted )
     return;
+  
+  if( level.paused ) 
+  {
+    level.pausedTime = levelTime - level.time;
+    if( ( level.pausedTime % 3000 ) == 0) 
+      trap_SendServerCommand( -1, "cp \"The game has been paused. Please wait.\"" );
+    
+   for(i=0;i<level.maxclients;i++)
+   {
+     level.clients[ i ].ps.commandTime = levelTime;
+   }
+	
+   return;
+  }
 
   level.framenum++;
   level.previousTime = level.time;
@@ -2295,5 +2587,7 @@
 
     trap_Cvar_Set( "g_listEntity", "0" );
   }
+  
+  level.pausedTime=0;
 }
 
Index: src/game/bg_pmove.c
===================================================================
--- src/game/bg_pmove.c	(revision 966)
+++ src/game/bg_pmove.c	(working copy)
@@ -510,12 +510,19 @@
       pm->ps->weapon != WP_ALEVEL3_UPG )
     return qfalse;
 
-  if( pm->cmd.buttons & BUTTON_ATTACK2 )
+  // we were pouncing, but we've landed  
+  if( pm->ps->groundEntityNum != ENTITYNUM_NONE
+    && ( pm->ps->pm_flags & PMF_CHARGE ) )
   {
+    pm->ps->weaponTime += LEVEL3_POUNCE_TIME;
     pm->ps->pm_flags &= ~PMF_CHARGE;
-    return qfalse;
   }
 
+  // we're building up for a pounce
+  if( pm->cmd.buttons & BUTTON_ATTACK2 )
+    return qfalse;
+
+  // already a pounce in progress
   if( pm->ps->pm_flags & PMF_CHARGE )
     return qfalse;
 
@@ -2698,7 +2705,15 @@
     return;
   }
 
-  // make weapon function
+  
+  // no bite during pounce
+  if( ( pm->ps->weapon == WP_ALEVEL3 || pm->ps->weapon == WP_ALEVEL3_UPG ) 
+    && ( pm->cmd.buttons & BUTTON_ATTACK )
+    && ( pm->ps->pm_flags & PMF_CHARGE ) )
+  {
+    return;
+  }
+
   if( pm->ps->weaponTime > 0 )
     pm->ps->weaponTime -= pml.msec;
 
@@ -2908,7 +2923,13 @@
       }
       break;
   }
-
+  
+  if ( pm->ps->weapon == WP_LUCIFER_CANNON && pm->ps->stats[ STAT_MISC ] > 0 && attack3 )
+  {
+    attack1 = qtrue;
+    attack3 = qfalse;
+  }
+	  
   //TA: fire events for non auto weapons
   if( attack3 )
   {
Index: src/game/g_admin.c
===================================================================
--- src/game/g_admin.c	(revision 966)
+++ src/game/g_admin.c	(working copy)
@@ -38,6 +38,13 @@
 // note: list ordered alphabetically
 g_admin_cmd_t g_admin_cmds[ ] = 
   {
+    {"adjustban", G_admin_adjustban, "b",
+      "change the duration or reason of a ban.  time is specified as numbers "
+      "followed by units 'w' (weeks), 'd' (days), 'h' (hours) or 'm' (minutes),"
+      " or seconds if no units are specified",
+      "[^3ban#^7] (^5time^7) (^5reason^7)"
+    },
+
     {"admintest", G_admin_admintest, "a",
       "display your current admin level",
       ""
@@ -55,11 +62,19 @@
 
     {"ban", G_admin_ban, "b",
       "ban a player by IP and GUID with an optional expiration time and reason."
-      "  time is seconds or suffix with 'w' - weeks, 'd' - days, 'h' - hours, "
-      "or 'm' - minutes",
+      "  time is specified as numbers followed by units 'w' (weeks), 'd' "
+      "(days), 'h' (hours) or 'm' (minutes), or seconds if no units are "
+      "specified",
       "[^3name|slot#|IP^7] (^5time^7) (^5reason^7)"
     },
 
+    {"buildlog", G_admin_buildlog, "U",
+      "display a list of recent builds and deconstructs, optionally specifying"
+      " a team",
+      "(^5xnum^7) (^5#skip^7) (^5-name|num^7) (^5a|h^7)"
+      "\n ^3Example:^7 '!buildlog #10 h' skips 10 events, then shows the previous 10 events affecting human buildables"
+    },
+
     {"cancelvote", G_admin_cancelvote, "c",
       "cancel a vote taking place",
       ""
@@ -70,19 +85,44 @@
       "[^3name|slot#^7]"
     },
 
+    {"designate", G_admin_designate, "g",
+      "give the player designated builder privileges",
+      "[^3name|slot#^7]"
+    },
+    
+    {"devmap", G_admin_devmap, "L",
+      "load a map with cheats (and optionally force layout)",
+      "[^3mapname^7] (^5layout^7)"
+    },
+    
     {"help", G_admin_help, "h",
       "display commands available to you or help on a specific command",
       "(^5command^7)"
     },
 
+  {"info", G_admin_info, "H",
+    "display the contents of server info files",
+    "(^5subject^7)"
+  },
+
     {"kick", G_admin_kick, "k",
       "kick a player with an optional reason",
       "(^5reason^7)"
     },
     
+    {"L1", G_admin_L1, "l",
+      "Sets a level 0 to level 1",
+      "[^3name|slot#^7]"
+    },
+    
+    {"layoutsave", G_admin_layoutsave, "L",
+      "save a map layout",
+      "[^3mapname^7]"
+    },
+    
     {"listadmins", G_admin_listadmins, "D",
       "display a list of all server admins and their levels",
-      "(^5name|start admin#^7)"
+      "(^5name|start admin#^7) (^5minimum level to display^7)"
     },
     
     {"listlayouts", G_admin_listlayouts, "L",
@@ -124,7 +164,13 @@
       "pass a vote currently taking place",
       ""
     },
+    
+    {"pause", G_admin_pause, "S",
+      "Pause (or unpause) the game.",
+      ""
+    },
 
+
     {"putteam", G_admin_putteam, "p",
       "move a player to a specified team",
       "[^3name|slot#^7] [^3h|a|s^7]"
@@ -134,6 +180,11 @@
       "reloads the admin config file and refreshes permission flags",
       ""
     },
+    
+    {"register", G_admin_register, "R",
+      "Registers your name to protect it from being used by others or updates your admin name to your current name.",
+      ""
+    },
 
     {"rename", G_admin_rename, "N",
       "rename a player",
@@ -141,10 +192,16 @@
     },
 
     {"restart", G_admin_restart, "r",
-      "restart the current map (optionally using named layout)",
-      "(^5layout^7)"
+      "restart the current map (optionally using named layout or keeping/switching teams)",
+      "(^5layout^7) (^5keepteams|switchteams|keepteamslock|switchteamslock^7)"
     },
 
+    {"revert", G_admin_revert, "v",
+      "revert one or more buildlog events, optionally of only one team",
+      "(^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)"
+      "\n ^3Example:^7 '!revert x5 h' reverts the last 5 events affecting human buildables"
+    },
+
     {"setlevel", G_admin_setlevel, "s",
       "sets the admin level of a player",
       "[^3name|slot#|admin#^7] [^3level^7]"
@@ -158,6 +215,13 @@
     {"spec999", G_admin_spec999, "P",
       "move 999 pingers to the spectator team",
       ""},
+      
+     //kev: a bit of a hack, but there is no real point to
+     //creating a new admin flag for this, so i stole it from !help
+    {"specme", G_admin_putmespec, "h",
+        "moves you to the spectators",
+	""
+    },
 
     {"time", G_admin_time, "C",
       "show the current local server time",
@@ -165,17 +229,28 @@
 
     {"unban", G_admin_unban, "b",
       "unbans a player specified by the slot as seen in showbans",
-      "[^3ban slot#^7]"
+      "[^3ban#^7]"
     },
     
+    {"undesignate", G_admin_designate, "g",
+      "revoke designated builder privileges",
+      "[^3name|slot#^7]"
+    },
+    
     {"unlock", G_admin_unlock, "K",
       "unlock a locked team",
       "[^3a|h^7]"
     },
-
+    
     {"unmute", G_admin_mute, "m",
       "unmute a muted player",
       "[^3name|slot#^7]"
+    },
+
+    {
+     "warn", G_admin_warn, "w",
+      "Warn a player to cease or face admin intervention",
+      "[^3name|slot#^7] [reason]"
     }
   };
 
@@ -231,6 +306,7 @@
           {
           case ADMF_INCOGNITO:
           case ADMF_IMMUTABLE:
+          case ADMF_DBUILDER:
             return qfalse; 
           default:
             return qtrue;
@@ -264,6 +340,7 @@
           {
           case ADMF_INCOGNITO:
           case ADMF_IMMUTABLE:
+          case ADMF_DBUILDER:
             return qfalse; 
           default:
             return qtrue;
@@ -282,12 +359,20 @@
   gclient_t *client;
   char testName[ MAX_NAME_LENGTH ] = {""};
   char name2[ MAX_NAME_LENGTH ] = {""};
+  int alphaCount = 0;
 
   G_SanitiseName( name, name2 );
 
   if( !Q_stricmp( name2, "UnnamedPlayer" ) ) 
     return qtrue;
 
+  if( !Q_stricmp( name2, "console" ) )
+  {
+    Q_strncpyz( err, va( "The name '%s^7' is invalid here", name2 ),
+      len );
+    return qfalse;
+  }
+
   for( i = 0; i < level.maxclients; i++ )
   {
     client = &level.clients[ i ];
@@ -309,6 +394,32 @@
       return qfalse;
     }
   }
+   
+  if( '0' <= name2[ 0 ]  && name2[ 0 ] <= '9' )
+  {
+    Q_strncpyz( err, "Names cannot begin with a number. Please choose another.", len );
+    return qfalse;
+  }
+  
+  for( i = 0; name2[ i ] !='\0'; i++)
+  {
+    if( Q_isalpha( name2[ i ] ) )
+     alphaCount++;
+    if( name2[ i ] == '/' )
+    {
+      if( name2[ i + 1 ] == '/' || name2[ i + 1 ] == '*' )
+      {
+        Q_strncpyz( err, "Names cannot contain '//' or '/*'. Please choose another.", len );
+        return qfalse;
+      }
+    }
+  }
+  
+  if( alphaCount == 0 ) 
+  {
+    Q_strncpyz( err, va( "The name '%s^7' does not include at least one letter. Please choose another.", name ), len );
+    return qfalse;
+  }
 
   if( !g_adminNameProtect.string[ 0 ] )
     return qtrue;
@@ -321,8 +432,8 @@
     if( !Q_stricmp( name2, testName ) &&
       Q_stricmp( ent->client->pers.guid, g_admin_admins[ i ]->guid ) )
     {
-      Q_strncpyz( err, va( "The name '%s^7' belongs to an admin, "
-        "please use another name", name ), len );
+      Q_strncpyz( err, va( "The name '%s^7' belongs to an admin. "
+        "Please choose another.", name ), len );
       return qfalse;
     }
   }
@@ -397,7 +508,6 @@
 {
   fileHandle_t f;
   int len, i, j;
-  qtime_t qt;
   int t;
   char levels[ MAX_STRING_CHARS ] = {""};
 
@@ -407,7 +517,7 @@
       " configuration will not be saved to a file.\n" );
     return;
   }
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
   len = trap_FS_FOpenFile( g_admin.string, &f, FS_WRITE );
   if( len < 0 )
   {
@@ -574,15 +684,15 @@
 
   Q_strncpyz( g_admin_levels[ 2 ]->name, "^6Team Manager",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 2 ]->flags, "iahCpP", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 2 ]->flags, "iahCpPwd", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 3 ]->name, "^2Junior Admin",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 3 ]->flags, "iahCpPkm", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 3 ]->flags, "iahCpPkmwd?$", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 4 ]->name, "^3Senior Admin",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 4 ]->flags, "iahCpPkmBbe", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 4 ]->flags, "iahCpPkmBbewd?$", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 5 ]->name, "^1Server Operator",
     sizeof( l->name ) );
@@ -646,7 +756,7 @@
 {
   fileHandle_t f;
   int len, i, j;
-  char string[ MAX_STRING_CHARS ];
+  char string[ MAX_STRING_CHARS ], decoloured[ MAX_STRING_CHARS ];
   int min, tens, sec;
   g_admin_admin_t *a;
   g_admin_level_t *l;
@@ -737,11 +847,33 @@
                  cmd,
                  G_SayConcatArgs( 1 + skiparg ) );
   }
-  trap_FS_Write( string, strlen( string ), f );
+
+  if( g_decolourLogfiles.integer )
+  {
+    G_DecolorString( string, decoloured );
+    trap_FS_Write( decoloured, strlen( decoloured ), f );
+  }
+  else
+  {
+     trap_FS_Write( string, strlen( string ), f );
+  }
   trap_FS_FCloseFile( f );
+  
+  if ( !Q_stricmp( cmd, "attempted" ) )
+  {
+    Com_sprintf( string, sizeof( string ),
+                 "%s (%i) %s: %s",
+                 ( admin ) ? admin->client->pers.netname : "console",
+                 ( admin ) ? admin->s.clientNum : -1,
+                 cmd,
+                 G_SayConcatArgs( 1 + skiparg ) );
+    G_AdminsPrintf("%s\n",string);
+  }
+  
+    G_LogPrintf("Admin Command: %s^7: %s %s\n",( admin ) ? admin->client->pers.netname : "console", cmd, G_SayConcatArgs( 1 + skiparg ));
 }
 
-static int admin_listadmins( gentity_t *ent, int start, char *search )
+static int admin_listadmins( gentity_t *ent, int start, char *search, int minlevel )
 {
   int drawn = 0;
   char guid_stub[9];
@@ -800,59 +932,60 @@
 
   for( i = start; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]
     && drawn < MAX_ADMIN_LISTITEMS; i++ )
-  {
-    if( search[ 0 ] )
-    {
-      G_SanitiseName( g_admin_admins[ i ]->name, name );
-      if( !strstr( name, search ) )
-        continue;
+   if( g_admin_admins[ i ]->level >= minlevel ) 
+   {
+     if( search[ 0 ] )
+     {
+       G_SanitiseName( g_admin_admins[ i ]->name, name );
+       if( !strstr( name, search ) )
+         continue;
       
-      // verify we don't have the same guid/name pair in connected players
-      // since we don't want to draw the same player twice
-      dup = qfalse;
-      for( j = 0; j < level.maxclients; j++ )
-      {
-        vic = &g_entities[ j ];
-        if( !vic->client || vic->client->pers.connected != CON_CONNECTED )
-          continue;
-        G_SanitiseName( vic->client->pers.netname, name2 );
-        if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
-          && strstr( name2, search ) ) 
-        {
-          dup = qtrue;
-          break;
-        }
-      }
-      if( dup )
-        continue;
-    }
-    for( j = 0; j <= 8; j++ )
-      guid_stub[ j ] = g_admin_admins[ i ]->guid[ j + 24 ];
-    guid_stub[ j ] = '\0';
-   
-    lname[ 0 ] = '\0'; 
-    Q_strncpyz( lname_fmt, "%s", sizeof( lname_fmt ) );
-    for( j = 0; j < MAX_ADMIN_LEVELS && g_admin_levels[ j ]; j++ )
-    {
-      if( g_admin_levels[ j ]->level == g_admin_admins[ i ]->level )
-      {
-        G_DecolorString( g_admin_levels[ j ]->name, lname );
-        Com_sprintf( lname_fmt, sizeof( lname_fmt ), "%%%is",
-          ( admin_level_maxname + strlen( g_admin_levels[ j ]->name )
-            - strlen( lname ) ) );
-        Com_sprintf( lname, sizeof( lname ), lname_fmt,
-           g_admin_levels[ j ]->name );
-        break;
-      }
-    }
-    ADMBP( va( "%4i %4i %s^7 (*%s) %s^7\n",
-      ( i + MAX_CLIENTS ),
-      g_admin_admins[ i ]->level,
-      lname,
-      guid_stub,
-      g_admin_admins[ i ]->name ) );
-    drawn++;
-  }
+       // verify we don't have the same guid/name pair in connected players
+       // since we don't want to draw the same player twice
+       dup = qfalse;
+       for( j = 0; j < level.maxclients; j++ )
+       {
+         vic = &g_entities[ j ];
+         if( !vic->client || vic->client->pers.connected != CON_CONNECTED )
+           continue;
+         G_SanitiseName( vic->client->pers.netname, name2 );
+         if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
+           && strstr( name2, search ) ) 
+         {
+           dup = qtrue;
+           break;
+         }
+       }
+       if( dup )
+         continue;
+     }
+     for( j = 0; j <= 8; j++ )
+       guid_stub[ j ] = g_admin_admins[ i ]->guid[ j + 24 ];
+     guid_stub[ j ] = '\0';
+    
+     lname[ 0 ] = '\0'; 
+     Q_strncpyz( lname_fmt, "%s", sizeof( lname_fmt ) );
+     for( j = 0; j < MAX_ADMIN_LEVELS && g_admin_levels[ j ]; j++ )
+     {
+       if( g_admin_levels[ j ]->level == g_admin_admins[ i ]->level )
+       {
+         G_DecolorString( g_admin_levels[ j ]->name, lname );
+         Com_sprintf( lname_fmt, sizeof( lname_fmt ), "%%%is",
+           ( admin_level_maxname + strlen( g_admin_levels[ j ]->name )
+             - strlen( lname ) ) );
+         Com_sprintf( lname, sizeof( lname ), lname_fmt,
+            g_admin_levels[ j ]->name );
+         break;
+       }
+     }
+     ADMBP( va( "%4i %4i %s^7 (*%s) %s^7\n",
+       ( i + MAX_CLIENTS ),
+       g_admin_admins[ i ]->level,
+       lname,
+       guid_stub,
+       g_admin_admins[ i ]->name ) );
+     drawn++;
+   }
   ADMBP_end();
   return drawn;
 }
@@ -885,11 +1018,10 @@
 {
   char *guid, *ip;
   int i;
-  qtime_t qt;
   int t;
  
   *reason = '\0'; 
-  t  = trap_RealTime( &qt ); 
+  t = trap_RealTime( NULL );
   if( !*userinfo )
     return qfalse;
   ip = Info_ValueForKey( userinfo, "ip" );
@@ -910,12 +1042,24 @@
       Com_sprintf(
         reason,
         rlen,
+        "Banned player %s (%s) tried to connnect (ban #%i by %s^7  expires %s reason: %s^7 )",
+        Info_ValueForKey( userinfo, "name" ),
+	g_admin_bans[ i ]->name,
+        i,
+        g_admin_bans[ i ]->banner,
+        duration,
+        g_admin_bans[ i ]->reason
+      );
+      // G_AdminsPrintf("%s\n",reason);
+      Com_sprintf(
+        reason,
+        rlen,
         "You have been banned by %s^7 reason: %s^7 expires: %s",
         g_admin_bans[ i ]->banner,
         g_admin_bans[ i ]->reason,
         duration
       );
-      G_Printf("Banned player tried to connect from IP %s\n", ip);
+      G_LogPrintf("Banned player tried to connect from IP %s\n", ip);
       return qtrue;
     }
     if( *guid && !Q_stricmp( g_admin_bans[ i ]->guid, guid ) )
@@ -965,6 +1109,14 @@
   {
     return qfalse;
   }
+  
+       // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return qtrue;
+   }
 
   for( i = 0; i < MAX_ADMIN_COMMANDS && g_admin_commands[ i ]; i++ )
   {
@@ -1050,6 +1202,11 @@
       Q_strncpyz( g_admin_namelog[ i ]->name[ j ], client->pers.netname,
         sizeof( g_admin_namelog[ i ]->name[ j ] ) );
       g_admin_namelog[ i ]->slot = ( disconnect ) ? -1 : clientNum;
+ 
+      // if this player is connecting, they are no longer banned
+      if( !disconnect )
+        g_admin_namelog[ i ]->banned = qfalse;
+
       return;
     }
   }
@@ -1367,7 +1524,6 @@
   int matches = 0;
   int id = -1;
 
-
   if( G_SayArgc() < 3 + skiparg )
   {
     ADMP( "^3!setlevel: ^7usage: !setlevel [name|slot#] [level]\n" );
@@ -1488,7 +1644,7 @@
   {
     ADMP( "^3!setlevel:^7 more than one match.  Use the admin number "
       "instead:\n" );
-    admin_listadmins( ent, 0, name );
+    admin_listadmins( ent, 0, name, 0 );
     return qfalse;
   }
 
@@ -1543,6 +1699,39 @@
   return qtrue;
 }
 
+int G_admin_parse_time( const char *time )
+{
+  int seconds = 0, num = 0;
+  int i;
+  for( i = 0; time[ i ]; i++ )
+  {
+    if( isdigit( time[ i ] ) )
+    {
+      num = num * 10 + time[ i ] - '0';
+      continue;
+    }
+    if( i == 0 || !isdigit( time[ i - 1 ] ) )
+      return -1;
+    switch( time[ i ] )
+    {
+      case 'w': num *= 7;
+      case 'd': num *= 24;
+      case 'h': num *= 60;
+      case 'm': num *= 60;
+      case 's': break;
+      default:  return -1;
+    }
+    seconds += num;
+    num = 0;
+  }
+  if( num )
+    seconds += num;
+  // overflow
+  if( seconds < 0 )
+    seconds = 0;
+  return seconds;
+}
+
 static qboolean admin_create_ban( gentity_t *ent,
   char *netname,
   char *guid,
@@ -1554,6 +1743,8 @@
   qtime_t qt;
   int t;
   int i;
+  int j;
+  qboolean foundAdminTrueName=qfalse;
 
   t = trap_RealTime( &qt );
   b = G_Alloc( sizeof( g_admin_ban_t ) );
@@ -1571,8 +1762,19 @@
     qt.tm_hour, qt.tm_min, qt.tm_sec ),
     sizeof( b->made ) );
 
-  if( ent )
-    Q_strncpyz( b->banner, ent->client->pers.netname, sizeof( b->banner ) );
+  if( ent ) {
+    //Get admin true name
+    for(j = 0; j < MAX_ADMIN_ADMINS && g_admin_admins[ j ]; j++ )
+    {
+      if( !Q_stricmp( g_admin_admins[ j ]->guid, ent->client->pers.guid ) )
+      {
+          Q_strncpyz( b->banner, g_admin_admins[ j ]->name, sizeof( b->banner  ) );
+	  foundAdminTrueName=qtrue;
+        break;
+      }
+    }
+    if(foundAdminTrueName==qfalse) Q_strncpyz( b->banner, ent->client->pers.netname, sizeof( b->banner ) );
+  }
   else
     Q_strncpyz( b->banner, "console", sizeof( b->banner ) );
   if( !seconds )
@@ -1595,7 +1797,6 @@
   return qtrue;
 }
 
-
 qboolean G_admin_kick( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
@@ -1627,23 +1828,20 @@
     return qfalse;
   }
   vic = &g_entities[ pids[ 0 ] ];
-  if( g_adminTempBan.integer > 0 )
-  {
-    admin_create_ban( ent,
-      vic->client->pers.netname,
-      vic->client->pers.guid,
-      vic->client->pers.ip, g_adminTempBan.integer,
-      "automatic temp ban created by kick" );
-    if( g_admin.string[ 0 ] )
-      admin_writeconfig();
-  }
+  admin_create_ban( ent,
+    vic->client->pers.netname,
+    vic->client->pers.guid,
+    vic->client->pers.ip, G_admin_parse_time( g_adminTempBan.string ),
+    ( *reason ) ? reason : "kicked by admin" );
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+
+ trap_SendServerCommand( pids[ 0 ],
+  va( "disconnect \"You have been kicked.\n%s^7\nreason:\n%s\"",
+    ( ent ) ? va( "admin:\n%s", ent->client->pers.netname ) : "",
+    ( *reason ) ? reason : "kicked by admin" ) );
   
-  trap_SendServerCommand( pids[ 0 ],
-    va( "disconnect \"You have been kicked.\n%s^7\nreason:\n%s\"",
-      ( ent ) ? va( "admin:\n%s", ent->client->pers.netname ) : "",
-      ( *reason ) ? reason : "kicked by admin" ) );
-
-  trap_DropClient( pids[ 0 ], va( "has been kicked%s^7. reason: %s",
+  trap_DropClient( pids[ 0 ], va( "kicked%s^7, reason: %s",
     ( ent ) ? va( " by %s", ent->client->pers.netname ) : "",
     ( *reason ) ? reason : "kicked by admin" ) );
 
@@ -1658,7 +1856,6 @@
   char *reason;
   int minargc;
   char duration[ 32 ];
-  int modifier = 1;
   int logmatch = -1, logmatches = 0;
   int i, j;
   qboolean exactmatch = qfalse;
@@ -1682,32 +1879,14 @@
   }
   if( G_SayArgc() < minargc )
   {
-    ADMP( "^3!ban: ^7usage: !ban [name|slot|ip] [seconds] [reason]\n" );
+    ADMP( "^3!ban: ^7usage: !ban [name|slot|ip] [time] [reason]\n" );
     return qfalse;
   }
   G_SayArgv( 1 + skiparg, search, sizeof( search ) );
   G_SanitiseName( search, s2 );
   G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
 
-  // support "w" (weeks), "d" (days), "h" (hours), and "m" (minutes) modifiers
-  if( secs[ 0 ] )
-  {
-    int lastchar = strlen( secs ) - 1;
-    if( secs[ lastchar ] == 'w' )
-      modifier = 60 * 60 * 24 * 7;
-    else if( secs[ lastchar ] == 'd' )
-      modifier = 60 * 60 * 24;
-    else if( secs[ lastchar ] == 'h' )
-      modifier = 60 * 60;
-    else if( secs[ lastchar ] == 'm' )
-      modifier = 60;
-    else if( secs[ lastchar ] < '0' || secs[ lastchar ] > '9' )
-      secs[ lastchar ] = '\0';
-  }
-  seconds = atoi( secs );
-  if( seconds > 0 )
-    seconds *= modifier;
-
+  seconds = G_admin_parse_time( secs );
   if( seconds <= 0 )
   {
     if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
@@ -1833,7 +2012,7 @@
   else
     admin_writeconfig();
 
-  if(g_admin_namelog[ logmatch ]->slot == -1 ) 
+  if( g_admin_namelog[ logmatch ]->slot == -1 ) 
   {
     // client is already disconnected so stop here
     AP( va( "print \"^3!ban:^7 %s^7 has been banned by %s^7 "
@@ -1844,47 +2023,105 @@
       ( *reason ) ? reason : "banned by admin" ) );
     return qtrue;
   }
-
+  
   trap_SendServerCommand( g_admin_namelog[ logmatch ]->slot,
     va( "disconnect \"You have been banned.\n"
       "admin:\n%s^7\nduration:\n%s\nreason:\n%s\"",
       ( ent ) ? ent->client->pers.netname : "console",
       duration,
-      ( *reason ) ? reason : "kicked by admin" ) );
+      ( *reason ) ? reason : "banned by admin" ) );
 
   trap_DropClient(  g_admin_namelog[ logmatch ]->slot,
-    va( "has been banned by %s^7 duration: %s, reason: %s",
+    va( "banned by %s^7, duration: %s, reason: %s",
       ( ent ) ? ent->client->pers.netname : "console",
       duration,
       ( *reason ) ? reason : "banned by admin" ) );
   return qtrue;
 }
 
+qboolean G_admin_adjustban( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  int length;
+  int expires;
+  char duration[ 32 ] = {""};
+  char *reason;
+  char bs[ 5 ];
+  char secs[ 7 ];
+
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    ADMP( "^3!adjustban: ^7usage: !adjustban [ban#] [time] [reason]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1] )
+  {
+    ADMP( "^3!adjustban: ^7invalid ban#\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
+  length = G_admin_parse_time( secs );
+  if( length < 0 )
+    reason = G_SayConcatArgs( 2 + skiparg );
+  else
+  {
+    if( length != 0 )
+      expires = trap_RealTime( NULL ) + length;
+    else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+      expires = 0;
+    else
+    {
+      ADMP( "^3!ban: ^7ban time must be positive\n" );
+      return qfalse;
+    }
+
+    g_admin_bans[ bnum - 1 ]->expires = expires;
+    G_admin_duration( ( length ) ? length : -1, duration, sizeof( duration ) );
+    reason = G_SayConcatArgs( 3 + skiparg );
+  }
+  if( *reason )
+    Q_strncpyz( g_admin_bans[ bnum - 1 ]->reason, reason,
+      sizeof( g_admin_bans[ bnum - 1 ]->reason ) );
+  AP( va( "print \"^3!adjustban: ^7ban #%d for %s^7 has been updated by %s^7 "
+    "%s%s%s%s%s\n\"",
+    bnum,
+    g_admin_bans[ bnum - 1 ]->name,
+    ( ent ) ? ent->client->pers.netname : "console",
+    ( length >= 0 ) ? "duration: " : "",
+    duration,
+    ( length >= 0 && *reason ) ? ", " : "",
+    ( *reason ) ? "reason: " : "",
+    reason ) );
+  if( ent )
+    Q_strncpyz( g_admin_bans[ bnum - 1 ]->banner, ent->client->pers.netname,
+      sizeof( g_admin_bans[ bnum - 1 ]->banner ) );
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+  return qtrue;
+}
+
 qboolean G_admin_unban( gentity_t *ent, int skiparg )
 {
   int bnum;
-  char bs[ 4 ];
-  qtime_t qt;
+  char bs[ 5 ];
   int t;
 
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
   if( G_SayArgc() < 2 + skiparg )
   {
-    ADMP( "^3!unban: ^7usage: !unban [ban #]\n" );
+    ADMP( "^3!unban: ^7usage: !unban [ban#]\n" );
     return qfalse;
   }
   G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
   bnum = atoi( bs );
-  if( bnum < 1 )
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1 ] )
   {
-    ADMP( "^3!unban: ^7invalid ban #\n" );
+    ADMP( "^3!unban: ^7invalid ban#\n" );
     return qfalse;
   }
-  if( !g_admin_bans[ bnum - 1 ] )
-  {
-    ADMP( "^3!unban: ^7invalid ban #\n" );
-    return qfalse;
-  }
   g_admin_bans[ bnum -1 ]->expires = t;
   AP( va( "print \"^3!unban: ^7ban #%d for %s^7 has been removed by %s\n\"",
           bnum,
@@ -1988,12 +2225,73 @@
 
   trap_SendConsoleCommand( EXEC_APPEND, va( "map %s", map ) );
   level.restarted = qtrue;
-  AP( va( "print \"^3!map: ^7map '%s' started by %s %s\n\"", map,
+  AP( va( "print \"^3!map: ^7map '%s' started by %s^7 %s\n\"", map,
           ( ent ) ? ent->client->pers.netname : "console",
           ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
   return qtrue;
 }
 
+qboolean G_admin_devmap( gentity_t *ent, int skiparg )
+{
+  char map[ MAX_QPATH ];
+  char layout[ MAX_QPATH ] = { "" };
+
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!devmap: ^7usage: !devmap [map] (layout)\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( skiparg + 1, map, sizeof( map ) );
+
+  if( !trap_FS_FOpenFile( va( "maps/%s.bsp", map ), NULL, FS_READ ) )
+  {
+    ADMP( va( "^3!devmap: ^7invalid map name '%s'\n", map ) );
+    return qfalse;
+  }
+
+  if( G_SayArgc( ) > 2 + skiparg )
+  {
+    G_SayArgv( skiparg + 2, layout, sizeof( layout ) );
+    if( !Q_stricmp( layout, "*BUILTIN*" ) ||
+      trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
+        NULL, FS_READ ) > 0 )
+    {
+      trap_Cvar_Set( "g_layouts", layout );
+    }
+    else
+    {
+      ADMP( va( "^3!devmap: ^7invalid layout name '%s'\n", layout ) );
+      return qfalse;
+    }
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "devmap %s", map ) );
+  level.restarted = qtrue;
+  AP( va( "print \"^3!devmap: ^7map '%s' started by %s^7 with cheats %s\n\"", map,
+          ( ent ) ? ent->client->pers.netname : "console",
+          ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+  return qtrue;
+}
+
+qboolean G_admin_layoutsave( gentity_t *ent, int skiparg )
+{
+  char layout[ MAX_QPATH ];
+
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!layoutsave: ^7usage: !layoutsave [layout]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( skiparg + 1, layout, sizeof( layout ) );
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "layoutsave %s", layout ) );
+  AP( va( "print \"^3!layoutsave: ^7layout saved as '%s' by %s\n\"", layout,
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
 qboolean G_admin_mute( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
@@ -2107,6 +2405,10 @@
     }
     vic->client->pers.denyBuild = qtrue;
     vic->client->ps.stats[ STAT_BUILDABLE ] = BA_NONE;
+    if( vic->client->ps.stats[ STAT_PCLASS ]== PCL_ALIEN_BUILDER0 || vic->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG )
+    {
+      vic->suicideTime = level.time + 1000;
+    }
     CPx( pids[ 0 ], "cp \"^1You've lost your building rights\"" );
     AP( va(
       "print \"^3!denybuild: ^7building rights for ^7%s^7 revoked by ^7%s\n\"",
@@ -2120,29 +2422,43 @@
 qboolean G_admin_listadmins( gentity_t *ent, int skiparg )
 {
   int i, found = 0;
-  qtime_t qt;
-  int t;
   char search[ MAX_NAME_LENGTH ] = {""};
   char s[ MAX_NAME_LENGTH ] = {""};
   int start = 0;
   qboolean numeric = qtrue;
   int drawn = 0;
+  int minlevel = 1;
 
-  t = trap_RealTime( &qt );
+  if( G_SayArgc() == 3 + skiparg )
+  {
+    G_SayArgv( 2 + skiparg, s, sizeof( s ) );
+    if( s[ 0 ] >= '0' && s[ 0] <= '9' )
+    {
+      minlevel = atoi( s );
+      if( minlevel < 1 ) 
+       minlevel = 1;
+    }
+  }
 
   for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
   {
-    if( g_admin_admins[ i ]->level == 0 )
-      continue;
-    found++;
+    if( g_admin_admins[ i ]->level >= minlevel )
+      found++;
   }
   if( !found )
   {
-    ADMP( "^3!listadmins: ^7no admins defined\n" );
+    if( minlevel > 1 )
+    {
+      ADMP( va( "^3!listadmins: ^7no admins level %i or greater found\n", minlevel ) );
+    }
+    else
+    {
+       ADMP( "^3!listadmins: ^7no admins defined\n" );
+    }
     return qfalse;
   }
 
-  if( G_SayArgc() == 2 + skiparg )
+  if( G_SayArgc() >= 2 + skiparg )
   {
     G_SayArgv( 1 + skiparg, s, sizeof( s ) );
     for( i = 0; i < sizeof( s ) && s[ i ]; i++ )
@@ -2166,31 +2482,42 @@
   if( start >= found || start < 0 )
     start = 0;
 
-  if( start >= found )
-  {
-    ADMP( va( "^3!listadmins: ^7listing %d admins\n", found ) );
-    return qfalse;
-  }
+  drawn = admin_listadmins( ent, start, search, minlevel );
 
-  drawn = admin_listadmins( ent, start, search );
-
   if( search[ 0 ] )
   {
-    ADMP( va( "^3!listadmins:^7 found %d admins matching '%s^7'\n",
-      drawn, search ) );
+    if( drawn <= 20 )
+    {
+      ADMP( va( "^3!listadmins:^7 found %d admins level %i or greater matching '%s^7'\n",
+        drawn, minlevel, search ) );
+    }
+    else
+    {
+      ADMP( va( "^3!listadmins:^7 found >20 admins level %i or greater matching '%s^7. Try a more narrow search.'\n",
+        minlevel, search ) );
+    }
   }
   else
   {
     ADMBP_begin();
-    ADMBP( va( "^3!listadmins:^7 showing admin %d - %d of %d.  ",
+    ADMBP( va( "^3!listadmins:^7 showing admins level %i or greater %d - %d of %d.  ",
+      minlevel,
       ( found ) ? ( start + 1 ) : 0,
       ( ( start + MAX_ADMIN_LISTITEMS ) > found ) ?
        found : ( start + MAX_ADMIN_LISTITEMS ),
       found ) );
     if( ( start + MAX_ADMIN_LISTITEMS ) < found )
     {
-      ADMBP( va( "run '!listadmins %d' to see more",
-        ( start + MAX_ADMIN_LISTITEMS + 1 ) ) );
+      if( minlevel > 1)
+      {
+        ADMBP( va( "run '!listadmins %d %d' to see more",
+          ( start + MAX_ADMIN_LISTITEMS + 1 ), minlevel ) );
+      }
+      else
+      {
+        ADMBP( va( "run '!listadmins %d' to see more",
+          ( start + MAX_ADMIN_LISTITEMS + 1 ) ) );
+      }
     }
     ADMBP( "\n" );
     ADMBP_end();
@@ -2248,7 +2575,7 @@
   char lname[ MAX_NAME_LENGTH ];
   char lname2[ MAX_NAME_LENGTH ];
   char guid_stub[ 9 ];
-  char muted[ 2 ], denied[ 2 ];
+  char muted[ 2 ], denied[ 2 ], dbuilder[ 2 ];
   int l;
   char lname_fmt[ 5 ];
 
@@ -2296,6 +2623,21 @@
       Q_strncpyz( denied, "B", sizeof( denied ) );
     }
 
+    dbuilder[ 0 ] = '\0';
+    if( p->pers.designatedBuilder )
+    {
+      if( !G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) &&
+          G_admin_permission( &g_entities[ i ], ADMF_DBUILDER ) && 
+          G_admin_permission(ent, ADMF_SEESFULLLISTPLAYERS ) )
+      {
+        Q_strncpyz( dbuilder, "P", sizeof( dbuilder ) );
+      }
+      else
+      {
+        Q_strncpyz( dbuilder, "D", sizeof( dbuilder ) );
+      }
+    }
+
     l = 0;
     G_SanitiseName( p->pers.netname, n2 );
     n[ 0 ] = '\0';
@@ -2305,7 +2647,7 @@
       {
 
         // don't gather aka or level info if the admin is incognito
-        if( G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) )
+        if( ent && G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) )
         {
           break;
         }
@@ -2337,20 +2679,37 @@
 
     }
 
-    ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s^7 %s^7 %s%s^7%s\n",
-             i,
-             c,
-             t,
-             l,
-             ( *lname ) ? lname2 : "", 
-             guid_stub,
-             muted,
-             denied,
-             p->pers.netname,
-             ( *n ) ? "(a.k.a. " : "",
-             n,
-             ( *n ) ? ")" : ""
-           ) );
+     
+     if( G_admin_permission(ent, ADMF_SEESFULLLISTPLAYERS ) ) {
+ 
+      ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s%1s^7 %s^7 %s%s^7%s\n",
+               i,
+               c,
+               t,
+               l,
+               ( *lname ) ? lname2 : "", 
+               guid_stub,
+               muted,
+	       dbuilder,
+               denied,
+               p->pers.netname,
+               ( *n ) ? "(a.k.a. " : "",
+               n,
+               ( *n ) ? ")" : ""
+             ) );
+     }
+     else
+     {
+      ADMBP( va( "%2i %s%s^7 ^1%1s%1s%1s^7 %s^7\n",
+               i,
+               c,
+               t,
+               muted,
+               dbuilder,
+               denied,
+               p->pers.netname
+             ) );
+     }
   }
   ADMBP_end();
   return qtrue;
@@ -2359,7 +2718,6 @@
 qboolean G_admin_showbans( gentity_t *ent, int skiparg )
 {
   int i, found = 0;
-  qtime_t qt;
   int t;
   char duration[ 32 ];
   char name_fmt[ 32 ] = { "%s" };
@@ -2374,7 +2732,7 @@
   char n1[ MAX_NAME_LENGTH ] = {""};
   char n2[ MAX_NAME_LENGTH ] = {""};
 
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
 
   for( i = 0; i < MAX_ADMIN_BANS && g_admin_bans[ i ]; i++ )
   {
@@ -2499,7 +2857,7 @@
       // show 6 commands per line
       if( j == 6 )
       {
-	ADMBP( "\n" );
+  ADMBP( "\n" );
         j = 0;
       }
     }
@@ -2513,12 +2871,12 @@
       // show 6 commands per line
       if( j == 6 )
       {
-	ADMBP( "\n" );
+  ADMBP( "\n" );
         j = 0;
       }
     }
     if( count )
-	ADMBP( "\n" );
+  ADMBP( "\n" );
     ADMBP( va( "^3!help: ^7%i available commands\n", count ) );
     ADMBP( "run !help [^3command^7] for help with a specific command.\n" );
     ADMBP_end();
@@ -2693,6 +3051,24 @@
   return qtrue;
 }
 
+qboolean G_admin_pause( gentity_t *ent, int skiparg )
+{
+	if(!level.paused) 
+	{
+		AP( va( "print \"^3!pause: ^7%s^7 paused the game.\n\"", ( ent ) ? ent->client->pers.netname : "console" ) );
+		level.paused = qtrue;
+		trap_SendServerCommand( -1, "cp \"The game has been paused. Please wait.\"" );
+	}
+	else {
+		AP( va( "print \"^3!pause: ^7%s^7 unpaused the game (Paused for %d msec) \n\"", ( ent ) ? ent->client->pers.netname : "console",level.pausedTime ) );
+		trap_SendServerCommand( -1, "cp \"The game has been unpaused!\"" );
+		level.paused = qfalse;
+		
+		
+		}
+	return qtrue;
+}
+
 qboolean G_admin_spec999( gentity_t *ent, int skiparg )
 {
   int i;
@@ -2718,6 +3094,30 @@
   return qtrue;
 }
 
+qboolean G_admin_register(gentity_t *ent, int skiparg ){
+  int level = 0;
+
+  if( !ent ) return qtrue;
+	
+  level = G_admin_level(ent);
+	
+  if( level == 0 )
+   level = 1;
+  
+  if( !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+  {
+    ADMP( va( "^3!register: ^7 You cannot register for name protection until you update your client. Please replace your client executable with the one at http://trem.tjw.org/backport/ and reconnect. Updating your client will also allow you to have faster map downloads.\n" ) );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND,va( "!setlevel %d %d;",ent - g_entities, level) );
+  ClientUserinfoChanged( ent - g_entities );
+  
+  AP( va( "print \"^3!register: ^7%s^7 is now a protected nickname.\n\"", ent->client->pers.netname) );
+  
+  return qtrue;
+}
+
 qboolean G_admin_rename( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
@@ -2763,16 +3163,20 @@
   Info_SetValueForKey( userinfo, "name", newname );
   trap_SetUserinfo( pids[ 0 ], userinfo );
   ClientUserinfoChanged( pids[ 0 ] );
-  AP( va( "print \"^3!rename: ^7%s^7 has been renamed to %s^7 by %s\n\"",
-          oldname,
-          newname,
-          ( ent ) ? ent->client->pers.netname : "console" ) );
+  if( strcmp( oldname, level.clients[ pids[ 0 ] ].pers.netname ) )
+    AP( va( "print \"^3!rename: ^7%s^7 has been renamed to %s^7 by %s\n\"",
+	    oldname,
+	    level.clients[ pids[ 0 ] ].pers.netname,
+	    ( ent ) ? ent->client->pers.netname : "console" ) );
   return qtrue;
 }
 
 qboolean G_admin_restart( gentity_t *ent, int skiparg )
 {
   char layout[ MAX_CVAR_VALUE_STRING ] = { "" };
+  char teampref[ MAX_CVAR_VALUE_STRING ] = { "" };
+  int i;
+  gclient_t *cl;
 
   if( G_SayArgc( ) > 1 + skiparg )
   {
@@ -2781,23 +3185,79 @@
     trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
     G_SayArgv( skiparg + 1, layout, sizeof( layout ) );
 
-    if( !Q_stricmp( layout, "*BUILTIN*" ) ||
-      trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
-        NULL, FS_READ ) > 0 )
+    if( Q_stricmp( layout, "keepteams" ) && Q_stricmp( layout, "keepteamslock" ) && Q_stricmp( layout, "switchteams" ) && Q_stricmp( layout, "switchteamslock" ) )
     {
-      trap_Cvar_Set( "g_layouts", layout );
+      if( !Q_stricmp( layout, "*BUILTIN*" ) ||
+        trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
+          NULL, FS_READ ) > 0 )
+      {
+        trap_Cvar_Set( "g_layouts", layout );
+      }
+      else
+      {
+        ADMP( va( "^3!restart: ^7layout '%s' does not exist\n", layout ) );
+        return qfalse;
+      }
     }
-    else
+    else 
     {
-      ADMP( va( "^3!restart: ^7layout '%s' does not exist\n", layout ) );
-      return qfalse;
+      strcpy(layout,"");
+      G_SayArgv( skiparg + 1, teampref, sizeof( teampref ) );    
     }
   }
+  
+  if( G_SayArgc( ) > 2 + skiparg ) 
+  {
+    G_SayArgv( skiparg + 2, teampref, sizeof( teampref ) );      
+  }
+  
+  
+  if( !Q_stricmp( teampref, "keepteams" ) || !Q_stricmp( teampref, "keepteamslock" ) )
+  {
+    for( i = 0; i < g_maxclients.integer; i++ )
+    {
+      cl = level.clients + i;
+      if( cl->pers.connected != CON_CONNECTED )
+        continue;
 
+      if( cl->pers.teamSelection == PTE_NONE )
+        continue;
+
+      cl->sess.restartTeam = cl->pers.teamSelection;
+    }
+  } 
+  else if(!Q_stricmp( teampref, "switchteams" ) ||  !Q_stricmp( teampref, "switchteamslock" ))
+  {
+    for( i = 0; i < g_maxclients.integer; i++ )
+    {
+      cl = level.clients + i;
+      if( cl->pers.connected != CON_CONNECTED )
+        continue;
+
+      if( cl->pers.teamSelection == PTE_NONE )
+        continue;
+
+      if( cl->pers.teamSelection == PTE_ALIENS )
+        cl->sess.restartTeam = PTE_HUMANS;
+      else if(cl->pers.teamSelection == PTE_HUMANS )
+	cl->sess.restartTeam = PTE_ALIENS;
+    }  	  
+  }
+  
+  if( !Q_stricmp( teampref, "switchteamslock" ) || !Q_stricmp( teampref, "keepteamslock" ) )
+  {
+    trap_Cvar_Set( "g_lockTeamsAtStart", "1" );
+  }
+
   trap_SendConsoleCommand( EXEC_APPEND, "map_restart" );
-  AP( va( "print \"^3!restart: ^7map restarted by %s %s\n\"",
+  
+  if(teampref[ 0 ])
+    strcpy(teampref,va( "^7(with teams option: '%s^7')", teampref ));
+  
+  AP( va( "print \"^3!restart: ^7map restarted by %s %s %s\n\"",
           ( ent ) ? ent->client->pers.netname : "console",
-          ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+          ( layout[ 0 ] ) ? va( "^7(forcing layout '%s^7')", layout ) : "",
+          teampref ) );
   return qtrue;
 }
 
@@ -2962,6 +3422,696 @@
   return qtrue;
 } 
 
+qboolean G_admin_designate( gentity_t *ent, int skiparg )
+{
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!designate: ^7usage: designate [name|slot#]\n" );
+    return qfalse;
+  }
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  if( G_ClientNumbersFromString( name, pids ) != 1 )
+  {
+    G_MatchOnePlayer( pids, err, sizeof( err ) );
+    ADMP( va( "^3!designate: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) &&
+    !Q_stricmp( cmd, "undesignate" ) )
+  {
+    ADMP( "^3!mute: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n" );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( vic->client->pers.designatedBuilder == qtrue )
+  {
+    if( !Q_stricmp( cmd, "designate" ) )
+    {
+      ADMP( "^3!designate: ^7player is already designated builder\n" );
+      return qtrue;
+    }
+    vic->client->pers.designatedBuilder = qfalse;
+    CPx( pids[ 0 ], "cp \"^1Your designation has been revoked\"" );
+    AP( va(
+      "print \"^3!designate: ^7%s^7's designation has been revoked by %s\n\"",
+       vic->client->pers.netname,
+       ( ent ) ? ent->client->pers.netname : "console" ) );
+    G_CheckDBProtection( );
+  }
+  else
+  {
+    if( !Q_stricmp( cmd, "undesignate" ) )
+    {
+      ADMP( "^3!undesignate: ^7player is not currently designated builder\n" );
+      return qtrue;
+    }
+    vic->client->pers.designatedBuilder = qtrue;
+    CPx( pids[ 0 ], "cp \"^1You've been designated\"" );
+    AP( va( "print \"^3!designate: ^7%s^7 has been designated by ^7%s\n\"",
+      vic->client->pers.netname,
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
+ //!Warn by Gate (Daniel Evans) 
+ qboolean G_admin_warn( gentity_t *ent, int skiparg )
+ {//mostly copy and paste with the proper lines altered from !mute and !kick
+ 
+ 
+   int pids[ MAX_CLIENTS ];
+   char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
+   int minargc;
+   gentity_t *vic;
+ 
+   minargc = 3 + skiparg;
+   if( G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
+     minargc = 2 + skiparg;
+ 
+   if( G_SayArgc() < minargc )
+   {
+     ADMP( "^3!warn: ^7usage: warn [name] [reason]\n" );
+     return qfalse;
+   }
+   G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+   reason = G_SayConcatArgs( 2 + skiparg );
+   if( G_ClientNumbersFromString( name, pids ) != 1 )
+   {
+     G_MatchOnePlayer( pids, err, sizeof( err ) );
+     ADMP( va( "^3!warn: ^7%s\n", err ) );
+     return qfalse;
+   }
+   if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+   {
+     ADMP( "^3!warn: ^7sorry, but your intended victim has a higher admin"
+         " level than you.\n" );
+     return qfalse;
+   }
+  
+   vic = &g_entities[ pids[ 0 ] ];
+   //next line is the onscreen warning
+   CPx( pids[ 0 ],va("cp \"^1You have been warned by an administrator.\n ^3Cease immediately or face admin action!\n^1 %s%s\"",(*reason)? "REASON: " : "" ,(*reason)? reason : "") );
+   AP( va( "print \"^3!warn: ^7%s^7 has been warned to cease and desist: %s by %s \n\"",
+             vic->client->pers.netname, (*reason) ? reason : "his current activity",
+             ( ent ) ? ent->client->pers.netname : "console" ) );//console announcement
+   ClientUserinfoChanged( pids[ 0 ] );
+   return qtrue;
+ }
+ 
+
+qboolean G_admin_putmespec( gentity_t *ent, int skiparg )
+{
+  if( !ent )
+  {
+	ADMP( "!specme: sorry, but console isn't allowed on the spectators team\n");
+	return qfalse;
+  }
+  
+  if(ent->client->pers.teamSelection == PTE_NONE)
+    return qfalse;
+  
+    //guard against build timer exploit
+  if( ent->client->pers.teamSelection != PTE_NONE &&
+     ( ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0 ||
+       ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG ||
+       BG_InventoryContainsWeapon( WP_HBUILD, ent->client->ps.stats ) ||
+       BG_InventoryContainsWeapon( WP_HBUILD2, ent->client->ps.stats ) ) &&
+      ent->client->ps.stats[ STAT_MISC ] > 0 )
+  {
+    ADMP("!specme: You cannot leave your team until the build timer expires");
+    return qfalse;
+  }
+  
+  G_ChangeTeam( ent, PTE_NONE );
+  AP( va("print \"^3!specme: ^7%s^7 decided to join the spectators\n\"", ent->client->pers.netname ) );
+  return qtrue;
+}
+
+qboolean G_admin_buildlog( gentity_t *ent, int skiparg )
+{
+#define LOG_DISPLAY_LENGTH 10
+  buildHistory_t *ptr;
+  gentity_t *builder = NULL;
+  int skip = 0, start = 0, lastID = -1, firstID = -1, i, len, matchlen = 0;
+  pTeam_t team = PTE_NONE;
+  char startbuf[ 12 ], message[ MAX_STRING_CHARS ], *teamchar; 
+  char *name, *action, *buildablename, markstring[ MAX_STRING_CHARS ]; 
+  if( !g_buildLogMaxLength.integer )
+  {
+    ADMP( "^3!buildlog: ^7build logging is disabled" );
+    return qfalse;
+  }
+  if( G_SayArgc( ) >= 2 + skiparg )
+  {
+    for( i = 1; i + skiparg < G_SayArgc( ); i++ )
+    {
+      char argbuf[ 64 ], err[ MAX_STRING_CHARS ];
+      int x = 0, pids[ MAX_CLIENTS ];
+      G_SayArgv( i + skiparg, argbuf, sizeof argbuf );
+      switch( argbuf[ 0 ])
+      {
+        case 'x':
+          x = 1;
+        default:
+          skip = atoi( argbuf + x );
+          start = 0;
+          break;
+        case '#':
+          start = atoi( argbuf + 1 );
+          skip = 0;
+          break;
+        case '-':
+          if(G_ClientNumbersFromString(argbuf + 1, pids) != 1)
+          {
+           G_MatchOnePlayer(pids, err, sizeof(err));
+           ADMP(va("^3!revert: ^7%s\n", err));
+           return qfalse;
+          }
+          builder = g_entities + *pids;
+          break;
+        case 'A':
+        case 'a':
+          team = PTE_ALIENS;
+          break;
+        case 'H':
+        case 'h':
+          team = PTE_HUMANS;
+          break;
+      }
+    }
+  }
+  // !buildlog can be abused, so let everyone know when it is used
+  AP( va( "print \"^3!buildlog: ^7%s^7 requested a log of recent building"
+      " activity\n\"", ( ent ) ? ent->client->pers.netname : "console" ) );
+  len = G_CountBuildLog( ); // also clips the log if too long
+  if( !len )
+  {
+    ADMP( "^3!buildlog: ^7no build log found\n" );
+    return qfalse;
+  }
+  if( start )
+  {
+    // set skip based on start
+    for( ptr = level.buildHistory; ptr && ptr->ID != start; 
+        ptr = ptr->next, skip++ );
+    if( !ptr )
+    {
+      ADMP( "^3!buildlog: ^7log ID not found\n" );
+      skip = 0;
+    }
+  }
+  // ensure skip is a useful value
+  if( skip > len - LOG_DISPLAY_LENGTH )
+    skip = len - LOG_DISPLAY_LENGTH;
+  *message = '\0';
+  // skip to start entry
+  for( ptr = level.buildHistory, i = len; ptr && i > len - skip; 
+      ptr = ptr->next )
+  {
+    // these checks could perhaps be done more efficiently but they are cheap
+    // in processor time so I'm not worrying
+    if( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+      continue;
+    if( builder && builder != ptr->ent )
+      continue;
+    matchlen++;
+    i--;
+  }
+  for( ; i + LOG_DISPLAY_LENGTH > len - skip && i > 0; i--, ptr = ptr->next )
+  {
+    if( !ptr ) 
+      break; // run out of log
+    *markstring = '\0'; // reinit markstring
+    // check team
+    if( ( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+        || ( builder && builder != ptr->ent ) )
+    {
+      skip++; // loop an extra time because we skipped one
+      continue; 
+    }
+    if( lastID < 0 )
+      lastID = ptr->ID;
+    firstID = ptr->ID;
+    matchlen++;
+    // set name to the ent's current name or last recorded name
+    if( ptr->ent )
+    {
+      if( ptr->ent->client )
+        name = ptr->ent->client->pers.netname;
+      else
+        name = "<world>"; // any non-client action
+    }
+    else
+      name = ptr->name;
+    switch( ptr->fate )
+    {
+      case BF_BUILT:
+        action = "^2built^7 a";
+        break;
+      case BF_DECONNED:
+        action = "^3DECONSTRUCTED^7 a";
+        break;
+      case BF_DESTROYED:
+        action = "destroyed a";
+        break;
+      case BF_TEAMKILLED:
+        action = "^1TEAMKILLED^7 a";
+        break;
+      default:
+        action = "\0"; // erm
+        break;
+    }
+    // handle buildables removed by markdecon
+    if( ptr->marked )
+    {
+      buildHistory_t *mark;
+      int j, markdecon[ BA_NUM_BUILDABLES ], and = 2;
+      char bnames[ 32 ], *article;
+      mark = ptr;
+      // count the number of buildables
+      memset( markdecon, 0, sizeof( markdecon ) );
+      while( ( mark = mark->marked ) )
+        markdecon[ mark->buildable ]++;
+      // reverse order makes grammar easier
+      for( j = BA_NUM_BUILDABLES; j >= 0; j-- )
+      {
+        buildablename = BG_FindHumanNameForBuildable( j );
+        // plural is easy
+        if( markdecon[ j ] > 1 )
+          Com_sprintf( bnames, 32, "%d %ss", markdecon[ j ], buildablename );
+        // use an appropriate article
+        else if( markdecon[ j ] == 1 )
+        {
+          if( BG_FindUniqueTestForBuildable( j ) )
+            article = "the"; // if only one
+          else if( strchr( "aeiouAEIOU", *buildablename ) )
+            article = "an"; // if first char is vowel
+          else
+            article = "a";
+          Com_sprintf( bnames, 32, "%s %s", article, buildablename );
+        }
+        else
+          continue; // none of this buildable
+        // C grammar: x, y, and z
+        // the integer and is 2 initially, the test means it is used on the
+        // second sprintf only, the reverse order makes this second to last
+        // the comma is only printed if there is already some markstring i.e.
+        // not the first time ( which would put it on the end of the string )
+        Com_sprintf( markstring, sizeof( markstring ), "%s%s %s%s", bnames, 
+            ( *markstring ) ? "," : "", ( and-- == 1 ) ? "and " : "", markstring );
+      }
+    }
+    buildablename = BG_FindHumanNameForBuildable( ptr->buildable );
+    switch( BG_FindTeamForBuildable( ptr->buildable ) )
+    {
+      case PTE_ALIENS: 
+        teamchar = "^1A"; 
+        break;
+      case PTE_HUMANS: 
+        teamchar = "^4H"; 
+        break;
+      default: 
+        teamchar = " "; // space so it lines up neatly
+        break;
+    }
+    // prepend the information to the string as we go back in buildhistory
+    // so the earliest events are at the top
+    Com_sprintf( message, MAX_STRING_CHARS, "%3d %s^7 %s^7 %s%s %s%s%s\n%s", 
+        ptr->ID, teamchar, name, action, 
+        ( strchr( "aeiouAEIOU", buildablename[ 0 ] ) ) ? "n" : "", 
+        buildablename, ( markstring[ 0 ] ) ? ", removing " : "", 
+        markstring, message );
+  }
+  for( ; ptr; ptr = ptr->next )
+  {
+    if( builder && builder != ptr->ent )
+      continue;
+    if( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+      continue;
+    matchlen++;
+  }
+  if( matchlen )
+    ADMP( va( "%s^3!buildlog: showing log entries %d - %d of %d\n", message,
+        firstID, lastID, matchlen ) );
+  else
+    ADMP( "^3!buildlog: ^7no log entries match those criteria\n" );
+  return qtrue;
+}
+
+qboolean G_admin_revert( gentity_t *ent, int skiparg )
+{
+  int i = 0, j = 0, repeat = 1, ID = 0, len, matchlen=0;
+  pTeam_t team = PTE_NONE;
+  qboolean force = qfalse, reached = qfalse;
+  gentity_t *builder = NULL, *targ;
+  buildHistory_t *ptr, *tmp, *mark, *prev;
+  vec3_t dist;
+  char argbuf[ 64 ], *name, *bname, *action, *article;
+  len = G_CountBuildLog( );
+  if( !len )
+  {
+    ADMP( "^3!revert: ^7no build log found\n" );
+    return qfalse;
+  }
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!revert: ^7usage: !revert (^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)\n" );
+    return qfalse;
+  }
+  for( i = 1; i + skiparg < G_SayArgc( ); i++ )
+  {
+    char arg[ 64 ], err[ MAX_STRING_CHARS ];
+    int pids[ MAX_CLIENTS ];
+    G_SayArgv( i + skiparg, arg, sizeof arg );
+    switch( arg[ 0 ])
+    {
+      case 'x':
+        repeat = atoi( arg + 1 );
+        break;
+      case '#':
+        ID = atoi( arg + 1 );
+        break;
+      case '-':
+        if(G_ClientNumbersFromString(arg + 1, pids) != 1)
+        {
+          G_MatchOnePlayer(pids, err, sizeof err);
+          ADMP(va("^3!revert: ^7%s\n", err));
+          return qfalse;
+        }
+        builder = g_entities + *pids;
+        break;
+      case 'A':
+      case 'a':
+        team = PTE_ALIENS;
+        break;
+      case 'H':
+      case 'h':
+        team = PTE_HUMANS;
+        break;
+      case '!':
+        force = qtrue;
+        break;
+      default:
+        ADMP( "^3!revert: ^7usage: !revert (^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)\n" );
+        return qfalse;
+    }
+  }
+  if( repeat > 25 )
+  {
+    ADMP( "^3!revert: ^7to avoid flooding, can only revert 25 builds at a time\n" );
+    repeat = 25;
+  }
+  for( i = 0, ptr = prev = level.buildHistory; repeat > 0; repeat--, j = 0 )
+  {
+    if( !ptr ) 
+      break; // run out of bhist
+    if( !reached && ID )
+    {
+      if( ptr->ID == ID )
+        reached = qtrue;
+      else
+      {
+        prev = ptr;
+        ptr = ptr->next;
+        repeat++;
+        continue;
+      }
+    }
+    if( ( team != PTE_NONE && 
+        team != BG_FindTeamForBuildable( ptr->buildable ) ) || 
+        ( builder && builder != ptr->ent ))
+    {
+      // team doesn't match, so skip this ptr and reset prev
+      prev = ptr;
+      ptr = ptr->next;
+      // we don't want to count this one so counteract the decrement by the for
+      repeat++;
+      continue;
+    }
+    // get the ent's current or last recorded name
+    if( ptr->ent )
+    {
+      if( ptr->ent->client )
+        name = ptr->ent->client->pers.netname;
+      else
+        name = "<world>"; // non-client actions
+    }
+    else
+      name = ptr->name;
+    bname = BG_FindHumanNameForBuildable( ptr->buildable ); 
+    action = "";
+    switch( ptr->fate )
+    {
+      case BF_BUILT:
+        action = "^2build^7";
+        for( j = MAX_CLIENTS, targ = g_entities + j;
+            j < level.num_entities; j++, targ++ )
+        {
+          // easy checks first to save time
+          if( targ->s.eType != ET_BUILDABLE )
+            continue;
+          if( targ->s.modelindex != ptr->buildable )
+            continue; 
+          VectorSubtract( targ->s.pos.trBase, ptr->origin, dist );
+#define FIND_BUILDABLE_TOLERANCE 5
+          if( VectorLength( dist ) > FIND_BUILDABLE_TOLERANCE )
+            continue; // number is somewhat arbitrary, watch for false pos/neg
+          // if we didn't continue then it's this one, unlink it but we can't
+          // free it yet, because the markdecon buildables might not place
+          trap_UnlinkEntity( targ );
+          break;
+        }
+        // if there are marked buildables to replace, and we aren't overriding 
+        // space check, check they can fit before acting
+        if( ptr->marked && !force )
+        {
+          for( mark = ptr->marked; mark; mark = mark->marked )
+            if( !G_RevertCanFit( mark ) )
+            {
+              trap_LinkEntity( targ ); // put it back, we failed
+              // scariest sprintf ever:
+              Com_sprintf( argbuf, sizeof argbuf, "%s%s%s%s%s%s%s!",
+                  ( repeat > 1 ) ? "x" : "", ( repeat > 1 ) ? va( "%d ", repeat ) : "",
+                  ( ID ) ? "#" : "", ( ID ) ? va( "%d ", ptr->ID ) : "",
+                  ( builder ) ? "-" : "", ( builder ) ? va( "%d ", builder - g_entities ) : "", 
+                  ( team == PTE_ALIENS ) ? "a " : ( team == PTE_HUMANS ) ? "h " : "" );
+              ADMP( va( "^3!revert: ^7revert aborted: reverting this %s would conflict with "
+                  "another buildable, use ^3!revert %s ^7to override\n", action, argbuf ) );
+              return qfalse;
+            }
+         }
+          // if we haven't returned yet then we're good to go, free it
+          G_FreeEntity( targ );
+          // put the marked buildables back and mark them again
+          if( ptr->marked ) // there may be a more efficient way of doing this
+          {
+            for( mark = ptr->marked; mark; mark = mark->marked )
+              G_SpawnRevertedBuildable( mark, qtrue ); 
+          }
+        break;
+      case BF_DECONNED:
+        if( !action[ 0 ] ) action = "^3deconstruction^7";
+      case BF_TEAMKILLED:
+	if( !action[ 0 ] ) action ="^1TEAMKILL^7";
+      case BF_DESTROYED:
+        if( !action[ 0 ] ) action = "destruction";
+        // if we're not overriding and the replacement can't fit, as before
+        if( !force && !G_RevertCanFit( ptr ) )
+        {
+          Com_sprintf( argbuf, sizeof argbuf, "%s%s%s%s%s%s%s!",
+              ( repeat > 1 ) ? "x" : "", ( repeat > 1 ) ? va( "%d ", repeat ) : "",
+              ( ID ) ? "#" : "", ( ID ) ? va( "%d ", ptr->ID ) : "",
+              ( builder ) ? "-" : "", ( builder ) ? va( "%d ", builder - g_entities ) : "", 
+              ( team == PTE_ALIENS ) ? "a " : ( team == PTE_HUMANS ) ? "h " : "" );
+          ADMP( va( "^3!revert: ^7revert aborted: reverting this %s would "
+              "conflict with another buildable, use ^3!revert %s ^7to override\n",
+              action, argbuf ) );
+          return qfalse;
+        }
+        // else replace it but don't mark it ( it might have been marked before
+        // but it isn't that important )
+        G_SpawnRevertedBuildable( ptr, qfalse );
+        break;
+      default:
+        // if this happens something has gone wrong
+        ADMP( "^3!revert: ^7incomplete or corrupted build log entry\n" );
+        /* quarantine and dispose of the log, it's dangerous
+        trap_Cvar_Set( "g_buildLogMaxLength", "0" );
+        G_CountBuildLog( );
+        */
+        return qfalse;
+      }
+      if( j == level.num_entities )
+      {
+        ADMP( va( "^3!revert: ^7could not find logged buildable #%d\n", ptr->ID ));
+        prev = ptr;
+        ptr = ptr->next;
+        continue;
+      }
+      // this is similar to the buildlog stuff
+      if( BG_FindUniqueTestForBuildable( ptr->buildable ) )
+        article = "the";
+      else if( strchr( "aeiouAEIOU", *bname ) )
+        article = "an";
+      else
+        article = "a";
+      AP( va( "print \"%s^7 reverted %s^7'%s %s of %s %s\n\"", 
+          ( ent ) ? ent->client->pers.netname : "console",
+          name, strchr( "Ss", name[ strlen( name ) - 1 ] ) ? "" : "s",
+          action, article, bname ) ); 
+      matchlen++;
+      // remove the reverted entry
+      // ptr moves on, prev just readjusts ->next unless it is about to be 
+      // freed, in which case it is forced to move on too
+      tmp = ptr;
+      if( ptr == level.buildHistory )
+        prev = level.buildHistory = ptr = ptr->next;
+      else
+        prev->next = ptr = ptr->next;
+      G_Free( tmp );
+  }
+  if( ID && !reached )
+  {
+    ADMP( "^3!revert: ^7no buildlog entry with that ID\n" );
+    return qfalse;
+  }
+  
+  if( !matchlen )
+  {
+     ADMP( "^3!revert: ^7no log entries match those criteria\n" );
+     return qfalse;
+  }
+  else
+  {
+    ADMP( va( "^3!revert: ^7reverted %d buildlog events\n", matchlen ) );  
+  }
+  
+  return qtrue;
+}
+
+void G_Unescape( char *input, char *output, int len );
+qboolean G_StringReplaceCvars( char *input, char *output, int len );
+
+qboolean G_admin_info( gentity_t *ent, int skiparg )
+{
+  fileHandle_t infoFile;
+  char filename[ MAX_OSPATH ], message[ MAX_STRING_CHARS ]; 
+  if( G_SayArgc() == 2 + skiparg )
+    G_SayArgv( 1 + skiparg, filename, sizeof( filename ) );
+  else if( G_SayArgc() == 1 + skiparg )
+    Q_strncpyz( filename, "default", sizeof( filename ) );
+  else
+  {
+    ADMP( "^3!info: ^7usage: ^3!info ^7(^5subject^7)\n" );
+    return qfalse;
+  }
+  Com_sprintf( filename, sizeof( filename ), "info/info-%s.txt", filename );
+  if( !trap_FS_FOpenFile( filename, &infoFile, FS_READ ) || !infoFile )
+  {
+    ADMP( "^3!info: ^7no relevant info is available\n" );
+    return qfalse;
+  }
+  else
+  {
+    int i;
+    // trap_FS_Read doesn't seem to null-terminate properly
+    memset( message, 0, sizeof( message ) );
+    trap_FS_Read( message, sizeof( message ), infoFile );
+    trap_FS_FCloseFile( infoFile );
+#define MAX_INFO_PARSE_LOOPS 100
+    for( i = 0; i < MAX_INFO_PARSE_LOOPS && 
+        G_StringReplaceCvars( message, message, sizeof( message ) ); i++ )
+    G_Unescape( message, message, sizeof( message ) );
+    if( i == MAX_INFO_PARSE_LOOPS )
+      G_Printf( S_COLOR_YELLOW "WARNING: %s exceeds MAX_INFO_PARSE_LOOPS\n", 
+          filename );
+    if( message[ strlen( message ) - 1 ] != '\n' )
+      ADMP( va( "%s\n", message ) );
+    else
+      ADMP( message );
+    return qtrue;
+  }
+}
+
+void G_Unescape( char *input, char *output, int len )
+{
+  // \n -> newline, \%c -> %c
+  // output is terminated at output[len - 1]
+  int i, j;
+  for( i = j = 0; input[i] && j + 1 < len; i++, j++ )
+  {
+    if( input[i] == '\\' )
+    {
+      if( !input[++i] )
+        break;
+      else if( input[i] == 'n' )
+        output[j] = '\n';
+      else
+        output[j] = input[i];
+    }
+    else
+      output[j] = input[i];
+  }
+  output[j] = '\0';
+}
+
+qboolean G_StringReplaceCvars( char *input, char *output, int len )
+{
+  int i, outNum = 0;
+  char cvarName[ 64 ], cvarValue[ MAX_CVAR_VALUE_STRING ];
+  char *outputBuffer;
+  qboolean doneAnything = qfalse;
+  // use our own internal buffer in case output == input
+  outputBuffer = G_Alloc( len );
+  len -= 1; // fit in a terminator
+  while( *input && outNum < len )
+  {
+    if( *input == '\\' && input[1] )
+    {
+      outputBuffer[ outNum++ ] = *input++;
+      outputBuffer[ outNum++ ] = *input++;
+    }
+    else if( *input == '$' && input[1] )
+    {
+      input++;
+      if( *input == '{' ) 
+        input++;
+      for( i = 0; *input && ( isalnum( *input ) || *input == '_' ) && 
+          i < 63; i++ )
+        cvarName[ i ] = *input++;
+      cvarName[ i ] = '\0';
+      if( *input == '}' ) 
+        input++;
+      trap_Cvar_VariableStringBuffer( cvarName, cvarValue, sizeof( cvarValue ) );
+      if( cvarValue[ 0 ] )
+      {
+        doneAnything = qtrue;
+        for( i = 0; cvarValue[ i ] && outNum < len; i++ )
+          outputBuffer[ outNum++ ] = cvarValue[ i ];
+      }
+    }
+    else
+    {
+      outputBuffer[ outNum++ ] = *input++;
+    }
+  }
+  outputBuffer[ outNum ] = '\0';
+  Q_strncpyz( output, outputBuffer, len );
+  G_Free( outputBuffer );
+  return doneAnything;
+}
+
 /*
 ================
  G_admin_print
@@ -3030,3 +4180,38 @@
     g_admin_commands[ i ] = NULL;
   }
 }
+
+qboolean G_admin_L1(gentity_t *ent, int skiparg ){
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
+  int minargc;
+  gentity_t *vic;
+
+  minargc = 2 + skiparg;
+
+  if( G_SayArgc() < minargc )
+  {
+    ADMP( "^3!L1: ^7usage: !L1 [name]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  reason = G_SayConcatArgs( 2 + skiparg );
+  if( G_ClientNumbersFromString( name, pids ) != 1 )
+  {
+    G_MatchOnePlayer( pids, err, sizeof( err ) );
+    ADMP( va( "^3!L1: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( G_admin_level(&g_entities[ pids[ 0 ] ] )>0 )
+  {
+    ADMP( "^3!L1: ^7sorry, but that person is already higher than"
+        " level 0.\n" );
+    return qfalse;
+  }
+ 
+  vic = &g_entities[ pids[ 0 ] ];
+  //AP(va( "!setlevel %s 1\n",vic->client->pers.netname));
+  trap_SendConsoleCommand( EXEC_APPEND,va( "!setlevel %d 1;", pids[ 0 ] ) );
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
Index: src/game/g_weapon.c
===================================================================
--- src/game/g_weapon.c	(revision 966)
+++ src/game/g_weapon.c	(working copy)
@@ -727,6 +727,8 @@
       bHealth = BG_FindHealthForBuildable( traceEnt->s.modelindex );
 
       traceEnt->health += HBUILD_HEALRATE;
+      ent->client->pers.statscounters.repairspoisons++;
+      level.humanStatsCounters.repairspoisons++;
 
       if( traceEnt->health > bHealth )
         traceEnt->health = bHealth;
@@ -1358,7 +1360,6 @@
   G_Damage( traceEnt, ent, ent, forward, tr.endpos, damage,
       DAMAGE_NO_KNOCKBACK|DAMAGE_NO_LOCDAMAGE, MOD_LEVEL3_POUNCE );
 
-  ent->client->ps.weaponTime += LEVEL3_POUNCE_TIME;
   ent->client->allowedToPounce = qfalse;
 
   return qtrue;
Index: src/game/g_misc.c
===================================================================
--- src/game/g_misc.c	(revision 966)
+++ src/game/g_misc.c	(working copy)
@@ -89,7 +89,7 @@
   G_UnlaggedClear( player );
 
   // set angles
-  SetClientViewAngle( player, angles );
+  G_SetClientViewAngle( player, angles );
 
   // kill anything at the destination
   if( player->client->sess.sessionTeam != TEAM_SPECTATOR )
Index: src/game/g_admin.h
===================================================================
--- src/game/g_admin.h	(revision 966)
+++ src/game/g_admin.h	(working copy)
@@ -55,6 +55,9 @@
  * 0 - inactivity rules do not apply to them
  * ! - admin commands cannot be used on them
  * @ - does not show up as an admin in !listplayers
+ * $ - sees all information in !listplayers 
+ * # - permanent designated builder
+ * ? - sees and can use adminchat
  */
 #define ADMF_IMMUNITY '1'
 #define ADMF_NOCENSORFLOOD '2' /* TODO */
@@ -69,6 +72,9 @@
 
 #define ADMF_IMMUTABLE '!'
 #define ADMF_INCOGNITO '@'
+#define ADMF_SEESFULLLISTPLAYERS '$'
+#define ADMF_DBUILDER '#'
+#define ADMF_ADMINCHAT '?'
 
 #define MAX_ADMIN_LISTITEMS 20
 #define MAX_ADMIN_SHOWBANS 10
@@ -145,6 +151,7 @@
 qboolean G_admin_time( gentity_t *ent, int skiparg );
 qboolean G_admin_setlevel( gentity_t *ent, int skiparg );
 qboolean G_admin_kick( gentity_t *ent, int skiparg );
+qboolean G_admin_adjustban( gentity_t *ent, int skiparg );
 qboolean G_admin_ban( gentity_t *ent, int skiparg );
 qboolean G_admin_unban( gentity_t *ent, int skiparg );
 qboolean G_admin_putteam( gentity_t *ent, int skiparg );
@@ -152,6 +159,8 @@
 qboolean G_admin_listlayouts( gentity_t *ent, int skiparg );
 qboolean G_admin_listplayers( gentity_t *ent, int skiparg );
 qboolean G_admin_map( gentity_t *ent, int skiparg );
+qboolean G_admin_devmap( gentity_t *ent, int skiparg );
+qboolean G_admin_layoutsave( gentity_t *ent, int skiparg );
 qboolean G_admin_mute( gentity_t *ent, int skiparg );
 qboolean G_admin_denybuild( gentity_t *ent, int skiparg );
 qboolean G_admin_showbans( gentity_t *ent, int skiparg );
@@ -161,12 +170,21 @@
 qboolean G_admin_cancelvote( gentity_t *ent, int skiparg );
 qboolean G_admin_passvote( gentity_t *ent, int skiparg );
 qboolean G_admin_spec999( gentity_t *ent, int skiparg );
+qboolean G_admin_register( gentity_t *ent, int skiparg );
 qboolean G_admin_rename( gentity_t *ent, int skiparg );
 qboolean G_admin_restart( gentity_t *ent, int skiparg );
 qboolean G_admin_nextmap( gentity_t *ent, int skiparg );
 qboolean G_admin_namelog( gentity_t *ent, int skiparg );
 qboolean G_admin_lock( gentity_t *ent, int skiparg );
 qboolean G_admin_unlock( gentity_t *ent, int skiparg );
+qboolean G_admin_info( gentity_t *ent, int skiparg );
+qboolean G_admin_buildlog( gentity_t *ent, int skiparg );
+qboolean G_admin_revert( gentity_t *ent, int skiparg );
+qboolean G_admin_pause( gentity_t *ent, int skiparg );
+qboolean G_admin_L1( gentity_t *ent, int skiparg );
+qboolean G_admin_putmespec( gentity_t *ent, int skiparg );
+qboolean G_admin_warn( gentity_t *ent, int skiparg );
+qboolean G_admin_designate( gentity_t *ent, int skiparg );
 
 void G_admin_print( gentity_t *ent, char *m );
 void G_admin_buffer_print( gentity_t *ent, char *m );
Index: src/game/g_missile.c
===================================================================
--- src/game/g_missile.c	(revision 966)
+++ src/game/g_missile.c	(working copy)
@@ -588,10 +588,10 @@
   trap_Trace( &tr, self->r.currentOrigin, self->r.mins, self->r.maxs,
               self->target_ent->r.currentOrigin, self->r.ownerNum, self->clipmask );
 
-  //if there is no LOS or the parent hive is too far away or the target is dead, return
+  //if there is no LOS or the parent hive is too far away or the target is dead or notargeting, return
   if( tr.entityNum == ENTITYNUM_WORLD ||
       Distance( self->r.currentOrigin, self->parent->r.currentOrigin ) > ( HIVE_RANGE * 5 ) ||
-      self->target_ent->health <= 0 )
+      self->target_ent->health <= 0 || self->target_ent->flags & FL_NOTARGET )
   {
     self->r.ownerNum = ENTITYNUM_WORLD;
 
Index: src/game/bg_lib.h
===================================================================
--- src/game/bg_lib.h	(revision 966)
+++ src/game/bg_lib.h	(working copy)
@@ -55,6 +55,22 @@
 #define LONG_MAX      2147483647L   /* maximum (signed) long value */
 #define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */
 
+#define isalnum(c)  (isalpha(c) || isdigit(c))
+#define isalpha(c)  (isupper(c) || islower(c))
+#define isascii(c)  ((c) > 0 && (c) <= 0x7f)
+#define iscntrl(c)  (((c) >= 0) && (((c) <= 0x1f) || ((c) == 0x7f)))
+#define isdigit(c)  ((c) >= '0' && (c) <= '9')
+#define isgraph(c)  ((c) != ' ' && isprint(c))
+#define islower(c)  ((c) >=  'a' && (c) <= 'z')
+#define isprint(c)  ((c) >= ' ' && (c) <= '~')
+#define ispunct(c)  (((c) > ' ' && (c) <= '~') && !isalnum(c))
+#define isspace(c)  ((c) ==  ' ' || (c) == '\f' || (c) == '\n' || (c) == '\r' || \
+                     (c) == '\t' || (c) == '\v')
+#define isupper(c)  ((c) >=  'A' && (c) <= 'Z')
+#define isxdigit(c) (isxupper(c) || isxlower(c))
+#define isxlower(c) (isdigit(c) || (c >= 'a' && c <= 'f'))
+#define isxupper(c) (isdigit(c) || (c >= 'A' && c <= 'F')) 
+
 // Misc functions
 typedef int cmp_t( const void *, const void * );
 void        qsort( void *a, size_t n, size_t es, cmp_t *cmp );
Index: src/game/g_client.c
===================================================================
--- src/game/g_client.c	(revision 966)
+++ src/game/g_client.c	(working copy)
@@ -92,45 +92,49 @@
   //if we're already at the max and trying to add credit then stop
   if( cap )
   {
-    if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    if( client->pers.teamSelection == PTE_ALIENS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] >= ALIEN_MAX_KILLS &&
+      if( client->pers.credit >= ALIEN_MAX_KILLS &&
           credit > 0 )
         return;
     }
-    else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    else if( client->pers.teamSelection == PTE_HUMANS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] >= HUMAN_MAX_CREDITS &&
+      if( client->pers.credit >= HUMAN_MAX_CREDITS &&
           credit > 0 )
         return;
     }
   }
 
-  client->ps.persistant[ PERS_CREDIT ] += credit;
+  client->pers.credit += credit;
 
   if( cap )
   {
-    if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    if( client->pers.teamSelection == PTE_ALIENS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] > ALIEN_MAX_KILLS )
-        client->ps.persistant[ PERS_CREDIT ] = ALIEN_MAX_KILLS;
+      if( client->pers.credit > ALIEN_MAX_KILLS )
+        client->pers.credit = ALIEN_MAX_KILLS;
     }
-    else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    else if( client->pers.teamSelection == PTE_HUMANS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] > HUMAN_MAX_CREDITS )
-        client->ps.persistant[ PERS_CREDIT ] = HUMAN_MAX_CREDITS;
+      if( client->pers.credit > HUMAN_MAX_CREDITS )
+        client->pers.credit = HUMAN_MAX_CREDITS;
     }
   }
 
-  if( client->ps.persistant[ PERS_CREDIT ] < 0 )
-    client->ps.persistant[ PERS_CREDIT ] = 0;
+  if( client->pers.credit < 0 )
+    client->pers.credit = 0;
+
+  // keep PERS_CREDIT in sync if not following 
+  if( client->sess.spectatorState != SPECTATOR_FOLLOW )
+    client->ps.persistant[ PERS_CREDIT ] = client->pers.credit;
 }
 
 
 /*
 =======================================================================
 
-  SelectSpawnPoint
+  G_SelectSpawnPoint
 
 =======================================================================
 */
@@ -165,13 +169,13 @@
 
 /*
 ================
-SelectNearestDeathmatchSpawnPoint
+G_SelectNearestDeathmatchSpawnPoint
 
 Find the spot that we DON'T want to use
 ================
 */
 #define MAX_SPAWN_POINTS  128
-gentity_t *SelectNearestDeathmatchSpawnPoint( vec3_t from )
+gentity_t *G_SelectNearestDeathmatchSpawnPoint( vec3_t from )
 {
   gentity_t *spot;
   vec3_t    delta;
@@ -200,13 +204,13 @@
 
 /*
 ================
-SelectRandomDeathmatchSpawnPoint
+G_SelectRandomDeathmatchSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
 #define MAX_SPAWN_POINTS  128
-gentity_t *SelectRandomDeathmatchSpawnPoint( void )
+gentity_t *G_SelectRandomDeathmatchSpawnPoint( void )
 {
   gentity_t *spot;
   int       count;
@@ -235,12 +239,12 @@
 
 /*
 ===========
-SelectRandomFurthestSpawnPoint
+G_SelectRandomFurthestSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectRandomFurthestSpawnPoint ( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectRandomFurthestSpawnPoint ( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
   vec3_t    delta;
@@ -318,12 +322,12 @@
 
 /*
 ================
-SelectAlienSpawnPoint
+G_SelectAlienSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
-gentity_t *SelectAlienSpawnPoint( vec3_t preference )
+gentity_t *G_SelectAlienSpawnPoint( vec3_t preference )
 {
   gentity_t *spot;
   int       count;
@@ -367,12 +371,12 @@
 
 /*
 ================
-SelectHumanSpawnPoint
+G_SelectHumanSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
-gentity_t *SelectHumanSpawnPoint( vec3_t preference )
+gentity_t *G_SelectHumanSpawnPoint( vec3_t preference )
 {
   gentity_t *spot;
   int       count;
@@ -416,32 +420,32 @@
 
 /*
 ===========
-SelectSpawnPoint
+G_SelectSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
 {
-  return SelectRandomFurthestSpawnPoint( avoidPoint, origin, angles );
+  return G_SelectRandomFurthestSpawnPoint( avoidPoint, origin, angles );
 }
 
 
 /*
 ===========
-SelectTremulousSpawnPoint
+G_SelectTremulousSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles )
 {
   gentity_t *spot = NULL;
 
   if( team == PTE_ALIENS )
-    spot = SelectAlienSpawnPoint( preference );
+    spot = G_SelectAlienSpawnPoint( preference );
   else if( team == PTE_HUMANS )
-    spot = SelectHumanSpawnPoint( preference );
+    spot = G_SelectHumanSpawnPoint( preference );
 
   //no available spots
   if( !spot )
@@ -462,13 +466,13 @@
 
 /*
 ===========
-SelectInitialSpawnPoint
+G_SelectInitialSpawnPoint
 
 Try to find a spawn point marked 'initial', otherwise
 use normal spawn selection.
 ============
 */
-gentity_t *SelectInitialSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectInitialSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -481,7 +485,7 @@
 
   if( !spot || SpotWouldTelefrag( spot ) )
   {
-    return SelectSpawnPoint( vec3_origin, origin, angles );
+    return G_SelectSpawnPoint( vec3_origin, origin, angles );
   }
 
   VectorCopy( spot->s.origin, origin );
@@ -493,11 +497,11 @@
 
 /*
 ===========
-SelectSpectatorSpawnPoint
+G_SelectSpectatorSpawnPoint
 
 ============
 */
-gentity_t *SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles )
 {
   FindIntermissionPoint( );
 
@@ -510,13 +514,13 @@
 
 /*
 ===========
-SelectAlienLockSpawnPoint
+G_SelectAlienLockSpawnPoint
 
 Try to find a spawn point for alien intermission otherwise
 use normal intermission spawn.
 ============
 */
-gentity_t *SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -524,7 +528,7 @@
   spot = G_Find( spot, FOFS( classname ), "info_alien_intermission" );
 
   if( !spot )
-    return SelectSpectatorSpawnPoint( origin, angles );
+    return G_SelectSpectatorSpawnPoint( origin, angles );
 
   VectorCopy( spot->s.origin, origin );
   VectorCopy( spot->s.angles, angles );
@@ -535,13 +539,13 @@
 
 /*
 ===========
-SelectHumanLockSpawnPoint
+G_SelectHumanLockSpawnPoint
 
 Try to find a spawn point for human intermission otherwise
 use normal intermission spawn.
 ============
 */
-gentity_t *SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -549,7 +553,7 @@
   spot = G_Find( spot, FOFS( classname ), "info_human_intermission" );
 
   if( !spot )
-    return SelectSpectatorSpawnPoint( origin, angles );
+    return G_SelectSpectatorSpawnPoint( origin, angles );
 
   VectorCopy( spot->s.origin, origin );
   VectorCopy( spot->s.angles, angles );
@@ -731,11 +735,11 @@
 
 /*
 ==================
-SetClientViewAngle
+G_SetClientViewAngle
 
 ==================
 */
-void SetClientViewAngle( gentity_t *ent, vec3_t angle )
+void G_SetClientViewAngle( gentity_t *ent, vec3_t angle )
 {
   int     i;
 
@@ -876,6 +880,37 @@
 
 
 /*
+===================
+G_NextNewbieName
+
+Generate a unique, known-good name for an UnnamedPlayer
+===================
+*/
+char *G_NextNewbieName( gentity_t *ent )
+{
+  char newname[ MAX_NAME_LENGTH ];
+  char namePrefix[ MAX_NAME_LENGTH - 4 ];
+  char err[ MAX_STRING_CHARS ];
+
+  if( g_newbieNamePrefix.string[ 0 ] )
+    Q_strncpyz( namePrefix, g_newbieNamePrefix.string , sizeof( namePrefix ) );
+  else
+    strcpy( namePrefix, "Newbie#" );
+
+  while( level.numNewbies < 10000 )
+  {
+    strcpy( newname, va( "%s%i", namePrefix, level.numNewbies ) );
+    if ( G_admin_name_check( ent, newname, err, sizeof( err ) ) )
+    {
+      return va( "%s", newname );
+    }
+    level.numNewbies++; // Only increments if the last requested name was used.
+  }
+  return "UnnamedPlayer";
+}
+
+
+/*
 ======================
 G_NonSegModel
 
@@ -953,6 +988,7 @@
   char      newname[ MAX_NAME_LENGTH ];
   char      err[ MAX_STRING_CHARS ];
   qboolean  revertName = qfalse;
+  qboolean  showRenameMsg = qtrue;
   gclient_t *client;
   char      c1[ MAX_INFO_STRING ];
   char      c2[ MAX_INFO_STRING ];
@@ -989,11 +1025,28 @@
 
   if( strcmp( oldname, newname ) )
   {
+    if( !strlen( oldname ) && client->pers.connected != CON_CONNECTED )
+      showRenameMsg = qfalse;
+
     // in case we need to revert and there's no oldname
-    if( client->pers.connected != CON_CONNECTED )
-        Q_strncpyz( oldname, "UnnamedPlayer", sizeof( oldname ) );
+    ClientCleanName( va( "%s", client->pers.netname ), oldname, sizeof( oldname ) );
+ 
+    if( g_newbieNumbering.integer )
+    {
+      if( !strcmp( newname, "UnnamedPlayer" ) )
+	Q_strncpyz( newname, G_NextNewbieName( ent ), sizeof( newname ) );
+      if( !strcmp( oldname, "UnnamedPlayer" ) )
+	Q_strncpyz( oldname, G_NextNewbieName( ent ), sizeof( oldname ) );
+    }
 
-    if( client->pers.nameChangeTime &&
+
+    if( client->pers.muted )
+    {
+      trap_SendServerCommand( ent - g_entities,
+        "print \"You cannot change your name while you are muted\n\"" );
+      revertName = qtrue;
+    }
+    else if( client->pers.nameChangeTime &&
       ( level.time - client->pers.nameChangeTime )
       <= ( g_minNameChangePeriod.value * 1000 ) )
     {
@@ -1027,6 +1080,8 @@
     {
       Q_strncpyz( client->pers.netname, newname,
         sizeof( client->pers.netname ) );
+      Info_SetValueForKey( userinfo, "name", newname );
+      trap_SetUserinfo( clientNum, userinfo );
       if( client->pers.connected == CON_CONNECTED )
       {
         client->pers.nameChangeTime = level.time;
@@ -1041,14 +1096,34 @@
       Q_strncpyz( client->pers.netname, "scoreboard", sizeof( client->pers.netname ) );
   }
 
-  if( client->pers.connected == CON_CONNECTED )
+  if( client->pers.connected >= CON_CONNECTING && showRenameMsg )
   {
     if( strcmp( oldname, client->pers.netname ) )
     {
       trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE
-        " renamed to %s\n\"", oldname, client->pers.netname ) );
-      G_LogPrintf( "ClientRename: %i [%s] (%s) \"%s\" -> \"%s\"\n", clientNum,
+        " renamed to %s^7\n\"", oldname, client->pers.netname ) );
+      if( g_decolourLogfiles.integer)
+      {
+        char    decoloured[ MAX_STRING_CHARS ] = "";   
+        if( g_decolourLogfiles.integer == 1 )
+	{
+	  Com_sprintf( decoloured, sizeof(decoloured), " (\"%s^7\" -> \"%s^7\")", oldname, client->pers.netname );
+	  G_DecolorString( decoloured, decoloured );
+          G_LogPrintfColoured( "ClientRename: %i [%s] (%s) \"%s^7\" -> \"%s^7\"%s\n", clientNum,
+             client->pers.ip, client->pers.guid, oldname, client->pers.netname, decoloured );
+	}
+	else
+	{
+          G_LogPrintf( "ClientRename: %i [%s] (%s) \"%s^7\" -> \"%s^7\"%s\n", clientNum,
+             client->pers.ip, client->pers.guid, oldname, client->pers.netname, decoloured );
+	}
+
+      }
+      else
+      {
+      G_LogPrintf( "ClientRename: %i [%s] (%s) \"%s^7\" -> \"%s^7\"\n", clientNum,
          client->pers.ip, client->pers.guid, oldname, client->pers.netname );
+      }
       G_admin_namelog_update( client, qfalse );
     }
   }
@@ -1065,7 +1140,7 @@
     client->pers.maxHealth = 0;
 
   // set model
-  if( client->ps.stats[ STAT_PCLASS ] == PCL_HUMAN_BSUIT )
+  if( client->ps.stats[ STAT_PCLASS ] == PCL_HUMAN && BG_InventoryContainsUpgrade( UP_BATTLESUIT, client->ps.stats ) )
   {
     Com_sprintf( buffer, MAX_QPATH, "%s/%s",  BG_FindModelNameForClass( PCL_HUMAN_BSUIT ),
                                               BG_FindSkinNameForClass( PCL_HUMAN_BSUIT ) );
@@ -1132,10 +1207,7 @@
   strcpy( c1, Info_ValueForKey( userinfo, "color1" ) );
   strcpy( c2, Info_ValueForKey( userinfo, "color2" ) );
 
-  if( client->ps.pm_flags & PMF_FOLLOW )
-    team = PTE_NONE;
-  else
-    team = client->ps.stats[ STAT_PTEAM ];
+  team = client->pers.teamSelection;
 
   // send over a subset of the userinfo keys so other clients can
   // print scoreboards, display models, and play custom sounds
@@ -1250,10 +1322,35 @@
 
   G_ReadSessionData( client );
 
+  if( firstTime )
+    client->pers.firstConnect = qtrue;
+  else
+    client->pers.firstConnect = qfalse;
+
   // get and distribute relevent paramters
   ClientUserinfoChanged( clientNum );
-  G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s\"\n", clientNum,
-   client->pers.ip, client->pers.guid, client->pers.netname );
+  
+  if( g_decolourLogfiles.integer )
+  {
+   char    decoloured[ MAX_STRING_CHARS ] = "";   
+   if( g_decolourLogfiles.integer == 1 )
+   {
+     Com_sprintf( decoloured, sizeof(decoloured), " (\"%s^7\")", client->pers.netname );
+     G_DecolorString( decoloured, decoloured );
+     G_LogPrintfColoured( "ClientConnect: %i [%s] (%s) \"%s^7\"%s\n", clientNum,
+        client->pers.ip, client->pers.guid, client->pers.netname, decoloured );
+   }
+   else
+   {
+      G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s^7\"%s\n", clientNum,
+          client->pers.ip, client->pers.guid, client->pers.netname, decoloured );
+   }
+  }
+  else
+  {
+  G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s^7\"\n", clientNum,
+    client->pers.ip, client->pers.guid, client->pers.netname );
+  }
 
   // don't do the "xxx connected" messages if they were caried over from previous level
   if( firstTime )
@@ -1262,6 +1359,15 @@
   // count current clients and rank for scoreboard
   CalculateRanks( );
   G_admin_namelog_update( client, qfalse );
+  
+
+  // if this is after !restart keepteams or !restart switchteams, apply said selection
+  if ( client->sess.restartTeam != PTE_NONE ) {
+    G_ChangeTeam( ent, client->sess.restartTeam );
+    client->sess.restartTeam = PTE_NONE;
+  }
+
+  
   return NULL;
 }
 
@@ -1295,6 +1401,7 @@
   client->pers.connected = CON_CONNECTED;
   client->pers.enterTime = level.time;
   client->pers.teamState.state = TEAM_BEGIN;
+  client->pers.classSelection = PCL_NONE;
 
   // save eflags around this, because changing teams will
   // cause this to happen with a valid entity, and we
@@ -1320,6 +1427,16 @@
 
   G_LogPrintf( "ClientBegin: %i\n", clientNum );
 
+    if( g_clientUpgradeNotice.integer )
+    {
+       if( !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+       {
+         trap_SendServerCommand( client->ps.clientNum, va( "print \"^1Your client is out of date. Updating your client will allow you to "
+	      "become an admin on servers and download maps much more quickly. Please replace your client executable with the one "
+	      "at ^2http://trem.tjw.org/backport/^1 and reconnect. \n\"" ) );
+       }
+    }
+
   // count current clients and rank for scoreboard
   CalculateRanks( );
 }
@@ -1369,6 +1486,13 @@
     client->sess.sessionTeam = TEAM_SPECTATOR;
     client->sess.spectatorState = SPECTATOR_LOCKED;
   }
+  
+  //if client is dead and following teammate, stop following before spawning
+  if(ent->client->sess.spectatorClient!=-1)
+  {
+    ent->client->sess.spectatorClient = -1;
+    ent->client->sess.spectatorState = SPECTATOR_FREE;
+  }
 
   if( origin != NULL )
     VectorCopy( origin, spawn_origin );
@@ -1382,11 +1506,11 @@
   if( client->sess.sessionTeam == TEAM_SPECTATOR )
   {
     if( teamLocal == PTE_NONE )
-      spawnPoint = SelectSpectatorSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectSpectatorSpawnPoint( spawn_origin, spawn_angles );
     else if( teamLocal == PTE_ALIENS )
-      spawnPoint = SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
     else if( teamLocal == PTE_HUMANS )
-      spawnPoint = SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
   }
   else
   {
@@ -1442,6 +1566,10 @@
   client->ps.persistant[ PERS_SPAWN_COUNT ]++;
   client->ps.persistant[ PERS_TEAM ] = client->sess.sessionTeam;
 
+  // restore really persistant things
+  client->ps.persistant[ PERS_SCORE ] = client->pers.score;
+  client->ps.persistant[ PERS_CREDIT ] = client->pers.credit;
+
   client->airOutTime = level.time + 12000;
 
   trap_GetUserinfo( index, userinfo, sizeof( userinfo ) );
@@ -1564,7 +1692,7 @@
   client->ps.pm_flags |= PMF_RESPAWNED;
 
   trap_GetUsercmd( client - level.clients, &ent->client->pers.cmd );
-  SetClientViewAngle( ent, spawn_angles );
+  G_SetClientViewAngle( ent, spawn_angles );
 
   if( !( client->sess.sessionTeam == TEAM_SPECTATOR ) )
   {
@@ -1654,12 +1782,23 @@
   gentity_t *ent;
   gentity_t *tent;
   int       i;
+  buildHistory_t *ptr;
 
   ent = g_entities + clientNum;
 
   if( !ent->client )
     return;
 
+  // look through the bhist and readjust it if the referenced ent has left
+  for( ptr = level.buildHistory; ptr; ptr = ptr->next )
+  {
+    if( ptr->ent == ent )
+    {
+      ptr->ent = NULL;
+      Q_strncpyz( ptr->name, ent->client->pers.netname, MAX_NETNAME );
+    }
+  }
+
   G_admin_namelog_update( ent->client, qtrue );
   G_LeaveTeam( ent );
 
Index: src/game/bg_public.h
===================================================================
--- src/game/bg_public.h	(revision 966)
+++ src/game/bg_public.h	(working copy)
@@ -257,7 +257,7 @@
 {
   PERS_SCORE,           // !!! MUST NOT CHANGE, SERVER AND GAME BOTH REFERENCE !!!
   PERS_HITS,            // total points damage inflicted so damage beeps can sound on change
-  PERS_RANK,
+  PERS_UNUSED,          // used to be PERS_RANK, no longer used
   PERS_TEAM,
   PERS_SPAWN_COUNT,     // incremented every respawn
   PERS_ATTACKER,        // clientnum of last damage inflicter
@@ -295,6 +295,7 @@
 #define EF_TEAMVOTED        0x00010000    // already cast a vote
 #define EF_BLOBLOCKED       0x00020000    // TA: caught by a trapper
 #define EF_REAL_LIGHT       0x00040000    // TA: light sprites according to ambient light
+#define EF_DBUILDER         0x00080000    // designated builder protection
 
 typedef enum
 {
@@ -454,13 +455,13 @@
   BIT_NUM_TEAMS
 } buildableTeam_t;
 
-#define B_HEALTH_BITS       12
+#define B_HEALTH_BITS       5
 #define B_HEALTH_MASK       ((1<<B_HEALTH_BITS)-1)
 
-#define B_MARKED_TOGGLEBIT  0x00001000
-#define B_SPAWNED_TOGGLEBIT 0x00002000
-#define B_POWERED_TOGGLEBIT 0x00004000
-#define B_DCCED_TOGGLEBIT   0x00008000
+#define B_DCCED_TOGGLEBIT    0x00000000
+#define B_SPAWNED_TOGGLEBIT  0x00000020
+#define B_POWERED_TOGGLEBIT  0x00000040
+#define B_MARKED_TOGGLEBIT   0x00000080
 
 
 // reward sounds (stored in ps->persistant[PERS_PLAYEREVENTS])
@@ -585,8 +586,6 @@
   MN_TEAM,
   MN_A_TEAMFULL,
   MN_H_TEAMFULL,
-  MN_A_TEAMCHANGEBUILDTIMER,
-  MN_H_TEAMCHANGEBUILDTIMER,
 
   //alien stuff
   MN_A_CLASS,
@@ -597,7 +596,6 @@
   MN_A_NOEROOM,
   MN_A_TOOCLOSE,
   MN_A_NOOVMND_EVOLVE,
-  MN_A_EVOLVEBUILDTIMER,
 
   //alien build
   MN_A_SPWNWARN,
@@ -617,11 +615,6 @@
   MN_H_NOSLOTS,
   MN_H_NOFUNDS,
   MN_H_ITEMHELD,
-  MN_H_NOENERGYAMMOHERE,
-  MN_H_NOARMOURYHERE,
-  MN_H_NOROOMBSUITON,
-  MN_H_NOROOMBSUITOFF,
-  MN_H_ARMOURYBUILDTIMER,
 
   //human build
   MN_H_REPEATER,
@@ -633,7 +626,19 @@
   MN_H_NORMAL,
   MN_H_TNODEWARN,
   MN_H_RPTWARN,
-  MN_H_RPTWARN2
+  MN_H_RPTWARN2,
+
+  //not used
+  MN_A_TEAMCHANGEBUILDTIMER,
+  MN_H_TEAMCHANGEBUILDTIMER,
+
+  MN_A_EVOLVEBUILDTIMER,
+
+  MN_H_NOENERGYAMMOHERE,
+  MN_H_NOARMOURYHERE,
+  MN_H_NOROOMBSUITON,
+  MN_H_NOROOMBSUITOFF,
+  MN_H_ARMOURYBUILDTIMER
 } dynMenu_t;
 
 // animations
@@ -1029,6 +1034,7 @@
   qboolean  dccTest;
   qboolean  transparentTest;
   qboolean  reactorTest;
+  qboolean  replaceable;
 } buildableAttributes_t;
 
 typedef struct
@@ -1122,6 +1128,7 @@
                                                                const vec3_t, const vec3_t, int, int ),
                                                 vec3_t outOrigin, vec3_t outAngles, trace_t *tr );
 int       BG_GetValueOfHuman( playerState_t *ps );
+int       BG_GetValueOfEquipment( playerState_t *ps );
 
 int       BG_FindBuildNumForName( char *name );
 int       BG_FindBuildNumForEntityName( char *name );
@@ -1156,6 +1163,7 @@
 int       BG_FindCreepSizeForBuildable( int bclass );
 int       BG_FindDCCTestForBuildable( int bclass );
 int       BG_FindUniqueTestForBuildable( int bclass );
+qboolean  BG_FindReplaceableTestForBuildable( int bclass );
 qboolean  BG_FindTransparentTestForBuildable( int bclass );
 void      BG_InitBuildableOverrides( void );
 
Index: src/game/g_team.c
===================================================================
--- src/game/g_team.c	(revision 966)
+++ src/game/g_team.c	(working copy)
@@ -253,4 +253,24 @@
         TeamplayInfoMessage( ent );
     }
   }
+
+  //Warn on unbalanced teams
+  if ( g_teamImbalanceWarnings.integer && !level.intermissiontime && level.time - level.lastTeamUnbalancedTime > ( g_teamImbalanceWarnings.integer * 1000 ) && level.numTeamWarnings<3 )
+  {
+	  level.lastTeamUnbalancedTime = level.time;
+	  if (level.numAlienSpawns > 0 && level.numHumanClients - level.numAlienClients > 2)
+	  {
+		  trap_SendServerCommand (-1, "print \"Teams are unbalanced. Humans have more players.\n Humans will keep their points when switching teams.\n\"");
+		  level.numTeamWarnings++;
+	  }
+	  else if (level.numHumanSpawns > 0 && level.numAlienClients - level.numHumanClients > 2)
+	  {
+		  trap_SendServerCommand (-1, "print \"Teams are unbalanced. Aliens have more players.\n Aliens will keep their points when switching teams.\n\"");
+		  level.numTeamWarnings++;
+	  }
+	  else
+	  {
+		  level.numTeamWarnings = 0;
+	  }
+  }
 }
Index: src/game/g_cmds.c
===================================================================
--- src/game/g_cmds.c	(revision 966)
+++ src/game/g_cmds.c	(working copy)
@@ -263,10 +263,15 @@
 
     if( cl->pers.connected == CON_CONNECTING )
       ping = -1;
+    else if( cl->sess.spectatorState == SPECTATOR_FOLLOW )
+      ping = cl->pers.ping < 999 ? cl->pers.ping : 999;
     else
       ping = cl->ps.ping < 999 ? cl->ps.ping : 999;
 
-    if( cl->ps.stats[ STAT_HEALTH ] > 0 )
+    //If (loop) client is a spectator, they have nothing, so indicate such. 
+    //Only send the client requesting the scoreboard the weapon/upgrades information for members of their team. If they are not on a team, send it all.
+    if( cl->sess.sessionTeam != TEAM_SPECTATOR && 
+      (ent->client->pers.teamSelection == PTE_NONE || cl->pers.teamSelection == ent->client->pers.teamSelection ) )
     {
       weapon = cl->ps.weapon;
 
@@ -290,8 +295,8 @@
     }
 
     Com_sprintf( entry, sizeof( entry ),
-      " %d %d %d %d %d %d", level.sortedClients[ i ], cl->ps.persistant[ PERS_SCORE ],
-      ping, ( level.time - cl->pers.enterTime ) / 60000, weapon, upgrade );
+      " %d %d %d %d %d %d", level.sortedClients[ i ], cl->pers.score, ping, 
+      ( level.time - cl->pers.enterTime ) / 60000, weapon, upgrade );
 
     j = strlen( entry );
 
@@ -345,7 +350,55 @@
   return line;
 }
 
+/*
+==================
+G_Flood_Limited
 
+Determine whether a user is flood limited, and adjust their flood demerits
+==================
+*/
+
+qboolean G_Flood_Limited( gentity_t *ent )
+{
+  int millisSinceLastCommand;
+  int maximumDemerits;
+
+  // This shouldn't be called if g_floodMinTime isn't set, but handle it anyway.
+  if( !g_floodMinTime.integer )
+    return qfalse;
+  
+  if( level.paused ) //Doesn't work when game is paused, so disable
+    return qfalse;
+  
+  // Do not limit admins with no censor/flood flag
+  if( G_admin_permission( ent, ADMF_NOCENSORFLOOD ) )
+   return qfalse;
+  
+  millisSinceLastCommand = level.time - ent->client->pers.lastFloodTime;
+  if( millisSinceLastCommand < g_floodMinTime.integer )
+    ent->client->pers.floodDemerits += ( g_floodMinTime.integer - millisSinceLastCommand );
+  else
+  {
+    ent->client->pers.floodDemerits -= ( millisSinceLastCommand - g_floodMinTime.integer );
+    if( ent->client->pers.floodDemerits < 0 )
+      ent->client->pers.floodDemerits = 0;
+  }
+
+  ent->client->pers.lastFloodTime = level.time;
+
+  // If g_floodMaxDemerits == 0, then we go against g_floodMinTime^2.
+  
+  if( !g_floodMaxDemerits.integer )
+     maximumDemerits = g_floodMinTime.integer * g_floodMinTime.integer / 1000;
+  else
+     maximumDemerits = g_floodMaxDemerits.integer;
+
+  if( ent->client->pers.floodDemerits > maximumDemerits )
+     return qtrue;
+
+  return qfalse;
+}
+  
 /*
 ==================
 Cmd_Give_f
@@ -364,8 +417,11 @@
 
   if( give_all || Q_stricmp( name, "health" ) == 0 )
   {
-    ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
-    BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+    if(!g_devmapNoGod.integer)
+    {
+     ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
+     BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+    }
   }
 
   if( give_all || Q_stricmpn( name, "funds", 5 ) == 0 )
@@ -416,12 +472,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   ent->flags ^= FL_GODMODE;
 
   if( !( ent->flags & FL_GODMODE ) )
     msg = "godmode OFF\n";
   else
     msg = "godmode ON\n";
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -440,12 +503,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   ent->flags ^= FL_NOTARGET;
 
   if( !( ent->flags & FL_NOTARGET ) )
     msg = "notarget OFF\n";
   else
     msg = "notarget ON\n";
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -462,12 +532,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   if( ent->client->noclip )
     msg = "noclip OFF\n";
   else
     msg = "noclip ON\n";
 
   ent->client->noclip = !ent->client->noclip;
+ } 
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -544,6 +621,9 @@
   else
     return;
 
+  // stop any following clients
+  G_StopFromFollowing( self );
+
   for( i = 0; i < level.num_entities; i++ )
   {
     ent = &g_entities[ i ];
@@ -555,14 +635,6 @@
       G_FreeEntity( ent );
     if( ent->client && ent->client->pers.connected == CON_CONNECTED )
     {
-      // stop following clients
-      if( ent->client->sess.sessionTeam == TEAM_SPECTATOR &&
-          ent->client->sess.spectatorState == SPECTATOR_FOLLOW &&
-          ent->client->sess.spectatorClient == self->client->ps.clientNum )
-      {
-        if( !G_FollowNewClient( ent, 1 ) )
-          G_StopFollowing( ent );
-      }
       // cure poison
       if( ent->client->ps.stats[ STAT_STATE ] & SS_POISONCLOUDED &&
           ent->client->lastPoisonCloudedClient == self )
@@ -582,52 +654,74 @@
 void G_ChangeTeam( gentity_t *ent, pTeam_t newTeam )
 {
   pTeam_t oldTeam = ent->client->pers.teamSelection;
+  qboolean isFixingImbalance=qfalse;
  
   if( oldTeam == newTeam )
     return;
 
   G_LeaveTeam( ent );
   ent->client->pers.teamSelection = newTeam;
+  
+  
+  if ( ( level.numAlienClients - level.numHumanClients > 2 && oldTeam==PTE_ALIENS && newTeam == PTE_HUMANS && level.numHumanSpawns>0 ) ||
+       ( level.numHumanClients - level.numAlienClients > 2 && oldTeam==PTE_HUMANS && newTeam == PTE_ALIENS  && level.numAlienSpawns>0 ) ) 
+  {
+    isFixingImbalance=qtrue;
+  }
 
   // under certain circumstances, clients can keep their kills and credits
   // when switching teams
   if( G_admin_permission( ent, ADMF_TEAMCHANGEFREE ) ||
+    ( g_teamImbalanceWarnings.integer && isFixingImbalance ) ||
     ( ( oldTeam == PTE_HUMANS || oldTeam == PTE_ALIENS )
     && ( level.time - ent->client->pers.teamChangeTime ) > 60000 ) )
   {
-    if( oldTeam == PTE_NONE )
-    {
-      // ps.persistant[] from a spectator cannot be trusted
-      ent->client->ps.persistant[ PERS_SCORE ] = ent->client->pers.savedScore;
-      ent->client->ps.persistant[ PERS_CREDIT ] = ent->client->pers.savedCredit;
-    }
-    else if( oldTeam == PTE_ALIENS )
-    {
-      // always save in human credtis
-      ent->client->ps.persistant[ PERS_CREDIT ] *=
-        (float)FREEKILL_HUMAN / FREEKILL_ALIEN;
-    }
+    if( oldTeam == PTE_ALIENS )
+      ent->client->pers.credit *= (float)FREEKILL_HUMAN / FREEKILL_ALIEN;
+    else if( newTeam == PTE_ALIENS )
+      ent->client->pers.credit *= (float)FREEKILL_ALIEN / FREEKILL_HUMAN;
+  }
+  else
+  {
+    ent->client->pers.credit = 0;
+    ent->client->pers.score = 0;
+  }
+  
+  ent->client->ps.persistant[ PERS_KILLED ] = 0;
+  ent->client->pers.statscounters.kills = 0;
+  ent->client->pers.statscounters.structskilled = 0;
+  ent->client->pers.statscounters.assists = 0;
+  ent->client->pers.statscounters.repairspoisons = 0;
+  ent->client->pers.statscounters.headshots = 0;
+  ent->client->pers.statscounters.hits = 0;
+  ent->client->pers.statscounters.hitslocational = 0;
+  ent->client->pers.statscounters.deaths = 0;
+  ent->client->pers.statscounters.feeds = 0;
+  ent->client->pers.statscounters.suicides = 0;
+  ent->client->pers.statscounters.teamkills = 0;
+  ent->client->pers.statscounters.dmgdone = 0;
+  ent->client->pers.statscounters.structdmgdone = 0;
+  ent->client->pers.statscounters.ffdmgdone = 0;
+  ent->client->pers.statscounters.structsbuilt = 0;
+  ent->client->pers.statscounters.timealive = 0;
+  ent->client->pers.statscounters.timeinbase = 0;
+  ent->client->pers.statscounters.dretchbasytime = 0;
+  ent->client->pers.statscounters.jetpackusewallwalkusetime = 0;
 
-    if( newTeam == PTE_NONE )
+  if( G_admin_permission( ent, ADMF_DBUILDER ) )
+  {
+    if( !ent->client->pers.designatedBuilder )
     {
-      // save values before the client enters the spectator team and their
-      // ps.persistant[] values become trashed
-      ent->client->pers.savedScore = ent->client->ps.persistant[ PERS_SCORE ];
-      ent->client->pers.savedCredit = ent->client->ps.persistant[ PERS_CREDIT ];
+      ent->client->pers.designatedBuilder = qtrue;
+      trap_SendServerCommand( ent-g_entities, 
+        "print \"Your designation has been restored\n\"" );
     }
-    else if( newTeam == PTE_ALIENS )
-    {
-      // convert to alien currency
-      ent->client->ps.persistant[ PERS_CREDIT ] *=
-        (float)FREEKILL_ALIEN / FREEKILL_HUMAN;
-    }
   }
-  else
+  else if( ent->client->pers.designatedBuilder )
   {
-    ent->client->ps.persistant[ PERS_CREDIT ] = 0;
-    ent->client->ps.persistant[ PERS_SCORE ] = 0;
-    ent->client->pers.savedScore = 0;
-    ent->client->pers.savedCredit = 0;
+    ent->client->pers.designatedBuilder = qfalse;
+    trap_SendServerCommand( ent-g_entities, 
+     "print \"You have lost designation due to teamchange\n\"" );
   }
 
   ent->client->pers.classSelection = PCL_NONE;
@@ -638,6 +732,7 @@
 
   //update ClientInfo
   ClientUserinfoChanged( ent->client->ps.clientNum );
+  G_CheckDBProtection( );
 }
 
 /*
@@ -650,6 +745,7 @@
   pTeam_t team;
   pTeam_t oldteam = ent->client->pers.teamSelection;
   char    s[ MAX_TOKEN_CHARS ];
+  char buf[ MAX_STRING_CHARS ];
   qboolean force = G_admin_permission(ent, ADMF_FORCETEAMCHANGE);
   int     aliens = level.numAlienClients;
   int     humans = level.numHumanClients;
@@ -663,6 +759,16 @@
   else if( oldteam == PTE_HUMANS )
     humans--;
 
+  // do warm up
+  if( g_doWarmup.integer &&
+      level.time - level.startTime < g_warmup.integer * 1000 )
+  {
+    trap_SendServerCommand( ent - g_entities, va( "print \"team: you can't join"
+      " a team during warm up (%d seconds remaining)\n\"",
+      g_warmup.integer - ( level.time - level.startTime ) / 1000 ) );
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
 
   if( !strlen( s ) )
@@ -672,11 +778,27 @@
     return;
   }
 
+  if( Q_stricmp( s, "spectate" ) ){
+	if(G_admin_level(ent)<g_minLevelToJoinTeam.integer){
+		trap_SendServerCommand( ent-g_entities,"print \"Sorry, but your admin level is only permitted to spectate.\n\"" ); 
+		return;
+	}
+  }
+  
   if( !Q_stricmp( s, "spectate" ) )
     team = PTE_NONE;
+  else if( !force && ent->client->pers.teamSelection == PTE_NONE &&
+           g_maxGameClients.integer && level.numPlayingClients >=
+           g_maxGameClients.integer )
+  {
+    trap_SendServerCommand( ent - g_entities, va( "print \"The maximum number "
+      "of playing clients has been reached (g_maxGameClients = %i)\n\"",
+      g_maxGameClients.integer ) );
+    return;
+  }
   else if( !Q_stricmp( s, "aliens" ) )
   {
-    if( level.alienTeamLocked )
+    if( level.alienTeamLocked && !force )
     {
       trap_SendServerCommand( ent-g_entities,
         va( "print \"Alien team has been ^1LOCKED\n\"" ) );
@@ -694,12 +816,13 @@
       G_TriggerMenu( ent - g_entities, MN_A_TEAMFULL );
       return;
     }
+    
 
     team = PTE_ALIENS;
   }
   else if( !Q_stricmp( s, "humans" ) )
   {
-    if( level.humanTeamLocked )
+    if( level.humanTeamLocked && !force )
     {
       trap_SendServerCommand( ent-g_entities,
         va( "print \"Human team has been ^1LOCKED\n\"" ) );
@@ -747,27 +870,57 @@
     return;
 
   //guard against build timer exploit
-  if( oldteam != PTE_NONE &&
+  if( oldteam != PTE_NONE && ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
      ( ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0 ||
        ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG ||
        BG_InventoryContainsWeapon( WP_HBUILD, ent->client->ps.stats ) ||
        BG_InventoryContainsWeapon( WP_HBUILD2, ent->client->ps.stats ) ) &&
       ent->client->ps.stats[ STAT_MISC ] > 0 )
   {
-    if( ent->client->pers.teamSelection == PTE_ALIENS )
-      G_TriggerMenu( ent->client->ps.clientNum, MN_A_TEAMCHANGEBUILDTIMER );
-    else
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_TEAMCHANGEBUILDTIMER );
+    trap_SendServerCommand( ent-g_entities,
+        va( "print \"You cannot change teams until build timer expires\n\"" ) );
     return;
   }
 
+   if (team != PTE_NONE)
+   {
+ 	  char	namebuff[32];
+ 
+ 	  Q_strncpyz (namebuff, ent->client->pers.netname, sizeof(namebuff));
+ 	  Q_CleanStr (namebuff);
+ 
+ 	  if (!namebuff[0] || !Q_stricmp (namebuff, "UnnamedPlayer"))
+ 	  {
+ 		  trap_SendServerCommand( ent-g_entities, va( "print \"Please set your player name before joining a team. Press ESC and use the Options / Game menu  or use /name in the console\n\"") );
+ 		  return;
+ 	  }
+   }
+ 
 
   G_ChangeTeam( ent, team );
+   
+   
 
-  if( team == PTE_ALIENS )
-    trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the aliens\n\"", ent->client->pers.netname ) );
-  else if( team == PTE_HUMANS )
-    trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the humans\n\"", ent->client->pers.netname ) );
+   if( team == PTE_ALIENS ) {
+     if ( oldteam == PTE_HUMANS )
+       Com_sprintf( buf, sizeof( buf ), "%s^7 abandoned humans and joined the aliens.", ent->client->pers.netname );
+     else
+       Com_sprintf( buf, sizeof( buf ), "%s^7 joined the aliens.", ent->client->pers.netname );
+   }
+   else if( team == PTE_HUMANS ) {
+     if ( oldteam == PTE_ALIENS )
+       Com_sprintf( buf, sizeof( buf ), "%s^7 abandoned the aliens and joined the humans.", ent->client->pers.netname );
+     else
+       Com_sprintf( buf, sizeof( buf ), "%s^7 joined the humans.", ent->client->pers.netname );
+   }
+   else if( team == PTE_NONE ) {
+     if ( oldteam == PTE_HUMANS )
+       Com_sprintf( buf, sizeof( buf ), "%s^7 left the humans.", ent->client->pers.netname );
+     else
+       Com_sprintf( buf, sizeof( buf ), "%s^7 left the aliens.", ent->client->pers.netname );
+   }
+   trap_SendServerCommand( -1, va( "print \"%s\n\"", buf ) );
+   G_LogOnlyPrintf("ClientTeam: %s\n",buf);
 }
 
 
@@ -776,9 +929,10 @@
 G_Say
 ==================
 */
-static void G_SayTo( gentity_t *ent, gentity_t *other, int mode, int color, const char *name, const char *message )
+static void G_SayTo( gentity_t *ent, gentity_t *other, int mode, int color, const char *name, const char *message, const char *prefix )
 {
   qboolean ignore = qfalse;
+  qboolean specAllChat = qfalse;
 
   if( !other )
     return;
@@ -792,23 +946,28 @@
   if( other->client->pers.connected != CON_CONNECTED )
     return;
 
-  if( mode == SAY_TEAM && !OnSameTeam( ent, other ) )
+  if( ( mode == SAY_TEAM || mode == SAY_ACTION_T ) && !OnSameTeam( ent, other ) )
   {
     if( other->client->pers.teamSelection != PTE_NONE )
       return;
 
-    if( !G_admin_permission( other, ADMF_SPEC_ALLCHAT ) )
+    specAllChat = G_admin_permission( other, ADMF_SPEC_ALLCHAT );
+    if( !specAllChat )
       return;
 
     // specs with ADMF_SPEC_ALLCHAT flag can see team chat
   }
+  
+  if( mode == SAY_ADMINS && !G_admin_permission( other, ADMF_ADMINCHAT) )
+     return;
 
   if( BG_ClientListTest( &other->client->sess.ignoreList, ent-g_entities ) )
     ignore = qtrue;
   
-  trap_SendServerCommand( other-g_entities, va( "%s \"%s%s%c%c%s\"",
-    mode == SAY_TEAM ? "tchat" : "chat",
+  trap_SendServerCommand( other-g_entities, va( "%s \"%s%s%s%c%c%s\"",
+    ( mode == SAY_TEAM || mode == SAY_ACTION_T ) ? "tchat" : "chat",
     ( ignore ) ? "[skipnotify]" : "",
+    ( specAllChat ) ? prefix : "",
     name, Q_COLOR_ESCAPE, color, message ) );
 }
 
@@ -825,6 +984,18 @@
   char        text[ MAX_SAY_TEXT ];
   char        location[ 64 ];
 
+  // Bail if the text is blank.
+  if( ! chatText[0] )
+     return;
+
+  // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+       
   if (g_chatTeamPrefix.integer)
   {
     switch( ent->client->pers.teamSelection)
@@ -849,21 +1020,25 @@
   {
     default:
     case SAY_ALL:
-      G_LogPrintf( "say: %s: %s\n", ent->client->pers.netname, chatText );
+      G_LogPrintf( "say: %s^7: %s^7\n", ent->client->pers.netname, chatText );
       Com_sprintf( name, sizeof( name ), "%s%s%c%c"EC": ", prefix,
                    ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
       color = COLOR_GREEN;
       break;
 
     case SAY_TEAM:
-      G_LogPrintf( "sayteam: %s: %s\n", ent->client->pers.netname, chatText );
+      G_LogPrintf( "sayteam: %s%s^7: %s^7\n", prefix, ent->client->pers.netname, chatText );
       if( Team_GetLocationMsg( ent, location, sizeof( location ) ) )
         Com_sprintf( name, sizeof( name ), EC"(%s%c%c"EC") (%s)"EC": ",
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE, location );
       else
         Com_sprintf( name, sizeof( name ), EC"(%s%c%c"EC")"EC": ",
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
-      color = COLOR_CYAN;
+      
+      if( ent->client->pers.teamSelection == PTE_NONE )
+        color = COLOR_YELLOW;
+      else
+        color = COLOR_CYAN;
       break;
 
     case SAY_TELL:
@@ -876,31 +1051,135 @@
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
       color = COLOR_MAGENTA;
       break;
+      
+    case SAY_ACTION:
+      G_LogPrintf( "action: %s^7: %s^7\n", ent->client->pers.netname, chatText );
+      Com_sprintf( name, sizeof( name ), "^2%s^7%s%s%c%c"EC" ", g_actionPrefix.string, prefix,
+                   ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+      color = COLOR_WHITE;
+      break;
+
+    case SAY_ACTION_T:
+      G_LogPrintf( "actionteam: %s%s^7: %s^7\n", prefix, ent->client->pers.netname, chatText );
+      if( Team_GetLocationMsg( ent, location, sizeof( location ) ) )
+        Com_sprintf( name, sizeof( name ), EC"^5%s^7%s%c%c"EC"(%s)"EC" ", g_actionPrefix.string, 
+          ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE, location );
+      else
+        Com_sprintf( name, sizeof( name ), EC"^5%s^7%s%c%c"EC""EC" ", g_actionPrefix.string, 
+          ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+      color = COLOR_WHITE;
+      break;
+      
+      case SAY_ADMINS:
+        if( G_admin_permission( ent, ADMF_ADMINCHAT ) ) //Differentiate between inter-admin chatter and user-admin alerts
+        {
+         G_LogPrintf( "say_admins: [ADMIN]%s^7: %s^7\n", ( ent ) ? ent->client->pers.netname : "console", chatText );
+         Com_sprintf( name, sizeof( name ), "%s[ADMIN]%s%c%c"EC": ", prefix,
+                    ( ent ) ? ent->client->pers.netname : "console", Q_COLOR_ESCAPE, COLOR_WHITE );
+	color = COLOR_MAGENTA;
+	}
+	else
+	{
+         G_LogPrintf( "say_admins: [PLAYER]%s^7: %s^7\n", ent->client->pers.netname, chatText );
+         Com_sprintf( name, sizeof( name ), "%s[PLAYER]%s%c%c"EC": ", prefix,
+                    ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+	color = COLOR_MAGENTA;
+	}
+
+	break;
   }
+  
+  if( mode!=SAY_TEAM && ent->client->pers.teamSelection == PTE_NONE && G_admin_level(ent)<g_minLevelToSpecMM1.integer )
+  {
+    trap_SendServerCommand( ent-g_entities,va( "print \"Sorry, but your admin level may only use teamchat while spectating.\n\"") ); 
+    return;
+  }
 
   Q_strncpyz( text, chatText, sizeof( text ) );
 
   if( target )
   {
-    G_SayTo( ent, target, mode, color, name, text );
+    G_SayTo( ent, target, mode, color, name, text, prefix );
     return;
   }
+  
+   
+   if( g_adminParseSay.integer && ( mode== SAY_ALL || mode == SAY_TEAM ) )
+   {
+     if( G_admin_cmd_check ( ent, qtrue ) && g_adminSayFilter.integer ) 
+     {
+       return;
+     }
+   }
 
-  // echo the text to the console
-  if( g_dedicated.integer )
-    G_Printf( "%s%s\n", name, text);
-
   // send it to all the apropriate clients
   for( j = 0; j < level.maxclients; j++ )
   {
     other = &g_entities[ j ];
-    G_SayTo( ent, other, mode, color, name, text );
+    G_SayTo( ent, other, mode, color, name, text, prefix );
   }
   
-  if( g_adminParseSay.integer )
+
+}
+
+static void Cmd_SayArea_f( gentity_t *ent )
+{
+  int    entityList[ MAX_GENTITIES ];
+  int    num, i;
+  int    color = COLOR_BLUE;
+  const char  *prefix;
+  vec3_t range = { HELMET_RANGE, HELMET_RANGE, HELMET_RANGE };
+  vec3_t mins, maxs;
+  char   *msg = ConcatArgs( 1 );
+  char   name[ 64 ];
+  
+   if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+  
+  if (g_chatTeamPrefix.integer)
   {
-    G_admin_cmd_check ( ent, qtrue );
+    switch( ent->client->pers.teamSelection)
+    {
+      default:
+      case PTE_NONE:
+        prefix = "[S] ";
+        break;
+
+      case PTE_ALIENS:
+        prefix = "[A] ";
+        break;
+
+      case PTE_HUMANS:
+        prefix = "[H] ";
+    }
   }
+  else
+    prefix = "";
+
+  G_LogPrintf( "sayarea: %s%s^7: %s\n", prefix, ent->client->pers.netname, msg );
+  Com_sprintf( name, sizeof( name ), EC"<%s%c%c"EC"> ",
+    ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+
+  VectorAdd( ent->s.origin, range, maxs );
+  VectorSubtract( ent->s.origin, range, mins );
+
+  num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
+  for( i = 0; i < num; i++ )
+    G_SayTo( ent, &g_entities[ entityList[ i ] ], SAY_TEAM, color, name, msg, prefix );
+  
+  //Send to ADMF_SPEC_ALLCHAT candidates
+  for( i = 0; i < level.maxclients; i++ )
+  {
+    if( (&g_entities[ i ])->client->pers.teamSelection == PTE_NONE  &&
+        G_admin_permission( &g_entities[ i ], ADMF_SPEC_ALLCHAT ) )
+    {
+      G_SayTo( ent, &g_entities[ i ], SAY_TEAM, color, name, msg, prefix );   
+    }
+  }
 }
 
 
@@ -913,11 +1192,14 @@
 {
   char    *p;
   char    *args;
+  int     offset = 0;
   int     mode = SAY_ALL;
 
   args = G_SayConcatArgs( 0 );
   if( Q_stricmpn( args, "say_team ", 9 ) == 0 )
     mode = SAY_TEAM;
+  if( Q_stricmpn( args, "say_admins ", 11 ) == 0 || Q_stricmpn( args, "a ", 2 ) == 0)
+    mode = SAY_ADMINS;
 
   // support parsing /m out of say text since some people have a hard
   // time figuring out what the console is.
@@ -929,12 +1211,89 @@
     G_PrivateMessage( ent );
     return;
   }
+  
+   
+   if( !Q_stricmpn( args, "say /a ", 7) ||
+       !Q_stricmpn( args, "say_team /a ", 12) ||
+       !Q_stricmpn( args, "say /say_admins ", 16) ||
+       !Q_stricmpn( args, "say_team /say_admins ", 21) )
+   {
+       mode = SAY_ADMINS;
+       offset=3;
+   }
+   
+   if( mode == SAY_ADMINS)  
+   if(!G_admin_permission( ent, ADMF_ADMINCHAT ) )
+   {
+     if( !g_publicSayadmins.integer )
+     {
+      ADMP( "Sorry, but public use of say_admins has been disabled.\n" );
+      return;
+     }
+     else
+     {
+       ADMP( "Your message has been sent to any available admins and to the server logs.\n" );
+     }
+   }
+   
 
+  if(!Q_stricmpn( args, "say /me ", 8 ) )
+  {
+   if( g_allowActions.integer ) 
+   { 
+    mode = SAY_ACTION;
+    offset = 4;
+   } else return;
+  }
+  else if(!Q_stricmpn( args, "say_team /me ", 13 ) )
+  {
+   if( g_allowActions.integer ) 
+   { 
+    mode = SAY_ACTION_T;
+    offset = 4;
+   } else return;
+  }
+  else if( !Q_stricmpn( args, "me ", 3 ) )
+  {
+   if( g_allowActions.integer ) 
+   { 
+    mode = SAY_ACTION;
+   } else return;
+  }
+  else if( !Q_stricmpn( args, "me_team ", 8 ) )
+  {
+   if( g_allowActions.integer ) 
+   { 
+    mode = SAY_ACTION_T;
+   } else return;
+  }
+
+
+  if( g_allowShare.integer )
+  {
+    args = G_SayConcatArgs(0);
+    if( !Q_stricmpn( args, "say /share", 10 ) ||
+      !Q_stricmpn( args, "say_team /share", 15 ) )
+    {
+      Cmd_Share_f( ent );
+      return;
+    }
+   if( !Q_stricmpn( args, "say /donate", 11 ) ||
+      !Q_stricmpn( args, "say_team /share", 16 ) )
+    {
+      Cmd_Donate_f( ent );
+      return;
+    }
+  }
+
+
   if( trap_Argc( ) < 2 )
     return;
 
   p = ConcatArgs( 1 );
 
+  p += offset;
+  
   G_Say( ent, NULL, mode, p );
 }
 
@@ -995,6 +1354,11 @@
   char  arg2[ MAX_STRING_TOKENS ];
   int   clientNum = -1;
   char  name[ MAX_NETNAME ];
+  char *arg2plus;
+  char nullstring[] = "";
+  char  message[ MAX_STRING_CHARS ];
+	
+  arg2plus = G_SayConcatArgs( 2 );
 
   if( !g_allowVote.integer )
   {
@@ -1002,6 +1366,18 @@
     return;
   }
 
+  if( g_voteMinTime.integer
+    && ent->client->pers.firstConnect 
+    && level.time - ent->client->pers.enterTime < g_voteMinTime.integer * 1000
+    && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+    && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+  {
+    trap_SendServerCommand( ent-g_entities, va(
+      "print \"You must wait %d seconds after connecting before calling a vote\n\"",
+      g_voteMinTime.integer ) );
+    return;
+  }
+
   if( level.voteTime )
   {
     trap_SendServerCommand( ent-g_entities, "print \"A vote is already in progress\n\"" );
@@ -1009,7 +1385,7 @@
   }
 
   if( g_voteLimit.integer > 0
-    && ent->client->pers.voteCount >= g_voteLimit.integer 
+    && ent->client->pers.voteCount >= g_voteLimit.integer
     && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
   {
     trap_SendServerCommand( ent-g_entities, va(
@@ -1017,6 +1393,13 @@
       g_voteLimit.integer ) );
     return;
   }
+  
+  if( ent->client->pers.muted )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You are muted and cannot call votes\n\"" );
+    return;
+  }
 
   // make sure it is a valid command to vote on
   trap_Argv( 1, arg1, sizeof( arg1 ) );
@@ -1034,6 +1417,8 @@
     level.voteExecuteTime = 0;
     trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.voteString ) );
   }
+  
+  level.votePercentToPass=50;
 
   // detect clientNum for partial name match votes
   if( !Q_stricmp( arg1, "kick" ) ||
@@ -1041,6 +1426,8 @@
     !Q_stricmp( arg1, "unmute" ) )
   {
     int clientNums[ MAX_CLIENTS ] = { -1 };
+    int numMatches=0;
+    char err[ MAX_STRING_CHARS ];
 
     if( !arg2[ 0 ] )
     {
@@ -1049,7 +1436,8 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums ) == 1 )
+    numMatches = G_ClientNumbersFromString( arg2, clientNums );
+    if( numMatches == 1 )
     {
       // there was only one partial name match
       clientNum = clientNums[ 0 ]; 
@@ -1057,9 +1445,16 @@
     else
     {
       // look for an exact name match (sets clientNum to -1 if it fails) 
-      clientNum = G_ClientNumberFromString( ent, arg2 );
+      clientNum = G_ClientNumberFromString( ent, arg2plus );
     }
-
+    
+    if( clientNum==-1  && numMatches > 1 ) 
+    {
+      G_MatchOnePlayer( clientNums, err, sizeof( err ) );
+      ADMP( va( "^3callvote: ^7%s\n", err ) );
+      return;
+    }
+    
     if( clientNum != -1 &&
       level.clients[ clientNum ].pers.connected == CON_DISCONNECTED )
     {
@@ -1071,6 +1466,9 @@
       Q_strncpyz( name, level.clients[ clientNum ].pers.netname,
         sizeof( name ) );
       Q_CleanStr( name );
+      if ( G_admin_permission ( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+        Com_sprintf( message, sizeof( message ), "%s^7 attempted /callvote %s %s on immune admin %s^7",
+          ent->client->pers.netname, arg1, arg2, g_entities[ clientNum ].client->pers.netname );
     }
     else
     {
@@ -1086,13 +1484,14 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: admin is immune from vote kick\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.voteString, sizeof( level.voteString ),
-      "!ban %s %d vote kick", level.clients[ clientNum ].pers.ip,
-      g_adminTempBan.integer + 1 );
+      "!ban %s \"%s\" vote kick", level.clients[ clientNum ].pers.ip,
+      g_adminTempBan.string );
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
       "Kick player \'%s\'", name );
   }
@@ -1109,6 +1508,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: admin is immune from vote mute\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
     Com_sprintf( level.voteString, sizeof( level.voteString ),
@@ -1131,51 +1531,118 @@
   }
   else if( !Q_stricmp( arg1, "map_restart" ) )
   {
+    if( g_mapvoteMaxTime.integer 
+      && level.time >= g_mapvoteMaxTime.integer * 1000 
+      && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+      && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+    {
+       trap_SendServerCommand( ent-g_entities, va(
+         "print \"You cannot call for a restart after %d seconds\n\"",
+         g_mapvoteMaxTime.integer ) );
+       return;
+    }
     Com_sprintf( level.voteString, sizeof( level.voteString ), "%s", arg1 );
     Com_sprintf( level.voteDisplayString,
         sizeof( level.voteDisplayString ), "Restart current map" );
+    level.votePercentToPass = g_mapVotesPercent.integer;
   }
   else if( !Q_stricmp( arg1, "map" ) )
   {
+    if( g_mapvoteMaxTime.integer 
+      && level.time >= g_mapvoteMaxTime.integer * 1000 
+      && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+      && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+    {
+       trap_SendServerCommand( ent-g_entities, va(
+         "print \"You cannot call for a mapchange after %d seconds\n\"",
+         g_mapvoteMaxTime.integer ) );
+       return;
+    }
+  
     if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
     {
       trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
         "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
       return;
     }
-
     Com_sprintf( level.voteString, sizeof( level.voteString ), "%s %s", arg1, arg2 );
     Com_sprintf( level.voteDisplayString,
         sizeof( level.voteDisplayString ), "Change to map '%s'", arg2 );
+    level.votePercentToPass = g_mapVotesPercent.integer;
   }
   else if( !Q_stricmp( arg1, "draw" ) )
   {
     Com_sprintf( level.voteString, sizeof( level.voteString ), "evacuation" );
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
         "End match in a draw" );
+    level.votePercentToPass = g_mapVotesPercent.integer;
   }
+   else if( !Q_stricmp( arg1, "poll" ) )
+    {
+    Com_sprintf( level.voteString, sizeof( level.voteString ), nullstring);
+    Com_sprintf( level.voteDisplayString,
+        sizeof( level.voteDisplayString ), "[Poll] \'%s\'", arg2plus );
+   }
+   else if( !Q_stricmp( arg1, "sudden_death" ) ||
+     !Q_stricmp( arg1, "suddendeath" ) )
+   {
+     if(!g_suddenDeathVotePercent.integer)
+     {
+       trap_SendServerCommand( ent-g_entities, "print \"Sudden Death votes have been disabled\n\"" );
+       return;
+     } 	  
+     else if( g_suddenDeath.integer ) 
+     {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: ""Sudden Death has already begun\n\"") );
+      return;
+     }
+    else 
+     {
+     level.votePercentToPass = g_suddenDeathVotePercent.integer;	   
+     Com_sprintf( level.voteString, sizeof( level.voteString ), "g_suddenDeath 1" );
+     Com_sprintf( level.voteDisplayString,
+         sizeof( level.voteDisplayString ), "Begin sudden death" );
+     }
+   }
   else
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities, "print \"Valid vote commands are: "
-      "map, map_restart, draw, kick, mute and unmute\n" );
+      "map, map_restart, draw, kick, mute, unmute, poll, and sudden_death\n" );
     return;
   }
+  
+  if( level.votePercentToPass!=50 )
+  {
+    Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " (Needs %d percent)", level.votePercentToPass ) );
+  }
+  
 
   trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE
-        " called a vote\n\"", ent->client->pers.netname ) );
+         " called a vote: %s\n\"", ent->client->pers.netname, level.voteDisplayString ) );
+  
+  G_LogPrintf("Vote: %s^7 called a vote: %s^7\n", ent->client->pers.netname, level.voteDisplayString );
+  
+  Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " Called by: %s^7", ent->client->pers.netname ) );
 
   ent->client->pers.voteCount++;
 
   // start the voting, the caller autoamtically votes yes
   level.voteTime = level.time;
-  level.voteYes = 1;
   level.voteNo = 0;
 
   for( i = 0 ; i < level.maxclients ; i++ )
     level.clients[i].ps.eFlags &= ~EF_VOTED;
 
-  ent->client->ps.eFlags |= EF_VOTED;
+  if( !Q_stricmp( arg1, "poll" ) )
+  {
+    level.voteYes = 0;
+  }
+  else
+  {
+   level.voteYes = 1;
+   ent->client->ps.eFlags |= EF_VOTED;
+  }
 
   trap_SetConfigstring( CS_VOTE_TIME, va( "%i", level.voteTime ) );
   trap_SetConfigstring( CS_VOTE_STRING, level.voteDisplayString );
@@ -1183,6 +1650,7 @@
   trap_SetConfigstring( CS_VOTE_NO, va( "%i", level.voteNo ) );
 }
 
+
 /*
 ==================
 Cmd_Vote_f
@@ -1193,7 +1661,24 @@
   char msg[ 64 ];
 
   if( !level.voteTime )
-  {
+  { 
+    if( ent->client->pers.teamSelection != PTE_NONE )
+    {
+      // If there is a teamvote going on but no global vote, forward this vote on as a teamvote
+      // (ugly hack for 1.1 cgames + noobs who can't figure out how to use any command that isn't bound by default)
+      int     cs_offset = 0;
+      if( ent->client->pers.teamSelection == PTE_ALIENS )
+        cs_offset = 1;
+    
+      if( level.teamVoteTime[ cs_offset ] )
+      {
+         if( !(ent->client->ps.eFlags & EF_TEAMVOTED ) )
+        {
+          Cmd_TeamVote_f(ent); 
+	  return;
+        }
+      }
+    }
     trap_SendServerCommand( ent-g_entities, "print \"No vote in progress\n\"" );
     return;
   }
@@ -1237,6 +1722,12 @@
   char  arg2[ MAX_STRING_TOKENS ];
   int   clientNum = -1;
   char  name[ MAX_NETNAME ];
+  char nullstring[] = "";
+  char  message[ MAX_STRING_CHARS ];
+	
+  char *arg2plus;
+	
+  arg2plus = G_SayConcatArgs( 2 );
   
   team = ent->client->pers.teamSelection;
 
@@ -1264,7 +1755,26 @@
       g_voteLimit.integer ) );
     return;
   }
+  
+  if( ent->client->pers.muted )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You are muted and cannot call teamvotes\n\"" );
+    return;
+  }
 
+  if( g_voteMinTime.integer
+    && ent->client->pers.firstConnect 
+    && level.time - ent->client->pers.enterTime < g_voteMinTime.integer * 1000
+    && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+    && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+  {
+    trap_SendServerCommand( ent-g_entities, va(
+      "print \"You must wait %d seconds after connecting before calling a vote\n\"",
+      g_voteMinTime.integer ) );
+    return;
+  }
+
   // make sure it is a valid command to vote on
   trap_Argv( 1, arg1, sizeof( arg1 ) );
   trap_Argv( 2, arg2, sizeof( arg2 ) );
@@ -1278,9 +1788,13 @@
   // detect clientNum for partial name match votes
   if( !Q_stricmp( arg1, "kick" ) ||
     !Q_stricmp( arg1, "denybuild" ) ||
-    !Q_stricmp( arg1, "allowbuild" ) )
+    !Q_stricmp( arg1, "allowbuild" ) || 
+    !Q_stricmp( arg1, "designate" ) || 
+    !Q_stricmp( arg1, "undesignate" ) )
   {
     int clientNums[ MAX_CLIENTS ] = { -1 };
+    int numMatches=0;
+    char err[ MAX_STRING_CHARS ];
 
     if( !arg2[ 0 ] )
     {
@@ -1289,7 +1803,8 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums ) == 1 )
+    numMatches = G_ClientNumbersFromString( arg2, clientNums );
+    if( numMatches == 1 )
     {
       // there was only one partial name match
       clientNum = clientNums[ 0 ]; 
@@ -1297,8 +1812,15 @@
     else
     {
       // look for an exact name match (sets clientNum to -1 if it fails) 
-      clientNum = G_ClientNumberFromString( ent, arg2 );
+      clientNum = G_ClientNumberFromString( ent, arg2plus );
     }
+    
+    if( clientNum==-1  && numMatches > 1 ) 
+    {
+      G_MatchOnePlayer( clientNums, err, sizeof( err ) );
+      ADMP( va( "^3callteamvote: ^7%s\n", err ) );
+      return;
+    }
 
     // make sure this player is on the same team
     if( clientNum != -1 && level.clients[ clientNum ].pers.teamSelection !=
@@ -1318,6 +1840,11 @@
       Q_strncpyz( name, level.clients[ clientNum ].pers.netname,
         sizeof( name ) );
       Q_CleanStr( name );
+      if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+      {
+        Com_sprintf( message, sizeof( message ), "%s^7 attempted /callteamvote %s %s on immune admin %s^7",
+          ent->client->pers.netname, arg1, arg2, g_entities[ clientNum ].client->pers.netname );
+      }
     }
     else
     {
@@ -1333,6 +1860,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callteamvote: admin is immune from vote kick\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
@@ -1340,8 +1868,8 @@
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.teamVoteString[ cs_offset ],
       sizeof( level.teamVoteString[ cs_offset ] ),
-      "!ban %s %d team vote kick", level.clients[ clientNum ].pers.ip,
-      g_adminTempBan.integer + 1 );
+      "!ban %s \"%s\" team vote kick", level.clients[ clientNum ].pers.ip,
+      g_adminTempBan.string );
     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Kick player '%s'", name );
@@ -1359,6 +1887,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callteamvote: admin is immune from denybuild\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
@@ -1383,6 +1912,49 @@
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Allow '%s' to build", name );
   }
+  else if( !Q_stricmp( arg1, "designate" ) )
+  {
+    if( !g_designateVotes.integer )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: Designate votes have been disabled.\n\"" );
+      return;
+    }
+	  
+    if( level.clients[ clientNum ].pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: player is already a designated builder\n\"" );
+      return;
+    }
+    Com_sprintf( level.teamVoteString[ cs_offset ],
+      sizeof( level.teamVoteString[ cs_offset ] ), "!designate %i", clientNum );
+    Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+        sizeof( level.teamVoteDisplayString[ cs_offset ] ),
+        "Make '%s' a designated builder", name );
+  }
+  else if( !Q_stricmp( arg1, "undesignate" ) )
+  {
+	  
+    if( !g_designateVotes.integer )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: Designate votes have been disabled.\n\"" );
+      return;
+    }
+	  
+    if( !level.clients[ clientNum ].pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: player is not currently a designated builder\n\"" );
+      return;
+    }
+    Com_sprintf( level.teamVoteString[ cs_offset ],
+      sizeof( level.teamVoteString[ cs_offset ] ), "!undesignate %i", clientNum );
+    Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+        sizeof( level.teamVoteDisplayString[ cs_offset ] ),
+        "Remove designated builder status from '%s'", name );
+  }
   else if( !Q_stricmp( arg1, "admitdefeat" ) )
   {
     Com_sprintf( level.teamVoteString[ cs_offset ],
@@ -1391,12 +1963,18 @@
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Admit Defeat" );
   }
+   else if( !Q_stricmp( arg1, "poll" ) )
+   {
+     Com_sprintf( level.teamVoteString[ cs_offset ], sizeof( level.teamVoteString[ cs_offset ] ), nullstring );
+     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+         sizeof( level.voteDisplayString ), "[Poll] \'%s\'", arg2plus );
+   }
   else
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities,
        "print \"Valid team vote commands are: "
-       "kick, denybuild, allowbuild and admitdefeat\n\"" );
+       "kick, denybuild, allowbuild, poll, designate, undesignate, and admitdefeat\n\"" );
     return;
   }
   ent->client->pers.voteCount++;
@@ -1407,13 +1985,24 @@
       continue;
 
     if( level.clients[ i ].ps.stats[ STAT_PTEAM ] == team )
+    {
       trap_SendServerCommand( i, va("print \"%s " S_COLOR_WHITE
-            "called a team vote\n\"", ent->client->pers.netname ) );
+            "called a team vote: %s^7 \n\"", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] ) );
+    }
+    else if( ( !Q_stricmp( arg1, "kick" ) || !Q_stricmp( arg1, "denybuild" ) ) && G_admin_permission( &g_entities[ i ], ADMF_ADMINCHAT ) )
+    {
+      trap_SendServerCommand( i, va("print \"^6[Admins]^7 %s " S_COLOR_WHITE
+            "called a team vote: %s^7 \n\"", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] ) );
+    }
   }
+  
+  if(team==PTE_ALIENS)
+    G_LogPrintf("Teamvote: %s^7 called a teamvote (aliens): %s^7\n", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] );
+  else if(team==PTE_HUMANS)
+    G_LogPrintf("Teamvote: %s^7 called a teamvote (humans): %s^7\n", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] );
 
   // start the voting, the caller autoamtically votes yes
   level.teamVoteTime[ cs_offset ] = level.time;
-  level.teamVoteYes[ cs_offset ] = 1;
   level.teamVoteNo[ cs_offset ] = 0;
 
   for( i = 0 ; i < level.maxclients ; i++ )
@@ -1422,7 +2011,15 @@
       level.clients[ i ].ps.eFlags &= ~EF_TEAMVOTED;
   }
 
-  ent->client->ps.eFlags |= EF_TEAMVOTED;
+  if( !Q_stricmp( arg1, "poll" ) )
+  {
+    level.teamVoteYes[ cs_offset ] = 0;
+  }
+  else
+  {
+   level.teamVoteYes[ cs_offset ] = 1;
+   ent->client->ps.eFlags |= EF_TEAMVOTED;
+  }
 
   trap_SetConfigstring( CS_TEAMVOTE_TIME + cs_offset, va( "%i", level.teamVoteTime[ cs_offset ] ) );
   trap_SetConfigstring( CS_TEAMVOTE_STRING + cs_offset, level.teamVoteDisplayString[ cs_offset ] );
@@ -1583,9 +2180,7 @@
   int       clientNum;
   int       i;
   vec3_t    infestOrigin;
-  int       allowedClasses[ PCL_NUM_CLASSES ];
-  int       numClasses = 0;
-  pClass_t  currentClass = ent->client->ps.stats[ STAT_PCLASS ];
+  pClass_t  currentClass = ent->client->pers.classSelection;
   pClass_t  newClass;
   int       numLevels;
   int       entityList[ MAX_GENTITIES ];
@@ -1594,30 +2189,101 @@
   int       num;
   gentity_t *other;
 
-  if( ent->client->ps.stats[ STAT_HEALTH ] <= 0 )
-    return;
 
   clientNum = ent->client - level.clients;
   trap_Argv( 1, s, sizeof( s ) );
+  newClass = BG_FindClassNumForName( s );
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_BUILDER0 ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_BUILDER0;
+  if( ent->client->sess.sessionTeam == TEAM_SPECTATOR )
+  {
+    if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+      G_StopFollowing( ent );
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_BUILDER0_UPG ) &&
-      BG_FindStagesForClass( PCL_ALIEN_BUILDER0_UPG, g_alienStage.integer ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_BUILDER0_UPG;
+    if( ent->client->pers.teamSelection == PTE_ALIENS )
+    {
+      if( newClass != PCL_ALIEN_BUILDER0 &&
+          newClass != PCL_ALIEN_BUILDER0_UPG &&
+          newClass != PCL_ALIEN_LEVEL0 )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"You cannot spawn with class %s\n\"", s ) );
+        return;
+      } 
+      
+      if( !BG_ClassIsAllowed( newClass ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"Class %s is not allowed\n\"", s ) );
+        return;
+      }
+      
+      if( !BG_FindStagesForClass( newClass, g_alienStage.integer ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"Class %s not allowed at stage %d\n\"",
+              s, g_alienStage.integer ) );
+        return;
+      }
+      
+      if( ent->client->pers.denyBuild && ( newClass==PCL_ALIEN_BUILDER0 || newClass==PCL_ALIEN_BUILDER0_UPG ) )
+      {
+        trap_SendServerCommand( ent-g_entities, "print \"Your building rights have been revoked\n\"" );
+        return;
+      }	
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_LEVEL0 ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_LEVEL0;
+      // spawn from an egg
+      if( G_PushSpawnQueue( &level.alienSpawnQueue, clientNum ) )
+      {
+        ent->client->pers.classSelection = newClass;
+        ent->client->ps.stats[ STAT_PCLASS ] = newClass;
+      }
+    }
+    else if( ent->client->pers.teamSelection == PTE_HUMANS )
+    {
+      //set the item to spawn with
+      if( !Q_stricmp( s, BG_FindNameForWeapon( WP_MACHINEGUN ) ) &&
+          BG_WeaponIsAllowed( WP_MACHINEGUN ) )
+      {
+        ent->client->pers.humanItemSelection = WP_MACHINEGUN;
+      }
+      else if( !Q_stricmp( s, BG_FindNameForWeapon( WP_HBUILD ) ) &&
+               BG_WeaponIsAllowed( WP_HBUILD ) )
+      {
+        ent->client->pers.humanItemSelection = WP_HBUILD;
+      }
+      else if( !Q_stricmp( s, BG_FindNameForWeapon( WP_HBUILD2 ) ) &&
+               BG_WeaponIsAllowed( WP_HBUILD2 ) &&
+               BG_FindStagesForWeapon( WP_HBUILD2, g_humanStage.integer ) )
+      {
+        ent->client->pers.humanItemSelection = WP_HBUILD2;
+      }
+      else
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"Unknown starting item\n\"" );
+        return;
+      }
+      // spawn from a telenode
+      G_LogOnlyPrintf("ClientTeamClass: %i human %s\n", clientNum, s);
+      if( G_PushSpawnQueue( &level.humanSpawnQueue, clientNum ) )
+      {
+        ent->client->pers.classSelection = PCL_HUMAN;
+        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
+      }
+    }
+    return;
+  }
 
+  if( ent->health <= 0 )
+    return;
+
   if( ent->client->pers.teamSelection == PTE_ALIENS &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING ) )
   {
-    newClass = BG_FindClassNumForName( s );
     if( newClass == PCL_NONE )
     {
-      trap_SendServerCommand( ent-g_entities, va( "print \"Unknown class\n\"" ) );
+      trap_SendServerCommand( ent-g_entities, "print \"Unknown class\n\"" );
       return;
     }
 
@@ -1627,7 +2293,8 @@
       if( ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) ||
           ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING ) )
       {
-        trap_SendServerCommand( ent-g_entities, va( "print \"You cannot evolve while wallwalking\n\"" ) );
+        trap_SendServerCommand( ent-g_entities,
+          "print \"You cannot evolve while wallwalking\n\"" );
         return;
       }
 
@@ -1655,11 +2322,13 @@
       }
 
       //guard against selling the HBUILD weapons exploit
-      if( ( currentClass == PCL_ALIEN_BUILDER0 ||
+       if( ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
+           ( currentClass == PCL_ALIEN_BUILDER0 ||
             currentClass == PCL_ALIEN_BUILDER0_UPG ) &&
           ent->client->ps.stats[ STAT_MISC ] > 0 )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_A_EVOLVEBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities,
+            va( "print \"You cannot evolve until build timer expires\n\"" ) );
         return;
       }
 
@@ -1674,6 +2343,8 @@
             BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
             BG_ClassIsAllowed( newClass ) )
         {
+          G_LogOnlyPrintf("ClientTeamClass: %i alien %s\n", clientNum, s);
+
           ent->client->pers.evolveHealthFraction = (float)ent->client->ps.stats[ STAT_HEALTH ] /
             (float)BG_FindHealthForClass( currentClass );
 
@@ -1693,7 +2364,7 @@
         else
         {
           trap_SendServerCommand( ent-g_entities,
-               va( "print \"You cannot evolve from your current class\n\"" ) );
+               "print \"You cannot evolve from your current class\n\"" );
           return;
         }
       }
@@ -1703,27 +2374,8 @@
         return;
       }
     }
-    else
-    {
-      //spawning from an egg
-      for( i = 0; i < numClasses; i++ )
-      {
-        if( allowedClasses[ i ] == newClass &&
-            BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
-            BG_ClassIsAllowed( newClass ) )
-        {
-          ent->client->pers.classSelection =
-            ent->client->ps.stats[ STAT_PCLASS ] = newClass;
-          G_PushSpawnQueue( &level.alienSpawnQueue, clientNum );
-          return;
-        }
-      }
-      trap_SendServerCommand( ent-g_entities, va( "print \"You cannot spawn as this class\n\"" ) );
-      return;
-    }
-  }
-  else if( ent->client->pers.teamSelection == PTE_HUMANS )
-  {
+   else if( ent->client->pers.teamSelection == PTE_HUMANS )
+   {
     //humans cannot use this command whilst alive
     if( ent->client->pers.classSelection != PCL_NONE )
     {
@@ -1749,11 +2401,36 @@
       return;
     }
 
+    G_LogOnlyPrintf("ClientTeamClass: %i human %s\n", clientNum, s);
+
     G_PushSpawnQueue( &level.humanSpawnQueue, clientNum );
   }
+ }
 }
 
+/*
+=================
+DBCommand
 
+Send command to all designated builders of selected team
+=================
+*/
+void DBCommand( pTeam_t team, const char *text )
+{
+  int i;
+  gentity_t *ent;
+
+  for( i = 0, ent = g_entities + i; i < level.maxclients; i++, ent++ )
+  {
+    if( !ent->client || ( ent->client->pers.connected != CON_CONNECTED ) ||
+        ( ent->client->pers.teamSelection != team ) ||
+	!ent->client->pers.designatedBuilder )
+      continue;
+
+    trap_SendServerCommand( i, text );
+  }
+}
+
 /*
 =================
 Cmd_Destroy_f
@@ -1779,7 +2456,20 @@
     deconstruct = qfalse;
 
   if( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING )
-    G_Damage( ent->client->hovel, ent, ent, forward, ent->s.origin, 10000, 0, MOD_SUICIDE );
+  {
+    if( ( ent->client->hovel->s.eFlags & EF_DBUILDER ) &&
+      !ent->client->pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities, 
+        "print \"This structure is protected by designated builder\n\"" );
+      DBCommand( ent->client->pers.teamSelection,
+        va( "print \"%s^3 has attempted to decon a protected structure!\n\"",
+	ent->client->pers.netname ) );
+      return;
+    }
+    G_Damage( ent->client->hovel, ent, ent, forward, ent->s.origin, 
+      10000, 0, MOD_SUICIDE );
+  }
 
   if( !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) )
   {
@@ -1801,6 +2491,17 @@
         traceEnt->deconstruct = qfalse;
         return;
       }
+      if( ( traceEnt->s.eFlags & EF_DBUILDER ) &&
+        !ent->client->pers.designatedBuilder )
+      {
+        trap_SendServerCommand( ent-g_entities, 
+          "print \"This structure is protected by designated builder\n\"" );
+        DBCommand( ent->client->pers.teamSelection,
+          va( "print \"%s^3 has attempted to decon a protected structure!\n\"",
+	  ent->client->pers.netname ) );
+        return;
+      }
+ 
 
       // Prevent destruction of the last spawn
       if( !g_markDeconstruct.integer )
@@ -1824,9 +2525,16 @@
         return;
 
       // Don't allow destruction of buildables that cannot be rebuilt
-      if( G_TimeTilSuddenDeath( ) <= 0 &&
-          BG_FindBuildPointsForBuildable( traceEnt->s.modelindex ) )
+      if(g_suddenDeath.integer && traceEnt->health > 0 &&
+          ( ( g_suddenDeathMode.integer == SDMODE_SELECTIVE &&
+              !BG_FindReplaceableTestForBuildable( traceEnt->s.modelindex ) ) ||
+            ( g_suddenDeathMode.integer == SDMODE_BP &&
+              BG_FindBuildPointsForBuildable( traceEnt->s.modelindex ) ) ||
+            g_suddenDeathMode.integer == SDMODE_NO_BUILD ) )
       {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"During Sudden Death you can only decon buildings that "
+          "can be rebuilt\n\"" );
         return;
       }
 
@@ -1836,7 +2544,7 @@
         return;
       }
 
-      if( traceEnt->health > 0 )
+      if( traceEnt->health > 0 || g_deconDead.integer )
       {
         if( g_markDeconstruct.integer )
         {
@@ -1845,16 +2553,36 @@
         }
         else
         {
-          G_TeamCommand( ent->client->pers.teamSelection,
-            va( "print \"%s ^3DECONSTRUCTED^7 by %s^7\n\"",
-              BG_FindHumanNameForBuildable( traceEnt->s.modelindex ), 
-              ent->client->pers.netname ) );
+          if( traceEnt->health > 0 )
+	  {		  
+            buildHistory_t *new;
+		  
+            new = G_Alloc( sizeof( buildHistory_t ) );
+            new->ID = ( ++level.lastBuildID > 1000 ) 
+                ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+            new->ent = ent;
+            new->name[ 0 ] = 0;
+            new->buildable = traceEnt->s.modelindex;
+            VectorCopy( traceEnt->s.pos.trBase, new->origin );
+            VectorCopy( traceEnt->s.angles, new->angles );
+            VectorCopy( traceEnt->s.origin2, new->origin2 );
+            VectorCopy( traceEnt->s.angles2, new->angles2 );
+            new->fate = BF_DECONNED;
+            new->next = NULL;
+            new->marked = NULL;
+            G_LogBuild( new );
+		  
+            G_TeamCommand( ent->client->pers.teamSelection,
+              va( "print \"%s ^3DECONSTRUCTED^7 by %s^7\n\"",
+                BG_FindHumanNameForBuildable( traceEnt->s.modelindex ), 
+                ent->client->pers.netname ) );
 
-          G_LogPrintf( "Decon: %i %i 0: %s deconstructed %s\n",
-            ent->client->ps.clientNum,
-            traceEnt->s.modelindex,
-            ent->client->pers.netname, 
-            BG_FindNameForBuildable( traceEnt->s.modelindex ) );
+            G_LogPrintf( "Decon: %i %i 0: %s^7 deconstructed %s\n",
+              ent->client->ps.clientNum,
+              traceEnt->s.modelindex,
+              ent->client->pers.netname, 
+              BG_FindNameForBuildable( traceEnt->s.modelindex ) );
+	  }
 
           if( !deconstruct )
             G_Damage( traceEnt, ent, ent, forward, tr.endpos, 10000, 0, MOD_SUICIDE );
@@ -2019,7 +2747,8 @@
         !G_BuildableRange( ent->client->ps.origin, 100, BA_H_REPEATER ) &&
         !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
     {
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOENERGYAMMOHERE );
+      trap_SendServerCommand( ent-g_entities, va(
+        "print \"You must be near a reactor, repeater or armoury\n\"" ) );
       return;
     }
   }
@@ -2028,7 +2757,7 @@
     //no armoury nearby
     if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
     {
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOARMOURYHERE );
+      trap_SendServerCommand( ent-g_entities, va( "print \"You must be near a powered armoury\n\"" ) );
       return;
     }
   }
@@ -2144,19 +2873,6 @@
       G_GiveClientMaxAmmo( ent, buyingEnergyAmmo );
     else
     {
-      if( upgrade == UP_BATTLESUIT )
-      {
-        vec3_t newOrigin;
-
-        if( !G_RoomForClassChange( ent, PCL_HUMAN_BSUIT, newOrigin ) )
-        {
-          G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITON );
-          return;
-        }
-        VectorCopy( newOrigin, ent->s.pos.trBase );
-        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN_BSUIT;
-      }
-
       //add to inventory
       BG_AddUpgradeToInventory( upgrade, ent->client->ps.stats );
     }
@@ -2202,7 +2918,7 @@
   //no armoury nearby
   if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
   {
-    G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOARMOURYHERE );
+    trap_SendServerCommand( ent-g_entities, va( "print \"You must be near a powered armoury\n\"" ) );
     return;
   }
 
@@ -2225,7 +2941,7 @@
       if( ( weapon == WP_HBUILD || weapon == WP_HBUILD2 ) &&
           ent->client->ps.stats[ STAT_MISC ] > 0 )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_H_ARMOURYBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities, va( "print \"Cannot sell until build timer expires\n\"" ) );
         return;
       }
 
@@ -2250,21 +2966,6 @@
     //remove upgrade if carried
     if( BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) )
     {
-      // shouldn't really need to test for this, but just to be safe
-      if( upgrade == UP_BATTLESUIT )
-      {
-        vec3_t newOrigin;
-
-        if( !G_RoomForClassChange( ent, PCL_HUMAN, newOrigin ) )
-        {
-          G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITOFF );
-          return;
-        }
-        VectorCopy( newOrigin, ent->s.pos.trBase );
-        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
-      }
-
-      //add to inventory
       BG_RemoveUpgradeFromInventory( upgrade, ent->client->ps.stats );
 
       if( upgrade == UP_BATTPACK )
@@ -2282,7 +2983,7 @@
       if( ( i == WP_HBUILD || i == WP_HBUILD2 ) &&
           ent->client->ps.stats[ STAT_MISC ] > 0 )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_H_ARMOURYBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities, va( "print \"Cannot sell until build timer expires\n\"" ) );
         continue;
       }
 
@@ -2308,21 +3009,6 @@
       if( BG_InventoryContainsUpgrade( i, ent->client->ps.stats ) &&
           BG_FindPurchasableForUpgrade( i ) )
       {
-
-        // shouldn't really need to test for this, but just to be safe
-        if( i == UP_BATTLESUIT )
-        {
-          vec3_t newOrigin;
-
-          if( !G_RoomForClassChange( ent, PCL_HUMAN, newOrigin ) )
-          {
-            G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITOFF );
-            continue;
-          }
-          VectorCopy( newOrigin, ent->s.pos.trBase );
-          ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
-        }
-
         BG_RemoveUpgradeFromInventory( i, ent->client->ps.stats );
 
         if( i == UP_BATTPACK )
@@ -2386,6 +3072,33 @@
   trap_Argv( 1, s, sizeof( s ) );
 
   buildable = BG_FindBuildNumForName( s );
+
+
+  if( g_suddenDeath.integer)
+  {
+    if( g_suddenDeathMode.integer == SDMODE_SELECTIVE )
+    {
+      if( !BG_FindReplaceableTestForBuildable( buildable ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"This building type cannot be rebuilt during Sudden Death\n\"" );
+        return;
+      }
+      if( G_BuildingExists( buildable ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"You can only rebuild one of each type of rebuildable building during Sudden Death.\n\"" );
+        return;
+      }
+    }
+    else if( g_suddenDeathMode.integer == SDMODE_NO_BUILD )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Building is not allowed during Sudden Death\n\"" );
+      return;
+    }
+  }
+
   team = ent->client->ps.stats[ STAT_PTEAM ];
 
   if( buildable != BA_NONE &&
@@ -2467,23 +3180,215 @@
   if( ent->client->pers.cmd.buttons & BUTTON_WALKING )
     return;
 
-  if( ent->client->ps.stats[ STAT_STAMINA ] > 0 )
+  if( ( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) &&
+      ( ent->client->ps.stats[ STAT_STAMINA ] > 0 ) )
     ent->client->ps.stats[ STAT_STATE ] |= SS_SPEEDBOOST;
 }
 
 /*
 =================
+Cmd_Protect_f
+=================
+*/
+void Cmd_Protect_f( gentity_t *ent )
+{
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt;
+
+  if( !ent->client->pers.designatedBuilder )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"Only designated"
+        " builders can toggle structure protection.\n\"" );
+    return;
+  }
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) &&
+      ( traceEnt->biteam == ent->client->pers.teamSelection ) )
+  {
+    if( traceEnt->s.eFlags & EF_DBUILDER )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Structure protection removed\n\"" );
+      traceEnt->s.eFlags &= ~EF_DBUILDER;
+    }
+    else
+    {
+      trap_SendServerCommand( ent-g_entities, 
+        "print \"Structure protection applied\n\"" );
+      traceEnt->s.eFlags |= EF_DBUILDER;
+    }
+  }
+}
+
+ /*
+ =================
+ Cmd_Resign_f
+ =================
+ */
+ void Cmd_Resign_f( gentity_t *ent )
+ {
+   if( !ent->client->pers.designatedBuilder )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"You are not a designated builder\n\"" );
+     return;
+   }
+ 
+   ent->client->pers.designatedBuilder = qfalse;
+   trap_SendServerCommand( -1, va(
+     "print \"%s" S_COLOR_WHITE " has resigned\n\"",
+     ent->client->pers.netname ) );
+   G_CheckDBProtection( );
+ }
+ 
+ 
+
+/*
+=================
 Cmd_Reload_f
 =================
 */
 void Cmd_Reload_f( gentity_t *ent )
 {
-  if( ent->client->ps.weaponstate != WEAPON_RELOADING )
+  if( ( ent->client->ps.weapon >= WP_ABUILD ) &&
+    ( ent->client->ps.weapon <= WP_HBUILD ) )
+  {
+    Cmd_Protect_f( ent );
+  }
+  else if( ent->client->ps.weaponstate != WEAPON_RELOADING )
     ent->client->ps.pm_flags |= PMF_WEAPON_RELOAD;
 }
 
+
 /*
 =================
+Cmd_MyStats_f
+=================
+*/
+void Cmd_MyStats_f( gentity_t *ent )
+{
+
+   if(!ent) return;
+	   
+
+   if( !level.intermissiontime && ent->client->pers.statscounters.timeLastViewed && (level.time - ent->client->pers.statscounters.timeLastViewed) <60000 ) 
+   {   
+     ADMP( "You may only check your stats once per minute and during intermission.\n");
+     return;
+   }
+   
+   if( !g_myStats.integer )
+   {
+    ADMP( "myStats has been disabled\n");
+    return;
+   }
+   
+   ADMP( G_statsString( &ent->client->pers.statscounters, &ent->client->pers.teamSelection ) );
+   ent->client->pers.statscounters.timeLastViewed = level.time;
+  	
+  return;
+}
+
+char *G_statsString( statsCounters_t *sc, pTeam_t *pt )
+{
+  char *s;
+  
+  int percentNearBase=0;
+  int percentJetpackWallwalk=0;
+  int percentHeadshots=0;
+	
+  if( sc->timealive )
+   percentNearBase = (int)(100 *  (float) sc->timeinbase / ((float) (sc->timealive ) ) );
+  
+	
+  if( *pt == PTE_ALIENS )
+  {
+    if( sc->dretchbasytime > 0 )
+     percentJetpackWallwalk = (int)(100 *  (float) sc->jetpackusewallwalkusetime / ((float) ( sc->dretchbasytime) ) );
+    
+    if( sc->hitslocational )
+      percentHeadshots = (int)(100 * (float) sc->headshots / ((float) (sc->hitslocational) ) );
+    
+    s = va( "^3Kills:^7 %3i ^3StructKills:^7 %3i ^3Assists:^7 %3i^7 ^3Poisons:^7 %3i ^3Headshots:^7 %3i (%3i)\n^3Deaths:^7 %3i ^3Feeds:^7 %3i ^3Suicides:^7 %3i ^3Teamkills:^7 %3i\n^3Damage to:^7 ^3Enemies:^7 %5i ^3Structs:^7 %5i ^3Friendlies:^7 %3i \n^3Structs Built:^7 %3i ^3Time Near Base:^7 %3i ^3Time wallwalking:^7 %i\n",
+     sc->kills,
+     sc->structskilled,
+     sc->assists,
+     sc->repairspoisons,
+     sc->headshots,
+     percentHeadshots,
+     sc->deaths,
+     sc->feeds,
+     sc->suicides,
+     sc->teamkills,
+     sc->dmgdone,
+     sc->structdmgdone,
+     sc->ffdmgdone,
+     sc->structsbuilt,
+     percentNearBase,
+     percentJetpackWallwalk
+         );	
+  }
+  else if( *pt == PTE_HUMANS )
+  {
+    if( sc->timealive )
+     percentJetpackWallwalk = (int)(100 *  (float) sc->jetpackusewallwalkusetime / ((float) ( sc->timealive ) ) );
+    s = va( "^3Kills:^7 %3i ^3StructKills:^7 %3i ^3Assists:^7 %3i \n^3Deaths:^7 %3i ^3Feeds:^7 %3i ^3Suicides:^7 %3i ^3Teamkills:^7 %3i\n^3Damage to:^7 ^3Enemies:^7 %5i ^3Structs:^7 %5i ^3Friendlies:^7 %3i \n^3Structs Built:^7 %3i ^3Repairs:^7 %4i ^3Time Near Base:^7 %3i ^3Time Jetpacking:^7 %3i\n",
+     sc->kills,
+     sc->structskilled,
+     sc->assists,
+     sc->deaths,
+     sc->feeds,
+     sc->suicides,
+     sc->teamkills,
+     sc->dmgdone,
+     sc->structdmgdone,
+     sc->ffdmgdone,
+     sc->structsbuilt,
+     sc->repairspoisons,
+     percentNearBase,
+     percentJetpackWallwalk
+         );	
+  }
+  else s="No stats available\n";
+	
+  return s;
+}
+
+
+
+/*
+=================
+G_StopFromFollowing
+
+stops any other clients from following this one
+called when a player leaves a team or dies
+=================
+*/
+void G_StopFromFollowing( gentity_t *ent )
+{
+  int i;
+
+  for( i = 0; i < level.maxclients; i++ )
+  {
+    if( level.clients[ i ].sess.spectatorState == SPECTATOR_FOLLOW &&
+        level.clients[ i ].sess.spectatorClient == ent-g_entities )
+    {
+      if( !G_FollowNewClient( &g_entities[ i ], 1 ) )
+        G_StopFollowing( &g_entities[ i ] );
+    }
+  }
+}
+
+/*
+=================
 G_StopFollowing
 
 If the client being followed leaves the game, or you just want to drop
@@ -2494,10 +3399,27 @@
 {
   ent->client->ps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;
   ent->client->sess.sessionTeam = TEAM_SPECTATOR;
-  ent->client->sess.spectatorState = SPECTATOR_FREE;
+  ent->client->ps.stats[ STAT_PTEAM ] = ent->client->pers.teamSelection;
+
+  if( ent->client->pers.teamSelection == PTE_NONE )
+  {
+    ent->client->sess.spectatorState = SPECTATOR_FREE;
+  }
+  else
+  {
+    vec3_t   spawn_origin, spawn_angles;
+
+    ent->client->sess.spectatorState = SPECTATOR_LOCKED;
+    if( ent->client->pers.teamSelection == PTE_ALIENS )
+      G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+    else if( ent->client->pers.teamSelection == PTE_HUMANS )
+      G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+    G_SetOrigin( ent, spawn_origin );
+    VectorCopy( spawn_origin, ent->client->ps.origin );
+    G_SetClientViewAngle( ent, spawn_angles );
+  }
   ent->client->sess.spectatorClient = -1;
   ent->client->ps.pm_flags &= ~PMF_FOLLOW;
-  ent->client->ps.stats[ STAT_PTEAM ] = PTE_NONE;
 
   ent->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBING;
   ent->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBINGCEILING;
@@ -2562,8 +3484,19 @@
       continue;
 
     // can't follow another spectator
-    if( level.clients[ clientnum ].sess.sessionTeam == TEAM_SPECTATOR )
-      continue;
+     if( level.clients[ clientnum ].pers.teamSelection == PTE_NONE )
+       continue;
+     
+      // can only follow teammates when dead and on a team
+     if( ent->client->pers.teamSelection != PTE_NONE && 
+         ( level.clients[ clientnum ].pers.teamSelection != 
+           ent->client->pers.teamSelection ) )
+       continue;
+     
+     // cannot follow a teammate who is following you
+     if( level.clients[ clientnum ].sess.spectatorState == SPECTATOR_FOLLOW && 
+         ( level.clients[ clientnum ].sess.spectatorClient == ent->s.number ) )
+       continue;
 
     // this is good, we can use it
     ent->client->sess.spectatorClient = clientnum;
@@ -2584,7 +3517,7 @@
 {
   if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
     G_StopFollowing( ent );
-  else if( ent->client->sess.spectatorState == SPECTATOR_FREE )
+  else
     G_FollowNewClient( ent, 1 );
 }
 
@@ -2598,13 +3531,18 @@
   int   i;
   int   pids[ MAX_CLIENTS ];
   char  arg[ MAX_TOKEN_CHARS ];
+	
+  if( ent->client->sess.sessionTeam != TEAM_SPECTATOR )
+  {
+    trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow unless you are dead or on the spectators.\n\"" );
+    return;
+  }
 
   if( trap_Argc( ) != 2 )
   {
     G_ToggleFollow( ent );
   }
-  else if( ent->client->sess.spectatorState == SPECTATOR_FREE ||
-           ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+  else
   {
     trap_Argv( 1, arg, sizeof( arg ) );
     if( G_ClientNumbersFromString( arg, pids ) == 1 )
@@ -2625,12 +3563,27 @@
 
     // can't follow self
     if( &level.clients[ i ] == ent->client )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow yourself.\n\"" );
       return;
+    }
 
     // can't follow another spectator
-    if( level.clients[ i ].pers.teamSelection == PTE_NONE )
+    if( level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow another spectator.\n\"" );
       return;
+    }
 
+    // can only follow teammates when dead and on a team
+    if( ent->client->pers.teamSelection != PTE_NONE && 
+        ( level.clients[ i ].pers.teamSelection != 
+          ent->client->pers.teamSelection ) )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You can only follow teammates, and only when you are dead.\n\"" );
+      return;
+    }
+
     ent->client->sess.spectatorState = SPECTATOR_FOLLOW;
     ent->client->sess.spectatorClient = i;
   }
@@ -2651,9 +3604,10 @@
     dir = -1;
 
   // won't work unless spectating
-  if( ent->client->sess.spectatorState == SPECTATOR_NOT )
-    return;
-
+   if( ent->client->sess.sessionTeam != TEAM_SPECTATOR )
+     return;
+   if( ent->client->sess.spectatorState == SPECTATOR_NOT )
+     return;
   G_FollowNewClient( ent, dir );
 }
 
@@ -2819,6 +3773,327 @@
   }
 }
 
+ /*
+ =================
+ Cmd_Share_f
+ =================
+ */
+ void Cmd_Share_f( gentity_t *ent )
+ {
+   int   i, clientNum = 0, creds = 0, skipargs = 0;
+   int   clientNums[ MAX_CLIENTS ] = { -1 };
+   char  cmd[ 12 ];
+   char  arg1[ MAX_STRING_TOKENS ];
+   char  arg2[ MAX_STRING_TOKENS ];
+   pTeam_t team;
+   
+   if( !ent || !ent->client || ( ent->client->pers.teamSelection == PTE_NONE ) )
+   {
+     return;
+   }
+   
+   if( !g_allowShare.integer )
+   {
+ 	  
+    trap_SendServerCommand( ent-g_entities,
+    "print \"Share has been disabled.\n\"" );
+ 
+     return;
+   }
+   
+   if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+ 
+   team = ent->client->pers.teamSelection;
+ 
+   G_SayArgv( 0, cmd, sizeof( cmd ) );
+   if( !Q_stricmp( cmd, "say" ) || !Q_stricmp( cmd, "say_team" ) )
+   {
+     skipargs = 1;
+     G_SayArgv( 1, cmd, sizeof( cmd ) );
+   }
+ 
+   // target player name is in arg1
+   G_SayArgv( 1+skipargs, arg1, sizeof( arg1 ) );
+   // amount to be shared is in arg2
+   G_SayArgv( 2+skipargs, arg2, sizeof( arg2 ) );
+ 
+   if( arg1[0] && !strchr( arg1, ';' ) && Q_stricmp( arg1, "target_in_aim" ) )
+   {
+     //check arg1 is a number
+     for( i = 0; arg1[ i ]; i++ )
+     {
+       if( arg1[ i ] < '0' || arg1[ i ] > '9' )
+       {
+         clientNum = -1;
+         break;
+       }
+     }
+ 
+     if( clientNum >= 0 )
+     {
+       clientNum = atoi( arg1 );
+     }
+     else if( G_ClientNumbersFromString( arg1, clientNums ) == 1 )
+     {
+       // there was one partial name match
+       clientNum = clientNums[ 0 ]; 
+     }
+     else
+     {
+       // look for an exact name match before bailing out
+       clientNum = G_ClientNumberFromString( ent, arg1 );
+       if( clientNum == -1 )
+       {
+         trap_SendServerCommand( ent-g_entities,
+           "print \"share: invalid player name specified.\n\"" );
+         return;
+       }
+     }
+   }
+   else // arg1 not set
+   {
+     vec3_t      forward, end;
+     trace_t     tr;
+     gentity_t   *traceEnt;
+ 
+     
+     // trace a teammate
+     AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+     VectorMA( ent->client->ps.origin, 8192 * 16, forward, end );
+ 
+     trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number, MASK_PLAYERSOLID );
+     traceEnt = &g_entities[ tr.entityNum ];
+ 
+     if( tr.fraction < 1.0f && traceEnt->client &&
+       ( traceEnt->client->pers.teamSelection == team ) )
+     {
+       clientNum = traceEnt - g_entities;
+     }
+     else
+     {
+       trap_SendServerCommand( ent-g_entities,
+         va( "print \"share: aim at a teammate to share %s.\n\"",
+         ( team == PTE_HUMANS ) ? "credits" : "evolvepoints" ) );
+       return;
+     }
+   }
+ 
+   // verify target player team
+   if( ( clientNum < 0 ) || ( clientNum >= level.maxclients ) ||
+       ( level.clients[ clientNum ].pers.teamSelection != team ) )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"share: not a valid player of your team.\n\"" );
+     return;
+   }
+ 
+   if( !arg2[0] || strchr( arg2, ';' ) )
+   {
+     // default credit count
+     if( team == PTE_HUMANS )
+     {
+       creds = FREEKILL_HUMAN;
+     }
+     else if( team == PTE_ALIENS )
+     {
+       creds = FREEKILL_ALIEN;
+     }
+   }
+   else
+   {
+     //check arg2 is a number
+     for( i = 0; arg2[ i ]; i++ )
+     {
+       if( arg2[ i ] < '0' || arg2[ i ] > '9' )
+       {
+         trap_SendServerCommand( ent-g_entities,
+           "print \"usage: share [name|slot#] [amount]\n\"" );
+         break;
+       }
+     }
+ 
+     // credit count from parameter
+     creds = atoi( arg2 );
+   }
+ 
+   // player specified "0" to transfer
+   if( creds <= 0 )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"Ooh, you are a generous one, indeed!\n\"" );
+     return;
+   }
+ 
+   // transfer only credits the player really has
+   if( creds > ent->client->pers.credit )
+   {
+     creds = ent->client->pers.credit;
+   }
+ 
+   // player has no credits
+   if( creds <= 0 )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"Earn some first, lazy gal!\n\"" );
+     return;
+   }
+ 
+   // allow transfers only up to the credit/evo limit
+   if( ( team == PTE_HUMANS ) && 
+       ( creds > HUMAN_MAX_CREDITS - level.clients[ clientNum ].pers.credit ) )
+   {
+     creds = HUMAN_MAX_CREDITS - level.clients[ clientNum ].pers.credit;
+   }
+   else if( ( team == PTE_ALIENS ) && 
+       ( creds > ALIEN_MAX_KILLS - level.clients[ clientNum ].pers.credit ) )
+   {
+     creds = ALIEN_MAX_KILLS - level.clients[ clientNum ].pers.credit;
+   }
+ 
+   // target cannot take any more credits
+   if( creds <= 0 )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       va( "print \"share: player cannot receive any more %s.\n\"",
+         ( team == PTE_HUMANS ) ? "credits" : "evolvepoints" ) );
+     return;
+   }
+ 
+   // transfer credits
+   G_AddCreditToClient( ent->client, -creds, qfalse );
+   trap_SendServerCommand( ent-g_entities,
+     va( "print \"share: transferred %d %s to %s^7.\n\"", creds,
+       ( team == PTE_HUMANS ) ? "credits" : "evolvepoints",
+       level.clients[ clientNum ].pers.netname ) );
+   G_AddCreditToClient( &(level.clients[ clientNum ]), creds, qtrue );
+   trap_SendServerCommand( clientNum,
+     va( "print \"You have received %d %s from %s^7.\n\"", creds,
+       ( team == PTE_HUMANS ) ? "credits" : "evolvepoints",
+       ent->client->pers.netname ) );
+ 
+   G_LogPrintf( "Share: %i %i %i %d: %s^7 transferred %d%s to %s^7\n",
+     ent->client->ps.clientNum,
+     clientNum,
+     team,
+     creds,
+     ent->client->pers.netname,
+     creds,
+     ( team == PTE_HUMANS ) ? "c" : "e",
+     level.clients[ clientNum ].pers.netname );
+ }
+ 
+ /*
+ =================
+ Cmd_Donate_f
+ 
+ Alms for the poor
+ =================
+ */
+ void Cmd_Donate_f( gentity_t *ent ) {
+   char s[ MAX_TOKEN_CHARS ] = "", *type = "evo(s)";
+   int i, value, divisor, portion, new_credits, total=0,
+     max = ALIEN_MAX_KILLS, *amounts;
+   qboolean donated = qtrue;
+ 
+   if( !ent->client ) return;
+ 	  
+   if( !g_allowShare.integer )
+   {
+ 	  
+    trap_SendServerCommand( ent-g_entities,
+    "print \"Donate has been disabled.\n\"" );
+ 
+     return;
+   }
+   
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+ 
+ 
+   if( ent->client->pers.teamSelection == PTE_ALIENS )
+     divisor = level.numAlienClients-1;
+   else if( ent->client->pers.teamSelection == PTE_HUMANS ) {
+     divisor = level.numHumanClients-1;
+     max = HUMAN_MAX_CREDITS;
+     type = "credit(s)";
+   } else {
+     trap_SendServerCommand( ent-g_entities,
+       va( "print \"donate: spectators cannot be so gracious\n\"" ) );
+     return;
+   }
+ 
+   if( divisor < 1 ) {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"donate: get yourself some teammates first\n\"" );
+     return;
+   }
+ 
+   trap_Argv( 1, s, sizeof( s ) );
+   value = atoi(s);
+   if( value <= 0 ) {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"donate: very funny\n\"" );
+     return;
+   }
+   if( value > ent->client->pers.credit)
+     value = ent->client->pers.credit;
+ 
+   // allocate memory for distribution amounts
+   amounts = G_Alloc( level.maxclients * sizeof( int ) );
+   for( i = 0; i < level.maxclients; i++ ) amounts[ i ] = 0;
+ 
+   // determine donation amounts for each client
+   total = value;
+   while( donated && value ) {
+     donated = qfalse;
+     portion = value / divisor;
+     if( portion < 1 ) portion = 1;
+     for( i = 0; i < level.maxclients; i++ )
+       if( level.clients[ i ].pers.connected == CON_CONNECTED &&
+            ent->client != level.clients + i &&
+            level.clients[ i ].pers.teamSelection ==
+            ent->client->pers.teamSelection ) {
+         new_credits = level.clients[ i ].pers.credit + portion;
+         amounts[ i ] = portion;
+         if( new_credits > max ) {
+           amounts[ i ] -= new_credits - max;
+           new_credits = max;
+         }
+         if( amounts[ i ] ) {
+	   G_AddCreditToClient( &(level.clients[ i ]), amounts[ i ], qtrue );
+           donated = qtrue;
+           value -= amounts[ i ];
+           if( value < portion ) break;
+         }
+       }
+   }
+ 
+   // transfer funds
+   G_AddCreditToClient( ent->client, value - total, qtrue );
+   for( i = 0; i < level.maxclients; i++ )
+     if( amounts[ i ] ) {
+       trap_SendServerCommand( i,
+         va( "print \"%s^7 donated %d %s to you, don't forget to say 'thank you'!\n\"",
+         ent->client->pers.netname, amounts[ i ], type ) );
+     }
+ 
+   G_Free( amounts );
+ 
+   trap_SendServerCommand( ent-g_entities,
+     va( "print \"Donated %d %s to the cause.\n\"",
+     total-value, type ) );
+ }
+ 
+
 commands_t cmds[ ] = {
   // normal commands
   { "team", 0, Cmd_Team_f },
@@ -2830,13 +4105,19 @@
   { "tell", CMD_MESSAGE, Cmd_Tell_f },
   { "callvote", CMD_MESSAGE, Cmd_CallVote_f },
   { "callteamvote", CMD_MESSAGE|CMD_TEAM, Cmd_CallTeamVote_f },
+  { "say_area", CMD_MESSAGE|CMD_TEAM, Cmd_SayArea_f },
   // can be used even during intermission
   { "say", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
   { "say_team", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "say_admins", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "a", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
   { "m", CMD_MESSAGE|CMD_INTERMISSION, G_PrivateMessage },
   { "mt", CMD_MESSAGE|CMD_INTERMISSION, G_PrivateMessage },
+  { "me", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "me_team", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
 
   { "score", CMD_INTERMISSION, ScoreboardMessage },
+  { "mystats", CMD_TEAM|CMD_INTERMISSION, Cmd_MyStats_f },
 
   // cheats
   { "give", CMD_CHEAT|CMD_TEAM|CMD_LIVING, Cmd_Give_f },
@@ -2853,9 +4134,9 @@
   { "ptrcverify", 0, Cmd_PTRCVerify_f },
   { "ptrcrestore", 0, Cmd_PTRCRestore_f },
 
-  { "follow", CMD_NOTEAM, Cmd_Follow_f },
-  { "follownext", CMD_NOTEAM, Cmd_FollowCycle_f },
-  { "followprev", CMD_NOTEAM, Cmd_FollowCycle_f },
+  { "follow", 0, Cmd_Follow_f },
+  { "follownext", 0, Cmd_FollowCycle_f },
+  { "followprev", 0, Cmd_FollowCycle_f },
 
   { "where", CMD_TEAM, Cmd_Where_f },
   { "teamvote", CMD_TEAM, Cmd_TeamVote_f },
@@ -2870,7 +4151,11 @@
   { "itemdeact", CMD_HUMAN|CMD_LIVING, Cmd_DeActivateItem_f },
   { "itemtoggle", CMD_HUMAN|CMD_LIVING, Cmd_ToggleItem_f },
   { "reload", CMD_HUMAN|CMD_LIVING, Cmd_Reload_f },
-  { "boost", CMD_HUMAN|CMD_LIVING, Cmd_Boost_f }
+  { "boost", 0, Cmd_Boost_f },
+  { "share", CMD_TEAM, Cmd_Share_f },
+  { "donate", CMD_TEAM, Cmd_Donate_f },
+  { "protect", CMD_TEAM|CMD_LIVING, Cmd_Protect_f },
+  { "resign", CMD_TEAM, Cmd_Resign_f }
 };
 static int numCmds = sizeof( cmds ) / sizeof( cmds[ 0 ] );
 
@@ -2907,7 +4192,7 @@
 
   // do tests here to reduce the amount of repeated code
 
-  if( !( cmds[ i ].cmdFlags & CMD_INTERMISSION ) && level.intermissiontime )
+  if( !( cmds[ i ].cmdFlags & CMD_INTERMISSION ) && ( level.intermissiontime || level.paused ) )
     return;
 
   if( cmds[ i ].cmdFlags & CMD_CHEAT && !g_cheats.integer )
@@ -2918,7 +4203,11 @@
   }
 
   if( cmds[ i ].cmdFlags & CMD_MESSAGE && ent->client->pers.muted )
+  {
+    trap_SendServerCommand( clientNum,
+      "print \"You are muted and cannot use message commands.\n\"" );
     return;
+  }
 
   if( cmds[ i ].cmdFlags & CMD_TEAM &&
       ent->client->pers.teamSelection == PTE_NONE )
@@ -3098,6 +4387,13 @@
     ADMP( "Sorry, but private messages have been disabled\n" );
     return;
   }
+  
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
 
   G_SayArgv( 0, cmd, sizeof( cmd ) );
   if( !Q_stricmp( cmd, "say" ) || !Q_stricmp( cmd, "say_team" ) )
@@ -3148,6 +4444,17 @@
 
   color = teamonly ? COLOR_CYAN : COLOR_YELLOW;
 
+  if( !Q_stricmp( name, "console" ) )
+  {
+    ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+    ADMP( va( "^%csent to Console.\n", color ) );
+
+    G_LogPrintf( "privmsg: %s^7: Console: ^6%s^7\n",
+      ( ent ) ? ent->client->pers.netname : "Console", msg );
+
+    return;
+  }
+
   Q_strncpyz( str,
     va( "^%csent to %i player%s: ^7", color, matches,
       ( matches == 1 ) ? "" : "s" ),
@@ -3169,12 +4476,7 @@
       color,
       msg,
       ent ? ent-g_entities : -1 ) );
-    if( ent )
-    {
-      trap_SendServerCommand( pids[ i ], va(
-        "print \">> to reply, say: /m %d [your message] <<\n\"",
-        ( ent - g_entities ) ) ); 
-    }
+
     trap_SendServerCommand( pids[ i ], va( 
       "cp \"^%cprivate message from ^7%s^7\"", color,
       ( ent ) ? ent->client->pers.netname : "console" ) );
@@ -3185,10 +4487,12 @@
       name ) );
   else
   {
-    ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+    if( ent )
+      ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+
     ADMP( va( "%s\n", str ) );
 
-    G_LogPrintf( "%s: %s: %s: %s\n",
+    G_LogPrintf( "%s: %s^7: %s^7: %s\n",
       ( teamonly ) ? "tprivmsg" : "privmsg",
       ( ent ) ? ent->client->pers.netname : "console",
       name, msg );
Index: src/cgame/cg_tutorial.c
===================================================================
--- src/cgame/cg_tutorial.c	(revision 966)
+++ src/cgame/cg_tutorial.c	(working copy)
@@ -533,40 +533,34 @@
 */
 static void CG_SpectatorText( char *text, playerState_t *ps )
 {
-  if( ps->pm_flags & PMF_FOLLOW )
+  if( cgs.clientinfo[ cg.clientNum ].team != PTE_NONE )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to return to free spectator mode\n",
-          CG_KeyNameForCommand( "+button2" ) ) );
-
-    if( CG_PlayerCount( ) > 1 )
-    {
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s or ",
-            CG_KeyNameForCommand( "weapprev" ) ) );
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "%s to change player\n",
-            CG_KeyNameForCommand( "weapnext" ) ) );
-    }
+        va( "Press %s to spawn\n", CG_KeyNameForCommand( "+attack" ) ) );
   }
-  else if( ps->pm_type == PM_SPECTATOR )
+  else 
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to join a team\n",
-          CG_KeyNameForCommand( "+attack" ) ) );
+        va( "Press %s to join a team\n", CG_KeyNameForCommand( "+attack" ) ) );
+  }
 
-    if( CG_PlayerCount( ) > 0 )
-    {
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s to enter spectator follow mode\n",
-            CG_KeyNameForCommand( "+button2" ) ) );
-    }
+  if( ps->pm_flags & PMF_FOLLOW )
+  {
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "Press %s to stop following\n",
+          CG_KeyNameForCommand( "+button2" ) ) );
+
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "Press %s or ", CG_KeyNameForCommand( "weapprev" ) ) );
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "%s to change player\n", CG_KeyNameForCommand( "weapnext" ) ) );
   }
   else
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to spawn\n",
-          CG_KeyNameForCommand( "+attack" ) ) );
+        va( "Press %s to follow a %s\n", CG_KeyNameForCommand( "+button2" ),
+          ( cgs.clientinfo[ cg.clientNum ].team == PTE_NONE )
+            ? "player" : "teammate" ) );
   }
 }
 
